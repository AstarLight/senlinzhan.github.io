<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/7/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/page/7/"/>

  <title> Hexo </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Hexo</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/03/16/Linux文件管理/" itemprop="url">
                  Linux 系统：文件操作
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-03-16T15:21:52+08:00" content="2015-03-16">
              2015-03-16
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/系统管理/" itemprop="url" rel="index">
                    <span itemprop="name">系统管理</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h2><p>　　每个 Linux 文件都有相应的权限，根据这个权限，我们可以判断文件是否可读、可写或可运行。例如：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ ls -l /etc/passwd</div><div class="line">-rw-r--r-- 1 root root 1870  9月 17 01:08 /etc/passwd</div></pre></td></tr></table></figure></p>
<p>　　可以看到，<code>-rw-r--r--</code>表示文件的权限，但注意，即使是同一文件，对不同的用户和群组来说，文件的权限都是不同的，我们可以将文件权限分成四个部分：<br><img src="/images/data-structure/ama.png" alt=""><br>　　第一部分表示文件的类型，这里<code>-</code>表示文件是一般的文件，此外，对于文件夹来说，通常使用<code>d</code>来表示文件的类型。第二部分表示用户的权限，第三部分表示群组的权限，最后一部分表示其它的权限。<br>　　在表示权限时，<code>r</code>表示文件是可读的，<code>w</code>表示文件是可写的，<code>x</code>则表示文件是可执行的，<code>-</code>则不代表什么。例如，<code>/etc/passwd</code>文件的拥有者是<code>root</code>的权限是<code>rw-</code>，这表示<code>root</code>用户可以对文件进行读和写，而<code>root</code>群组的权限是<code>r--</code>，因此，<code>root</code>群组的用户可以读文件，但不能写文件。此外，一般的用户也只能以只读方式访问文件。<br>　　有时，在一些可执行文件的权限中，其可执行权限是<code>s</code>而不是<code>x</code>，这表示，在执行文件时，将以文件拥有者的身份来执行，例如，对于<code>root</code>用户来说，<code>/usr/bin/passwd</code>的权限是<code>rws</code>：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ ls -l /usr/bin/passwd</div><div class="line">-rwsr-xr-x 1 root root 45420  2月 17  2014 /usr/bin/passwd</div><div class="line">ls -l /etc/shadow</div><div class="line">-rw-r----- 1 root shadow 1072  9月 17 01:08 /etc/shadow</div></pre></td></tr></table></figure></p>
<p>　　可以看到，对于普通用户来说，可以执行<code>/usr/bin/passwd</code>程序来更改用户密码，但是，更改密码意味着需要修改<code>/etc/shadow</code>这个文件。我们知道，只有<code>root</code>用户才能修改<code>/etc/shadow</code>这个文件，那么，普通用户怎样才能执行<code>/usr/bin/passwd</code>程序来修改<code>/etc/shadow</code>文件呢？<br>　　实际上，当普通用户执行<code>/usr/bin/passwd</code>时，由于<code>/usr/bin/passwd</code>的拥有者是<code>root</code>，因此，普通用户将暂时转成<code>root</code>用户，来执行<code>/usr/bin/passwd</code>，这时就可以修改<code>/etc/shadow</code>文件了。</p>
<h2 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h2><p>　　可以使用<code>chmod</code>命令来修改文件的去权限，例如，对于文件<code>file</code>，给群组和其它用户增加可读权限：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ chmod g+r file</div><div class="line">$ chmod o+r file</div></pre></td></tr></table></figure></p>
<p>　　或者使用：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ chomd go+r file</div></pre></td></tr></table></figure></p>
<p>　　此外，可以使用数字的方式给文件赋予权限。例如，要给文件赋予<code>-rwx--x--x</code>权限，那么可以使用：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ chmod 711 file</div></pre></td></tr></table></figure></p>
<p>　　实际上，<code>7</code>用三位的二进制表示为<code>111</code>，也就代表<code>rwx</code>，而<code>1</code>用三位的二进制表示为<code>001</code>，也即代表<code>--x</code>了。<br>　　此外，可以使用<code>umask</code>来设置文件的默认权限。例如：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ umask</div><div class="line">0002</div></pre></td></tr></table></figure></p>
<p>　　可以看到，默认的掩码值是<code>0002</code>。那么，这时，我们创建一个新的文件<code>file</code>，但在此之前将掩码值设置为<code>0000</code>，可以看到：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ umask 0000</div><div class="line">$ &gt; file</div><div class="line">$ ls -l file</div><div class="line">-rw-rw-rw- 1 senlin senlin 0  3月 17 14:37 file</div></pre></td></tr></table></figure></p>
<p>　　实际上，掩码的作用是用来删除相应的权限，例如，掩码<code>0002</code>对于的二进制数为<code>000 000 000 010</code>，当这个掩码作用于文件时，文件的权限将从原来的<code>-rw-rw-rw-</code>变成<code>-rw-rw-r--</code>，例如：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ umask 0002</div><div class="line">$ &gt; file1</div><div class="line">$ ls -l file1</div><div class="line">-rw-rw-r-- 1 senlin senlin 0  3月 17 14:41 file1</div></pre></td></tr></table></figure></p>
<h2 id="符号链接"><a href="#符号链接" class="headerlink" title="符号链接"></a>符号链接</h2><p>　　符号链接通常作为另一文件或文件夹的别名，例如：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ ls -l workspace</div><div class="line">lrwxrwxrwx 1 senlin senlin 30  9月 16 22:05 workspace -&gt; /home/senlin/KuaiPan/workspace</div></pre></td></tr></table></figure></p>
<p>　　可以看到，文件类型<code>l</code>表示这个文件是符号链接。实际上，符号链接的权限总是<code>rwxrwxrwx</code>，但这个权限并不是实际文件的权限。注意，符号链接所指向的文件或文件夹实际上也可能并不存在。可以使用<code>ln -s</code>命令来创建符号链接，例如：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ln -s /etc/passwd passwd</div></pre></td></tr></table></figure></p>
<h2 id="压缩解压"><a href="#压缩解压" class="headerlink" title="压缩解压"></a>压缩解压</h2><p>　　可以使用<code>gzip</code>来压缩文件，例如，将<code>file</code>压缩成为<code>file.gz</code>，可以这样做：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gzip file</div></pre></td></tr></table></figure></p>
<p>　　相应可以对压缩文件进行解压，例如，将<code>file.gz</code>解压成<code>file</code>，可以这样：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gunzip file.gz</div></pre></td></tr></table></figure></p>
<p>　　实际上<code>gzip</code>无法创建归档文件。我们可以使用<code>tar</code>命令来创建归档文件，例如：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ tar cvf total.tar file1 file2</div></pre></td></tr></table></figure></p>
<p>　　这样就可以将文件<code>file1</code>和<code>file2</code>归档成<code>total.tar</code>。其中，<code>c</code>选项使得<code>tar</code>处于创建模式，<code>v</code>选项使得<code>tar</code>输出归档文件中的文件名和文件夹，而<code>f</code>选项之后需要立即接相应的文件名，因此，<code>f</code>选项应该放在最后。<br>　　相应的，可以对归档文件进行解包，<code>x</code>选项使得<code>tar</code>命令处于提取模式：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ tar xvf total.tar</div></pre></td></tr></table></figure></p>
<p>　　那么这时就可以得到<code>file1</code>和<code>file2</code>这两个文件了。但注意，有时我们仅需要提取归档文件中的一部分，例如，我们可以只提取<code>file1</code>文件：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ tar xvf total.tar file1</div></pre></td></tr></table></figure></p>
<p>　　这样就只得到<code>file1</code>了。当然，为了只提取归档文件的一部分，我们首先需要知道归档文件中包含哪些文件，这时可以使用<code>t</code>选项：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ tar tvf total.tar </div><div class="line">-rw-rw-r-- senlin/senlin     0 2015-03-16 20:46 file1</div><div class="line">-rw-rw-r-- senlin/senlin     0 2015-03-16 20:46 file2</div></pre></td></tr></table></figure></p>
<p>　　注意，在提取文件时，可以额外指定<code>p</code>选项，用来保留归档文件中文件的权限<code>(permission)</code>。<br>　　有时需要处理以<code>.tar.gz</code>为后缀的文件，这时，可以先使用<code>gunzip</code>来进行解压，得到归档文件，接着，再使用<code>tar</code>命令来提取归档文件：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ gunzip total.tar.gz </div><div class="line">$ tar xvf total.tar </div><div class="line">file1</div><div class="line">file2</div></pre></td></tr></table></figure></p>
<p>　　当然，我们可以组合使用解压和解包操作，例如：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ zcat total.tar.gz | tar xvf -</div><div class="line">file1</div><div class="line">file2</div></pre></td></tr></table></figure></p>
<p>　　其中，<code>zcat</code>命令等同于<code>gunzip -dc</code>，<code>d</code>选项表示解压，而<code>c</code>选项表示将解压的内容发送到标准输出。而<code>tar</code>命令的<code>f</code>选项后的<code>-</code>表示读取标准输入的内容。<br>　　另外，还有更简便的做法，在解包归档文件是，给<code>tar</code>指定<code>z</code>选项表示使用<code>gunzip</code>来进行解压：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ tar zxvf total.tar.gz </div><div class="line">file1</div><div class="line">file2</div></pre></td></tr></table></figure></p>
<p>　　同样，也可以访问<code>.tar.gz</code>文件的目录：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ tar ztvf total.tar.gz </div><div class="line">-rw-rw-r-- senlin/senlin     0 2015-03-16 20:46 file1</div><div class="line">-rw-rw-r-- senlin/senlin     0 2015-03-16 20:46 file2</div></pre></td></tr></table></figure></p>
<p>　　在创建模式下，也可以直接创建<code>.tar.gz</code>文件：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ tar zcvf total.tar.gz file1 file2</div><div class="line">file1</div><div class="line">file2</div></pre></td></tr></table></figure></p>
<p>　　与<code>gzip</code>和<code>gunzip</code>工具类似，我们也可以使用<code>bzip2</code>和<code>bunzip2</code>工具来分别压缩或解压<code>.bz2</code>的文件：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ tar jcvf total.tar.bz2 file1 file2</div><div class="line">file1</div><div class="line">file2</div></pre></td></tr></table></figure></p>
<p>　　通过指定给<code>tar</code>指定<code>j</code>选项来调用<code>bzip2</code>工具。同样，也可从归档压缩文件中直接提取文件：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ tar jxvf total.tar.bz2</div><div class="line">file1</div><div class="line">file2</div></pre></td></tr></table></figure></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.amazon.com/How-Linux-Works-Superuser-Should/dp/1593275676/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1426490449&amp;sr=1-1&amp;keywords=how+linux+works" target="_blank" rel="external">How Linux Works 2nd Edition: What Every Superuser Should Know</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/03/13/多项式乘法与加法/" itemprop="url">
                  多项式的算法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-03-13T11:03:40+08:00" content="2015-03-13">
              2015-03-13
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/算法分析/" itemprop="url" rel="index">
                    <span itemprop="name">算法分析</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>　　在数值计算中，有时我们需要对多项式进行相加或相乘，此外，还经常需要对多项式进行求值。例如，假定我们需要对两个多项式进行乘法运算：<br><img src="/images/data-structure/dmp.png" alt=""></p>
<h2 id="多项式的表示"><a href="#多项式的表示" class="headerlink" title="多项式的表示"></a>多项式的表示</h2><p>　　我们可以定义一个<code>Poly</code>类用来表示多项式，在<code>Poly</code>中，我们使用数组来存储多项式的系数，由于系数作为数组的元素，那么系数对应的下标就是多项式的幂，例如，假定我们使用<code>Poly</code>来表示多项式<img src="/images/data-structure/dmr.png" alt="">，那么数组的结构就如下图所示：<br><img src="/images/data-structure/dm.png" alt=""><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">class</span> Poly</div><div class="line">&#123;</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</div><div class="line">    <span class="keyword">friend</span> Poly&lt;Type&gt; plus( <span class="keyword">const</span> Poly&lt;Type&gt; &amp;, <span class="keyword">const</span> Poly&lt;Type&gt; &amp; );</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</div><div class="line">    <span class="keyword">friend</span> Poly&lt;Type&gt; multiply( <span class="keyword">const</span> Poly&lt;Type&gt; &amp;, <span class="keyword">const</span> Poly&lt;Type&gt; &amp; );</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</div><div class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::ostream &amp;<span class="keyword">operator</span>&lt;&lt;( <span class="built_in">std</span>::ostream &amp;, <span class="keyword">const</span> Poly&lt;Type&gt; &amp; );</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Poly( T coefficient, <span class="keyword">int</span> power )</div><div class="line">        : size_&#123; power + <span class="number">1</span> &#125;, arr_( size_, T&#123; <span class="number">0</span> &#125; ) &#123;</div><div class="line">            arr_[power] = coefficient;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">double</span> <span class="title">evaluate</span><span class="params">( <span class="keyword">double</span> value )</span> <span class="keyword">const</span></span>;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">int</span> size_;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; arr_;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="built_in">std</span>::ostream &amp;<span class="keyword">operator</span>&lt;&lt;( <span class="built_in">std</span>::ostream &amp;os, <span class="keyword">const</span> Poly&lt;T&gt; &amp;poly ) &#123;</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; poly.size_; ++i ) &#123;</div><div class="line">        <span class="keyword">if</span>( poly.arr_[i] != <span class="number">0</span> ) &#123;</div><div class="line">            os &lt;&lt; poly.arr_[i] &lt;&lt; <span class="string">"x^"</span> &lt;&lt; i </div><div class="line">               &lt;&lt; ( i != poly.size_ - <span class="number">1</span> ? <span class="string">" +"</span> : <span class="string">""</span> ) &lt;&lt; <span class="string">" "</span>;   </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> os;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="/images/data-structure/apo.png" alt=""></p>
<h2 id="多项式的加法"><a href="#多项式的加法" class="headerlink" title="多项式的加法"></a>多项式的加法</h2><p>　　在对多项式进行加法运算时，我们需要对幂相同的项系数进行累加：　　<br><img src="/images/data-structure/dm4.png" alt=""><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line">Poly&lt;T&gt; plus( <span class="keyword">const</span> Poly&lt;T&gt; &amp;first, <span class="keyword">const</span> Poly&lt;T&gt; &amp;second ) &#123;</div><div class="line">    <span class="keyword">int</span> maxPower = <span class="built_in">std</span>::max( first.size_ - <span class="number">1</span>, second.size_ - <span class="number">1</span> );</div><div class="line">    Poly&lt;T&gt; newPoly( T&#123; <span class="number">0</span> &#125;, maxPower );</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; first.size_; ++i ) &#123;</div><div class="line">        newPoly.arr_[i] += first.arr_[i];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; second.size_; ++i ) &#123;</div><div class="line">        newPoly.arr_[i] += second.arr_[i];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> newPoly;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="多项式的乘法"><a href="#多项式的乘法" class="headerlink" title="多项式的乘法"></a>多项式的乘法</h2><p>　　在对多项式进行乘法运算时，我们可以使用乘法分配率：<br><img src="/images/data-structure/dm5.png" alt=""><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line">Poly&lt;T&gt; multiply( <span class="keyword">const</span> Poly&lt;T&gt; &amp;first, <span class="keyword">const</span> Poly&lt;T&gt; &amp;second ) &#123;</div><div class="line">    <span class="keyword">int</span> totalPower = ( first.size_ - <span class="number">1</span> ) + ( second.size_ - <span class="number">1</span> );</div><div class="line">    Poly&lt;T&gt; newPoly( T&#123; <span class="number">0</span> &#125;, totalPower );</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; first.size_; ++i ) &#123;</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; second.size_; ++j ) &#123;</div><div class="line">            newPoly.arr_[i + j] += first.arr_[i] * second.arr_[j];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> newPoly;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="多项式的求值"><a href="#多项式的求值" class="headerlink" title="多项式的求值"></a>多项式的求值</h2><p><img src="/images/data-structure/dda.png" alt=""><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">double</span> Poly&lt;T&gt;::evaluate( <span class="keyword">double</span> value ) <span class="keyword">const</span> &#123;</div><div class="line">    <span class="keyword">double</span> result = <span class="number">0.0</span>;</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = size_ - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i ) &#123;</div><div class="line">        result = result * value + arr_[i];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　我们可以编写一个测试程序，验证以下多项式乘法：<br><img src="/images/data-structure/dmo.png" alt=""><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">auto</span> poly1 = plus( Poly&lt;<span class="keyword">double</span>&gt;( <span class="number">1</span>, <span class="number">0</span> ), </div><div class="line">                       plus( Poly&lt;<span class="keyword">double</span>&gt;( <span class="number">-1</span>, <span class="number">1</span> ), </div><div class="line">                             plus( Poly&lt;<span class="keyword">double</span>&gt;( <span class="number">0.5</span>, <span class="number">2</span> ), </div><div class="line">                                   Poly&lt;<span class="keyword">double</span>&gt;( <span class="number">-1.0</span>/<span class="number">6.0</span>, <span class="number">3</span> ) ) ) );</div><div class="line">    <span class="keyword">auto</span> poly2 = plus( Poly&lt;<span class="keyword">double</span>&gt;( <span class="number">1</span>, <span class="number">0</span> ),</div><div class="line">                       plus( Poly&lt;<span class="keyword">double</span>&gt;( <span class="number">1</span>, <span class="number">1</span> ),</div><div class="line">                             plus( Poly&lt;<span class="keyword">double</span>&gt;( <span class="number">1</span>, <span class="number">2</span> ),</div><div class="line">                                   Poly&lt;<span class="keyword">double</span>&gt;( <span class="number">1</span>, <span class="number">3</span> ) ) ) );</div><div class="line">    <span class="keyword">auto</span> poly = multiply( poly1, poly2 );</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; poly &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">int</span> x = <span class="number">2</span>;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"if x is "</span> &lt;&lt; x &lt;&lt; <span class="string">", and result is "</span> &lt;&lt; poly.evaluate( x ) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　程序的运行输出：<br> <img src="/images/data-structure/dm6.png" alt=""></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.amazon.com/Algorithms-Parts-1-4-Fundamentals-Structure/dp/0201350882" target="_blank" rel="external">Algorithms in C++ 3rd Edition by Robert Sedgewick</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/02/27/图的搜索算法/" itemprop="url">
                  图算法（三）-- 无向图的搜索算法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-02-27T15:42:47+08:00" content="2015-02-27">
              2015-02-27
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/算法分析/" itemprop="url" rel="index">
                    <span itemprop="name">算法分析</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h2><p>　　我们可以使用深度优先搜索来历遍一个连通图中的所有节点：</p>
<ul>
<li>访问当前节点。</li>
<li>若与当前节点相邻的节点未曾被访问,则需要递归地访问这些相邻的节点。　　</li>
</ul>
<p>　　假定一个无向图中是连通的，使用深度优先历遍，我们最终可以历遍所有顶点。为了确保对每个顶点只进行一次访问，需要使用一个<code>bool</code>类型数组<code>visited</code>来记录顶点被访问的情况，首先将数组元素初始化为<code>false</code>，假定顶点<code>N</code>已经被访问，则<code>visited[N]</code>的值为<code>true</code>。在历遍的过程中，要是顶点还未被访问，那么就访问这个顶点，要是顶点已经被访问，那么就略过这个顶点。我们可以使用下图来表示邻接表构造的图：<br><img src="/images/data-structure/gc.png" alt="">　　<img src="/images/data-structure/gd.png" alt=""><br>　　假定我们从顶点<code>0</code>开始历遍所有顶点，那么使用深度优先搜索的历遍过程：<br><img src="/images/data-structure/ge.png" alt="">　　<img src="/images/data-structure/dfstree.png" alt=""><br>　<br>　　可以看到，从顶点<code>0</code>开始，历遍的路径为<code>0-3-4-2-1</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Edge.hpp"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ListGraph.hpp"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"DepthFirstSearch.hpp"</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span> VECTIX_NUMBER = <span class="number">5</span>;</div><div class="line">    <span class="function">ListGraph <span class="title">sparseGraph</span><span class="params">( VECTIX_NUMBER )</span></span>;</div><div class="line">    sparseGraph.addEdge( Edge( <span class="number">0</span>, <span class="number">1</span> ) );</div><div class="line">    sparseGraph.addEdge( Edge( <span class="number">0</span>, <span class="number">2</span> ) );</div><div class="line">    sparseGraph.addEdge( Edge( <span class="number">0</span>, <span class="number">3</span> ) );</div><div class="line">    sparseGraph.addEdge( Edge( <span class="number">3</span>, <span class="number">4</span> ) );</div><div class="line">    sparseGraph.addEdge( Edge( <span class="number">1</span>, <span class="number">4</span> ) );</div><div class="line">    sparseGraph.addEdge( Edge( <span class="number">2</span>, <span class="number">4</span> ) );</div><div class="line">    DepthFirstSearch&lt;ListGraph&gt; search( sparseGraph );</div><div class="line">    search.printPath( <span class="number">0</span> );</div><div class="line">    search.printPath( <span class="number">1</span> );</div><div class="line">    search.printPath( <span class="number">2</span> );</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">/***</span></div><div class="line">search path starts from vectix 0: 0 3 4 2 1 </div><div class="line">search path starts from vectix 1: 1 4 2 0 3 </div><div class="line">search path starts from vectix 2: 2 4 1 0 3 </div><div class="line">***/</div></pre></td></tr></table></figure></p>
<p>　　我们使用<code>DepthFirstSearch</code>来表示深度优先搜索算法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"> </div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Graph&gt;</div><div class="line"><span class="keyword">class</span> DepthFirstSearch</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    DepthFirstSearch( <span class="keyword">const</span> Graph &amp;g ) : graph_( g ) &#123; &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printPath</span><span class="params">( <span class="keyword">unsigned</span> vectix )</span> <span class="keyword">const</span> </span>&#123;                              <span class="comment">// 输出搜索路径</span></div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"search path starts from vectix "</span> &lt;&lt; vectix &lt;&lt; <span class="string">": "</span>;</div><div class="line">        search( vectix, []( <span class="keyword">unsigned</span> v ) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="string">" "</span>; &#125; );</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> UnaryFunction&gt;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">( <span class="keyword">unsigned</span> vectix, UnaryFunction unaryFunc )</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">        assert( vectix &lt; graph_.vectixSize() );</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visited( graph_.vectixSize(), <span class="literal">false</span> );</div><div class="line">        search( vectix, visited, unaryFunc );</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> Graph &amp;graph_;</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> UnaryFunction&gt;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">( <span class="keyword">unsigned</span> vectix, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &amp;visited, UnaryFunction unaryFunc )</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">        unaryFunc( vectix );</div><div class="line">        visited[vectix] = <span class="literal">true</span>;</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">auto</span> iter = graph_.cbegin( vectix ); iter != graph_.cend( vectix ); ++iter ) &#123;</div><div class="line">            <span class="keyword">if</span>( !visited[*iter] ) &#123;</div><div class="line">                search( *iter, visited, unaryFunc );</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>　　可以看到，要是图是连通的，我们才能历遍图的所有顶点，也就是说，<code>DepthFirstSearch</code>只能对一个连通部分进行搜索。但有时，当图具有多个连通部分时，从某一顶点出发，<code>DepthFirstSearch</code>只能搜索图中的一个连通部分。</p>
<h2 id="无向图连通性"><a href="#无向图连通性" class="headerlink" title="无向图连通性"></a>无向图连通性</h2><p>　　通常，图具有多个连通部分，例如，以下的图具有<code>3</code>个连通部分。实际上，我们可以分别给这三个连通部分编号为<code>1</code>、<code>2</code>和<code>3</code>，那么，每个顶点都唯一地存在于特定的连通部分中：<br><img src="/images/data-structure/gl.png" alt=""><br>　　例如，我们可以编写程序验证上图中不同顶点之间的连通关系：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Edge.hpp"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ListGraph.hpp"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"GraphConnectivity.hpp"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span> VECTIX_NUMBER = <span class="number">13</span>;</div><div class="line">    <span class="function">ListGraph <span class="title">sparseGraph</span><span class="params">( VECTIX_NUMBER )</span></span>;</div><div class="line">    sparseGraph.addEdge( Edge( <span class="number">0</span>, <span class="number">1</span> ) );</div><div class="line">    sparseGraph.addEdge( Edge( <span class="number">0</span>, <span class="number">2</span> ) );</div><div class="line">    sparseGraph.addEdge( Edge( <span class="number">0</span>, <span class="number">5</span> ) );</div><div class="line">    sparseGraph.addEdge( Edge( <span class="number">0</span>, <span class="number">6</span> ) );</div><div class="line">    sparseGraph.addEdge( Edge( <span class="number">3</span>, <span class="number">4</span> ) );</div><div class="line">    sparseGraph.addEdge( Edge( <span class="number">3</span>, <span class="number">5</span> ) );</div><div class="line">    sparseGraph.addEdge( Edge( <span class="number">4</span>, <span class="number">5</span> ) );</div><div class="line">    sparseGraph.addEdge( Edge( <span class="number">4</span>, <span class="number">6</span> ) );</div><div class="line">    sparseGraph.addEdge( Edge( <span class="number">7</span>, <span class="number">8</span> ) );</div><div class="line">    sparseGraph.addEdge( Edge( <span class="number">9</span>, <span class="number">10</span> ) );</div><div class="line">    sparseGraph.addEdge( Edge( <span class="number">9</span>, <span class="number">11</span> ) );</div><div class="line">    sparseGraph.addEdge( Edge( <span class="number">9</span>, <span class="number">12</span> ) );</div><div class="line">    sparseGraph.addEdge( Edge( <span class="number">11</span>, <span class="number">12</span> ) );</div><div class="line">    GraphConnectivity&lt;ListGraph&gt; connectivity( sparseGraph );</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Connectivity components number: "</span> &lt;&lt; connectivity.count() &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"All connectivity relationship: "</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; VECTIX_NUMBER; ++i ) &#123;</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">unsigned</span> j = <span class="number">0</span>; j &lt; VECTIX_NUMBER; ++j ) &#123;</div><div class="line">            <span class="keyword">if</span>( i != j &amp;&amp; connectivity.connect( i, j ) ) &#123;</div><div class="line">                <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">"-"</span> &lt;&lt; j &lt;&lt; <span class="string">" "</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">/***</span></div><div class="line">Connectivity components number: 3</div><div class="line">All connectivity relationship: </div><div class="line">0-1 0-2 0-3 0-4 0-5 0-6 </div><div class="line">1-0 1-2 1-3 1-4 1-5 1-6 </div><div class="line">2-0 2-1 2-3 2-4 2-5 2-6 </div><div class="line">3-0 3-1 3-2 3-4 3-5 3-6 </div><div class="line">4-0 4-1 4-2 4-3 4-5 4-6 </div><div class="line">5-0 5-1 5-2 5-3 5-4 5-6 </div><div class="line">6-0 6-1 6-2 6-3 6-4 6-5 </div><div class="line">7-8 </div><div class="line">8-7 </div><div class="line">9-10 9-11 9-12 </div><div class="line">10-9 10-11 10-12 </div><div class="line">11-9 11-10 11-12 </div><div class="line">12-9 12-10 12-11 </div><div class="line">***/</div></pre></td></tr></table></figure></p>
<p>　　可以看到，我们使用<code>GraphConnectivity</code>来计算每个顶点所在的连通部分，这样，要是想要判断两个顶点是否连通，只需要简单地判断这两个顶点是否存在于同一个连通部分即可：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Graph&gt;</div><div class="line"><span class="keyword">class</span> GraphConnectivity</div><div class="line">&#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> Graph &amp;graph_;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span>&gt; components_;</div><div class="line">    <span class="keyword">unsigned</span> componentCount_ = <span class="number">0</span>;</div><div class="line">    </div><div class="line"><span class="keyword">public</span>:</div><div class="line">    GraphConnectivity( <span class="keyword">const</span> Graph &amp;g )</div><div class="line">        : graph_( g ), components_( graph_.vectixSize(), <span class="number">0</span> ) &#123;</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">unsigned</span> vectix = <span class="number">0</span>; vectix &lt; graph_.vectixSize(); ++vectix ) &#123;</div><div class="line">            <span class="keyword">if</span>( components_[vectix] == <span class="number">0</span> ) &#123;</div><div class="line">                ++componentCount_;</div><div class="line">                getComponent( vectix );</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">count</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;                                    <span class="comment">// 返回连通部分的个数</span></div><div class="line">        <span class="keyword">return</span> componentCount_;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">connect</span><span class="params">( <span class="keyword">unsigned</span> first, <span class="keyword">unsigned</span> second )</span> <span class="keyword">const</span> </span>&#123;     <span class="comment">// 判断两个顶点是否连通</span></div><div class="line">        <span class="keyword">return</span> components_[first] == components_[second];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getComponent</span><span class="params">( <span class="keyword">unsigned</span> vectix )</span> </span>&#123;                      <span class="comment">// 计算 vectix 存在于哪个连通部分</span></div><div class="line">        components_[vectix] = componentCount_;</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">auto</span> iter = graph_.cbegin( vectix ); iter != graph_.cend( vectix ); ++iter ) &#123;</div><div class="line">            <span class="keyword">if</span>( components_[*iter] == <span class="number">0</span> ) &#123;</div><div class="line">                getComponent( *iter );</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><p>　　在广度优先搜索中,我们需要用到先入先出的队列来存储那些还未访问的顶点：</p>
<ul>
<li>首先,我们让起始顶点入列，那么此时队列中只含有一个顶点。</li>
<li>每次都让一个顶点出列，要是出列的顶点还未曾被访问，那么我们就访问这个顶点，接着，将与这个节点相邻的其它所有顶点都放到队列中。</li>
<li>不断地重复上一个过程,直到队列为空。</li>
</ul>
<p>　　例如，对于以下的图，我们从顶点<code>0</code>开始访问：<br><img src="/images/data-structure/gc.png" alt="">　　<img src="/images/data-structure/gd.png" alt=""><br>　　可以看到，深度优先搜索将按照<code>0-3-2-1-4</code>的顺序来访问所有顶点：<br><img src="/images/data-structure/gua.png" alt="">　　<img src="/images/data-structure/gb.png" alt=""><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Edge.hpp"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ListGraph.hpp"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"BreadFirstSearch.hpp"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span> VECTIX_NUMBER = <span class="number">5</span>;</div><div class="line">    <span class="function">ListGraph <span class="title">sparseGraph</span><span class="params">( VECTIX_NUMBER )</span></span>;</div><div class="line">    sparseGraph.addEdge( Edge( <span class="number">0</span>, <span class="number">1</span> ) );</div><div class="line">    sparseGraph.addEdge( Edge( <span class="number">0</span>, <span class="number">2</span> ) );</div><div class="line">    sparseGraph.addEdge( Edge( <span class="number">0</span>, <span class="number">3</span> ) );</div><div class="line">    sparseGraph.addEdge( Edge( <span class="number">3</span>, <span class="number">4</span> ) );</div><div class="line">    sparseGraph.addEdge( Edge( <span class="number">1</span>, <span class="number">4</span> ) );</div><div class="line">    sparseGraph.addEdge( Edge( <span class="number">2</span>, <span class="number">4</span> ) );</div><div class="line">    BreadFirstSearch&lt;ListGraph&gt; search( sparseGraph );</div><div class="line">    search.printPath( <span class="number">0</span> );</div><div class="line">    search.printPath( <span class="number">1</span> );</div><div class="line">    search.printPath( <span class="number">2</span> );</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">/***</span></div><div class="line">search path starts from vectix 0: 0 3 2 1 4 </div><div class="line">search path starts from vectix 1: 1 4 0 2 3 </div><div class="line">search path starts from vectix 2: 2 4 0 1 3 </div><div class="line">***/</div></pre></td></tr></table></figure></p>
<p>　　我们使用<code>BreadFirstSearch</code>来表示广度优先搜索算法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Graph&gt;</div><div class="line"><span class="keyword">class</span> BreadFirstSearch</div><div class="line">&#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> Graph &amp;graph_;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    BreadFirstSearch( <span class="keyword">const</span> Graph &amp;g ) : graph_( g ) &#123; &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printPath</span><span class="params">( <span class="keyword">unsigned</span> vectix )</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"search path starts from vectix "</span> &lt;&lt; vectix &lt;&lt; <span class="string">": "</span>;</div><div class="line">        search( vectix, []( <span class="keyword">unsigned</span> v ) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="string">" "</span>; &#125; );</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> UnaryFunction&gt;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">( <span class="keyword">unsigned</span> vectix, UnaryFunction unaryFunc )</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">        assert( vectix &lt; graph_.vectixSize() );</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visited( graph_.vectixSize(), <span class="literal">false</span> );</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">unsigned</span>&gt; vectixQueue;</div><div class="line">        vectixQueue.push( vectix );</div><div class="line">        <span class="keyword">while</span>( !vectixQueue.empty() ) &#123;</div><div class="line">            <span class="keyword">auto</span> front = vectixQueue.front();</div><div class="line">            vectixQueue.pop();</div><div class="line">            <span class="keyword">if</span>( !visited[front] ) &#123;</div><div class="line">                unaryFunc( front );</div><div class="line">                visited[front] = <span class="literal">true</span>;</div><div class="line">                <span class="keyword">for</span>( <span class="keyword">auto</span> iter = graph_.cbegin( front ); iter != graph_.cend( front ); ++iter ) &#123;</div><div class="line">                    <span class="keyword">if</span>( !visited[*iter] ) &#123;</div><div class="line">                        vectixQueue.push( *iter );</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.amazon.com/Algorithms-Parts-1-4-Fundamentals-Structure/dp/0201350882" target="_blank" rel="external">Algorithms in C++ 3rd Edition by Robert Sedgewick</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/02/24/图的路径搜索/" itemprop="url">
                  图算法（二）-- 无向图的路径搜索
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-02-24T13:47:11+08:00" content="2015-02-24">
              2015-02-24
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/算法分析/" itemprop="url" rel="index">
                    <span itemprop="name">算法分析</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>　　在<a href="http://senlinzhan.github.io/2015/02/23/%E5%9B%BE%E7%9A%84%E6%9E%84%E9%80%A0/" target="_blank" rel="external">图的构造</a>，我们可以使用<code>MatrixGraph</code>或<code>ListGraph</code>来构造图。通常，我们需要知道在图中任意的两个顶点是否连通，也就是在图中是否存在路径使得一个顶点可以到达另一顶点，这种问题称为图的路径搜索。</p>
<h2 id="路径连通两个顶点"><a href="#路径连通两个顶点" class="headerlink" title="路径连通两个顶点"></a>路径连通两个顶点</h2><p>　　为了判断两个顶点是否连通，可以使用<strong>深度优先搜索算法</strong>，这是一种递归的算法，例如，为了判断顶点<code>A</code>和<code>B</code>是否连通，我们可以分别判断<code>A</code>的所有相邻顶点是否存在路径到达<code>B</code>，若存在这样的路径，那就说明<code>A</code>和<code>B</code>是连通的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Graph&gt;</div><div class="line"><span class="keyword">class</span> ExistPath</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    ExistPath( <span class="keyword">const</span> Graph &amp;g )</div><div class="line">        : graph_( g ) &#123; &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 判断顶点 src 和 des 是否连通    </span></div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">connected</span><span class="params">( <span class="keyword">unsigned</span> src, <span class="keyword">unsigned</span> des )</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visited( graph_.vectixSize(), <span class="literal">false</span> );</div><div class="line">        <span class="keyword">return</span> search( src, des, visited );</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 若顶点 src 和 des 连通，则输出一条从 src 到 des 的路径</span></div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">printEdgesIfExist</span><span class="params">( <span class="keyword">unsigned</span> src, <span class="keyword">unsigned</span> des )</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"path from "</span> &lt;&lt; src &lt;&lt; <span class="string">" to "</span> &lt;&lt; des &lt;&lt; <span class="string">": "</span>;</div><div class="line">        <span class="keyword">auto</span> result = processEdgesIfExist( src, des, </div><div class="line">                                           []( <span class="keyword">unsigned</span> left, <span class="keyword">unsigned</span> right ) &#123;</div><div class="line">                                               <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; left &lt;&lt; <span class="string">"-"</span> &lt;&lt; right &lt;&lt; <span class="string">" "</span>;</div><div class="line">                                           &#125;);</div><div class="line">        <span class="keyword">if</span>( !result ) &#123;</div><div class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"does not exists!"</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> BinaryFunction&gt;</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">processEdgesIfExist</span><span class="params">( <span class="keyword">unsigned</span> src, <span class="keyword">unsigned</span> des, BinaryFunction binaryFunc )</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visited( graph_.vectixSize(), <span class="literal">false</span> );</div><div class="line">        <span class="keyword">return</span> process( des, src, visited, binaryFunc );</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> Graph &amp;graph_;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">( <span class="keyword">unsigned</span> src, <span class="keyword">unsigned</span> des, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &amp;visited )</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>( src == des ) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        visited[src] = <span class="literal">true</span>;</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">auto</span> iter = graph_.cbegin( src ); iter != graph_.cend( src ); ++iter ) &#123;</div><div class="line">            <span class="keyword">if</span>( !visited[*iter] ) &#123;</div><div class="line">                <span class="keyword">if</span>( search( *iter, des, visited ) ) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> BinaryFunction&gt;</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">process</span><span class="params">( <span class="keyword">unsigned</span> src, <span class="keyword">unsigned</span> des, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &amp;visited, </span></span></div><div class="line">                 BinaryFunction binaryFunc ) <span class="keyword">const</span> &#123;</div><div class="line">        <span class="keyword">if</span>( src == des ) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        visited[src] = <span class="literal">true</span>;</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">auto</span> iter = graph_.cbegin( src ); iter != graph_.cend( src ); ++iter ) &#123;</div><div class="line">            <span class="keyword">if</span>( !visited[*iter] ) &#123;</div><div class="line">                <span class="keyword">if</span>( process( *iter, des, visited, binaryFunc ) ) &#123;</div><div class="line">                    binaryFunc( *iter, src );</div><div class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>　　通常，我们使用<code>MatrixGraph</code>来表示密集图，而使用<code>ListGraph</code>来表示稀疏图，为了判断两个顶点是否连通，我们需要考虑<strong>最坏情况下</strong>算法的执行性能：</p>
<ul>
<li>对于密集图来说，图的大小为$V^2$，图的边数正比于$V^2$，因此，判断两个顶点是否连通，在最坏情况下，需要对每条边进行检查，算法的时间复杂度为$O(V^2)$，即与图的大小成线性关系。</li>
<li>对于稀疏图来说，图的大小为<code>V + E</code>，判断两个顶点是否连通，在最坏情况下，算法的时间复杂度为<code>O(V + E)</code>，即与图的大小成线性关系。</li>
</ul>
<p>　　使用深度优先算法通常很少会出现最坏情况，实际上判断两个顶点是否连通，有时也可能只需要检查少数的几条边即可。<br>　　我们使用以下程序构造简单的图，判断顶点<code>2</code>和顶点<code>6</code>之间是否存在路径：<br><img src="/images/data-structure/gra.png" alt=""><br>　　若顶点<code>2</code>和<code>6</code>之间存在路径，可以输出这条路径：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Edge.hpp"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ListGraph.hpp"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ExistPath.hpp"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span> VECTIX_NUMBER = <span class="number">100</span>;</div><div class="line">    <span class="function">ListGraph <span class="title">sparseGraph</span><span class="params">( VECTIX_NUMBER )</span></span>;</div><div class="line">    sparseGraph.addEdge( Edge( <span class="number">0</span>, <span class="number">1</span> ) );</div><div class="line">    sparseGraph.addEdge( Edge( <span class="number">0</span>, <span class="number">2</span> ) );</div><div class="line">    sparseGraph.addEdge( Edge( <span class="number">0</span>, <span class="number">5</span> ) );</div><div class="line">    sparseGraph.addEdge( Edge( <span class="number">0</span>, <span class="number">6</span> ) );</div><div class="line">    sparseGraph.addEdge( Edge( <span class="number">1</span>, <span class="number">2</span> ) );</div><div class="line">    sparseGraph.addEdge( Edge( <span class="number">2</span>, <span class="number">3</span> ) );</div><div class="line">    sparseGraph.addEdge( Edge( <span class="number">2</span>, <span class="number">4</span> ) );</div><div class="line">    sparseGraph.addEdge( Edge( <span class="number">3</span>, <span class="number">4</span> ) );</div><div class="line">    sparseGraph.addEdge( Edge( <span class="number">4</span>, <span class="number">5</span> ) );</div><div class="line">    sparseGraph.addEdge( Edge( <span class="number">4</span>, <span class="number">6</span> ) );</div><div class="line">    ExistPath&lt;ListGraph&gt; path( sparseGraph );</div><div class="line">    path.printEdgesIfExist( <span class="number">2</span>, <span class="number">6</span> );</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// path from 2 to 6: 2-0 0-5 5-4 4-6</span></div></pre></td></tr></table></figure></p>
<h2 id="历遍所有顶点一次"><a href="#历遍所有顶点一次" class="headerlink" title="历遍所有顶点一次"></a>历遍所有顶点一次</h2><p>　　给定两个顶点，我们可以判断这两个顶点之间是否存在路径，使得这条路径能够包含图中的<strong>所有顶点</strong>，并且每个顶点只在这条路径中<strong>出现一次</strong>。<br>　　同样，使用深度优先搜索算法。若图中的总顶点数为<code>V</code>，假定需要寻找<code>A</code>到<code>B</code>之间的路径，那么我们从<code>A</code>出发，要是在历遍的过程中经过的顶点数恰好为<code>V</code>并且路径的末尾为<code>B</code>，那么这样的路径就存在。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Graph&gt;</div><div class="line"><span class="keyword">class</span> ExistPathTraverseOnce</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    ExistPathTraverseOnce( <span class="keyword">const</span> Graph &amp;g )</div><div class="line">        : graph_( g ) &#123; &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">traverseOnce</span><span class="params">( <span class="keyword">unsigned</span> src, <span class="keyword">unsigned</span> des )</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visited( graph_.vectixSize(), <span class="literal">false</span> );</div><div class="line">        <span class="keyword">return</span> traverseOnce( src, des, visited, graph_.vectixSize() );</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">printPathIfExist</span><span class="params">( <span class="keyword">unsigned</span> src, <span class="keyword">unsigned</span> des )</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visited( graph_.vectixSize(), <span class="literal">false</span> );</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"path from "</span> &lt;&lt; src &lt;&lt; <span class="string">" to "</span> &lt;&lt; des </div><div class="line">                  &lt;&lt; <span class="string">" traverse all vectix once: "</span>;</div><div class="line">        <span class="keyword">auto</span> result = processOnce( des, src, visited, graph_.vectixSize(), </div><div class="line">                                   []( <span class="keyword">unsigned</span> left, <span class="keyword">unsigned</span> right ) &#123;</div><div class="line">                                       <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; left &lt;&lt; <span class="string">"-"</span> &lt;&lt; right &lt;&lt; <span class="string">" "</span>;</div><div class="line">                                   &#125;);</div><div class="line">        <span class="keyword">if</span>( !result ) &#123;</div><div class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"does not exists!"</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> Graph &amp;graph_;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">traverseOnce</span><span class="params">( <span class="keyword">unsigned</span> src, <span class="keyword">unsigned</span> des, </span></span></div><div class="line">                       <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &amp;visited, <span class="keyword">unsigned</span> vectixNum ) <span class="keyword">const</span> &#123;</div><div class="line">        <span class="keyword">if</span>( src == des ) &#123;</div><div class="line">            <span class="keyword">return</span> vectixNum == <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        visited[src] = <span class="literal">true</span>;</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">auto</span> iter = graph_.cbegin( src ); iter != graph_.cend( src ); ++iter ) &#123;</div><div class="line">            <span class="keyword">if</span>( !visited[*iter] ) &#123;</div><div class="line">                <span class="keyword">if</span>( traverseOnce( *iter, des, visited, vectixNum - <span class="number">1</span> ) ) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        visited[src] = <span class="literal">false</span>;                         <span class="comment">// 若路径不存在，则恢复 visited[src] 的值</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> BinaryFunction&gt;</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">processOnce</span><span class="params">( <span class="keyword">unsigned</span> src, <span class="keyword">unsigned</span> des, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &amp;visited, </span></span></div><div class="line">                      <span class="keyword">unsigned</span> vectixNum, BinaryFunction binaryFunc ) <span class="keyword">const</span> &#123;</div><div class="line">        <span class="keyword">if</span>( src == des ) &#123;</div><div class="line">            <span class="keyword">return</span> vectixNum == <span class="number">1</span>;</div><div class="line">        &#125; </div><div class="line">        visited[src] = <span class="literal">true</span>;</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">auto</span> iter = graph_.cbegin( src ); iter != graph_.cend( src ); ++iter ) &#123;</div><div class="line">            <span class="keyword">if</span>( !visited[*iter] ) &#123;</div><div class="line">                <span class="keyword">if</span>( processOnce( *iter, des, visited, vectixNum - <span class="number">1</span>, binaryFunc ) ) &#123;</div><div class="line">                    binaryFunc( *iter, src );</div><div class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        visited[src] = <span class="literal">false</span>;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>　　例如，我们构建以下的图：<br><img src="/images/data-structure/gg.png" alt=""><br>　　判断两个顶点之间是否存在路径，使得这条路径中包含图中的所有顶点，并且仅包含一次：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Edge.hpp"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ListGraph.hpp"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ExistPathTraverseOnce.hpp"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span> VECTIX_NUMBER = <span class="number">7</span>;</div><div class="line">    <span class="function">ListGraph <span class="title">sparseGraph</span><span class="params">( VECTIX_NUMBER )</span></span>;</div><div class="line">    sparseGraph.addEdge( Edge( <span class="number">0</span>, <span class="number">1</span> ) );</div><div class="line">    sparseGraph.addEdge( Edge( <span class="number">0</span>, <span class="number">2</span> ) );</div><div class="line">    sparseGraph.addEdge( Edge( <span class="number">0</span>, <span class="number">5</span> ) );</div><div class="line">    sparseGraph.addEdge( Edge( <span class="number">0</span>, <span class="number">6</span> ) );</div><div class="line">    sparseGraph.addEdge( Edge( <span class="number">1</span>, <span class="number">2</span> ) );</div><div class="line">    sparseGraph.addEdge( Edge( <span class="number">1</span>, <span class="number">3</span> ) );</div><div class="line">    sparseGraph.addEdge( Edge( <span class="number">2</span>, <span class="number">3</span> ) );</div><div class="line">    sparseGraph.addEdge( Edge( <span class="number">2</span>, <span class="number">4</span> ) );</div><div class="line">    sparseGraph.addEdge( Edge( <span class="number">3</span>, <span class="number">4</span> ) );</div><div class="line">    sparseGraph.addEdge( Edge( <span class="number">3</span>, <span class="number">5</span> ) );</div><div class="line">    sparseGraph.addEdge( Edge( <span class="number">4</span>, <span class="number">5</span> ) );</div><div class="line">    sparseGraph.addEdge( Edge( <span class="number">4</span>, <span class="number">6</span> ) );</div><div class="line">    ExistPathTraverseOnce&lt;ListGraph&gt; path( sparseGraph );</div><div class="line">    path.printPathIfExist( <span class="number">0</span>, <span class="number">6</span> );</div><div class="line">    path.printPathIfExist( <span class="number">0</span>, <span class="number">5</span> );</div><div class="line">    path.printPathIfExist( <span class="number">0</span>, <span class="number">4</span> );</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">/***</span></div><div class="line">path from 0 to 6 traverse all vectix once: 0-1 1-2 2-3 3-5 5-4 4-6 </div><div class="line">path from 0 to 5 traverse all vectix once: 0-6 6-4 4-2 2-1 1-3 3-5 </div><div class="line">path from 0 to 4 traverse all vectix once: does not exists!</div><div class="line">***/</div></pre></td></tr></table></figure></p>
<p>　　注意，在<code>traverseOnce()</code>或<code>processOnce()</code>中，要是寻找的路径不存在，需要将<code>visited[src]</code>设置成<code>false</code>。实际上，在最坏情况下，算法需要对图中的每条路径进行检查，以求找到符合条件的路径，因此，在最坏情况下，<code>printPathIfExist()</code>的为<strong>指数时间</strong>操作。</p>
<h2 id="历遍所有的边一次"><a href="#历遍所有的边一次" class="headerlink" title="历遍所有的边一次"></a>历遍所有的边一次</h2><p>　　对于特定的顶点来说，通常存在几条边与之直接相连，假定一个顶点存在<code>n</code>条边与之直接相连，那么，这个顶点的度数<code>(degree)</code>就是<code>n</code>。我们可以定义<code>Degree</code>类来存储图中所有顶点的度数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Graph&gt;</div><div class="line"><span class="keyword">class</span> Degree</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Degree( <span class="keyword">const</span> Graph &amp;g )</div><div class="line">        :graph_( g ), degree_( g.vectixSize(), <span class="number">0</span> ) &#123;</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">unsigned</span> vectix = <span class="number">0</span>; vectix &lt; g.vectixSize(); ++vectix ) &#123;</div><div class="line">            <span class="keyword">for</span>( <span class="keyword">auto</span> iter = graph_.cbegin( vectix ); iter != graph_.cend( vectix ); ++iter ) &#123;</div><div class="line">                ++degree_[vectix];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">getDegree</span><span class="params">( <span class="keyword">unsigned</span> vectix )</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">        assert( vectix &lt; graph_.vectixSize() );</div><div class="line">        <span class="keyword">return</span> degree_[vectix]; </div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> Graph &amp;graph_;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span>&gt; degree_;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>　　要是图的边数为<code>E</code>，顶点数为<code>V</code>，那么对于邻接链表来说，寻找所有顶点的度数的时间为<code>O(E)</code>，而对于邻接矩阵来说，寻找所有顶点的度数的时间则是$O(V^2)$。<br>　　对于给定的图，可以判断是否存在<code>Euler tour</code>的路径：假定我们图中的某一顶点出发，历遍图中所有的边一次，并最后到达出发时的顶点。<br>　　与之类似，对于给定的图，可以判断是否存在<code>Euler path</code>的路径：假定我们图中的某一顶点出发，历遍图中所有的边一次，并最后到达另一个顶点。<br><img src="/images/data-structure/gga.png" alt=""><br>　　判断图是否存在<code>Euler tour</code>：图是连通的，并且它的所有顶点的度数都是偶数。而判断图是否存在<code>Euler path</code>：图是连通的，并且只拥有两个顶点的度数是奇数，其余顶点的度数是偶数的。<br>　　我们可以使用<code>ExistEulerTour</code>来获得<code>Euler tour</code>路径，对于给定的图，若存在这样的路径，那么每条边的度数均为偶数。<br>　　例如，我们使用以下程序构造图，要是图存在<code>Euler tour</code>路径，那么从任一顶点出发，历遍图中所有的边一次之后将会回到出发点：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Edge.hpp"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ListGraph.hpp"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ExistEulerPath.hpp"</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span> VECTIX_NUMBER = <span class="number">7</span>;</div><div class="line">    <span class="function">ListGraph <span class="title">sparseGraph</span><span class="params">( VECTIX_NUMBER )</span></span>;</div><div class="line">    sparseGraph.addEdge( Edge( <span class="number">0</span>, <span class="number">1</span> ) );</div><div class="line">    sparseGraph.addEdge( Edge( <span class="number">0</span>, <span class="number">2</span> ) );</div><div class="line">    sparseGraph.addEdge( Edge( <span class="number">0</span>, <span class="number">5</span> ) );</div><div class="line">    sparseGraph.addEdge( Edge( <span class="number">0</span>, <span class="number">6</span> ) );</div><div class="line">    sparseGraph.addEdge( Edge( <span class="number">1</span>, <span class="number">2</span> ) );</div><div class="line">    sparseGraph.addEdge( Edge( <span class="number">2</span>, <span class="number">3</span> ) );</div><div class="line">    sparseGraph.addEdge( Edge( <span class="number">2</span>, <span class="number">4</span> ) );</div><div class="line">    sparseGraph.addEdge( Edge( <span class="number">3</span>, <span class="number">4</span> ) );</div><div class="line">    sparseGraph.addEdge( Edge( <span class="number">4</span>, <span class="number">5</span> ) );</div><div class="line">    sparseGraph.addEdge( Edge( <span class="number">4</span>, <span class="number">6</span> ) );</div><div class="line">    ExistEulerTour&lt;ListGraph, Edge&gt; path( sparseGraph );</div><div class="line">    path.printPathIfExist( <span class="number">0</span> );                          <span class="comment">// 从顶点 0 开始历遍</span></div><div class="line">    path.printPathIfExist( <span class="number">1</span> );                          <span class="comment">// 从顶点 1 开始历遍</span></div><div class="line">    path.printPathIfExist( <span class="number">2</span> );                          <span class="comment">// 从顶点 2 开始历遍</span></div><div class="line">    path.printPathIfExist( <span class="number">3</span> );                          <span class="comment">// 从顶点 3 开始历遍</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">/***</span></div><div class="line">exists Euler tour: 0-1-2-3-4-2-0-5-4-6-0</div><div class="line">exists Euler tour: 1-0-2-3-4-5-0-6-4-2-1</div><div class="line">exists Euler tour: 2-0-1-2-3-4-5-0-6-4-2</div><div class="line">exists Euler tour: 3-2-0-1-2-4-5-0-6-4-3</div><div class="line">***/</div></pre></td></tr></table></figure></p>
<p>　　实际上，在每次调用<code>ExistEulerTour</code>的<code>printPathIfExist()</code>成员函数时，我们需要创建原来图的一个副本，因为在历遍图的过程需要不断删除这个副本中的边。<br>　　每次访问一条边之后，就需要将这条边从图中删除，我们使用一个栈保存历遍过程所遇到的顶点。例如，对于以下的图，从顶点<code>0</code>开始历遍，历遍的路径以蓝色显示，每次历遍一条边时就将这条边从图中删除：<br><img src="/images/data-structure/gpa.png" alt=""><br>　　可以看到，从顶点<code>0</code>出发，经过路径<code>0-1-2-0-5-4-6-0</code>到达顶点<code>0</code>，此时还存在三条边没有被访问（图中黑色的边），这时需要在栈中弹出顶点，要是弹出的顶点拥有与之直接相连的边，那么就继续访问这些边：<br><img src="/images/data-structure/gac.png" alt=""><br>　　每次我们输出栈弹出的顶点，就可以得到逆向的历遍路径：<code>0-6-4-2-3-4-5-0-2-1-0</code>。  　　<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Degree.hpp"</span></span></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Graph, <span class="keyword">typename</span> Edge&gt;</div><div class="line"><span class="keyword">class</span> ExistEulerTour</div><div class="line">&#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> Graph &amp;graph_;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">unsigned</span>&gt; vectixStack_;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    ExistEulerTour( <span class="keyword">const</span> Graph &amp;g ) : graph_( g ) &#123; &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 判断是否存在 Euler tour </span></div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exists</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">        Degree&lt;Graph&gt; degrees( graph_ );</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">unsigned</span> vectix = <span class="number">0</span>; vectix &lt; graph_.vectixSize(); ++vectix ) &#123;</div><div class="line">            <span class="keyword">if</span>( degrees.getDegree( vectix ) % <span class="number">2</span> != <span class="number">0</span> ) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printPathIfExist</span><span class="params">( <span class="keyword">unsigned</span> vectix )</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span>( !exists() ) &#123;</div><div class="line">           <span class="keyword">return</span>;</div><div class="line">       &#125;</div><div class="line">       Graph graphCopy = graph_;                           <span class="comment">// 创建原来图的副本 graphCopy</span></div><div class="line">       vectixStack_ = <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">unsigned</span>&gt;();              <span class="comment">// 清空 vectixStack_</span></div><div class="line">       <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"exists Euler tour: "</span> &lt;&lt; vectix;</div><div class="line">       <span class="keyword">while</span>( tour( graphCopy, vectix ) == vectix &amp;&amp; !vectixStack_.empty() ) &#123;</div><div class="line">           vectix = vectixStack_.top();</div><div class="line">           vectixStack_.pop();</div><div class="line">           <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"-"</span> &lt;&lt; vectix;</div><div class="line">       &#125;</div><div class="line">       <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">tour</span><span class="params">( Graph &amp;graph, <span class="keyword">unsigned</span> vectix )</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span>( <span class="literal">true</span> ) &#123;</div><div class="line">            <span class="keyword">auto</span> iter = graph.cbegin( vectix );</div><div class="line">            <span class="keyword">if</span>( iter == graph.cend( vectix ) ) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125; </div><div class="line">            vectixStack_.push( vectix );</div><div class="line">            graph.removeEdge( Edge( vectix, *iter ) );</div><div class="line">            vectix = *iter;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> vectix;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>　　实际上，寻找<code>Euler tour</code>路径是一种高效的算法，例如，假定<code>removeEdge()</code>是常量时间操作，由于图中的每条边仅被压进栈中一次，因此，<code>printPathIfExist()</code>的复杂度为<code>O(E)</code>。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.amazon.com/Algorithms-Parts-1-4-Fundamentals-Structure/dp/0201350882" target="_blank" rel="external">Algorithms in C++ 3rd Edition by Robert Sedgewick</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/02/23/图的构造/" itemprop="url">
                  图算法（一）-- 图的构造
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-02-23T15:08:53+08:00" content="2015-02-23">
              2015-02-23
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/算法分析/" itemprop="url" rel="index">
                    <span itemprop="name">算法分析</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="图的使用"><a href="#图的使用" class="headerlink" title="图的使用"></a>图的使用</h2><p>　　我们使用整数来表示顶点，对于特定顶点<code>vectix</code>，可以输出这个顶点的所有相邻顶点：</p>
<pre><code>for( auto iter = graph.cbegin( vectix ); iter != graph.cend( vectix ); ++iter ) {
    std::cout &lt;&lt; *iter &lt;&lt; &quot; &quot;;
}  
</code></pre><p>　　我们使用以下程序构造简单的无向图，无向图中包含<code>8</code>个顶点，分别编号为<code>0</code>到<code>7</code>：<br><img src="/images/data-structure/graph1.png" alt=""><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Edge.hpp"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MatrixGraph.hpp"</span></span></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Graph&gt;</div><div class="line"><span class="keyword">class</span> GraphUtility</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">( <span class="keyword">const</span> Graph &amp;graph )</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">auto</span> vectix = <span class="number">0</span>; vectix &lt; graph.vectixSize(); ++vectix ) &#123;</div><div class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; vectix &lt;&lt; <span class="string">":  "</span>;</div><div class="line">            <span class="keyword">for</span>( <span class="keyword">auto</span> iter = graph.cbegin( vectix ); iter != graph.cend( vectix ); ++iter ) &#123;</div><div class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="string">" "</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span> VECTIX_NUMBER = <span class="number">8</span>;</div><div class="line">    <span class="function">MatrixGraph <span class="title">graph</span><span class="params">( VECTIX_NUMBER )</span></span>;</div><div class="line">    graph.addEdge( Edge( <span class="number">0</span>, <span class="number">1</span> ) );</div><div class="line">    graph.addEdge( Edge( <span class="number">0</span>, <span class="number">2</span> ) );</div><div class="line">    graph.addEdge( Edge( <span class="number">0</span>, <span class="number">5</span> ) );</div><div class="line">    graph.addEdge( Edge( <span class="number">7</span>, <span class="number">5</span> ) );</div><div class="line">    graph.addEdge( Edge( <span class="number">7</span>, <span class="number">1</span> ) );</div><div class="line">    graph.addEdge( Edge( <span class="number">7</span>, <span class="number">2</span> ) );</div><div class="line"></div><div class="line">    GraphUtility&lt;MatrixGraph&gt;::print( graph );</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">/***</span></div><div class="line">0:  1 2 5 </div><div class="line">1:  0 7 </div><div class="line">2:  0 7 </div><div class="line">3:  </div><div class="line">4:  </div><div class="line">5:  0 7 </div><div class="line">6:  </div><div class="line">7:  1 2 5 </div><div class="line">***/</div></pre></td></tr></table></figure></p>
<h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p>　　我们可以使用邻接矩阵来表示图，假定我们使用<code>matrix_</code>来表示矩阵，若顶点<code>1</code>和顶点<code>2</code>连通，那么：</p>
<ul>
<li>对于无向图，则<code>matrix_[1][2]</code>和<code>matrix_[2][1]</code>的值均为<code>true</code>。</li>
<li>对于有向图，则<code>matrix_[1][2]</code>的值为<code>true</code>。</li>
</ul>
<p>　　我们使用<code>Edge</code>来表示边：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Edge</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Edge( <span class="keyword">unsigned</span> src, <span class="keyword">unsigned</span> des ) : src_( src ), des_( des ) &#123;  &#125;</div><div class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">src</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;  <span class="keyword">return</span> src_;  &#125;</div><div class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">des</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;  <span class="keyword">return</span> des_;  &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">unsigned</span> src_;</div><div class="line">    <span class="keyword">unsigned</span> des_;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>　　假定图的顶点数目为<code>V</code>，那么我们使用<code>V</code>行<code>V</code>列矩阵作为图的底层数据结构。我们使用<code>MatrixGraph</code>表示使用邻接矩阵构造的图。注意，<code>MatrixGraph</code>中无法插入重复的边，也就是说，当传递给<code>addEdge()</code>的边已经存在于图中，那么<code>addEdge()</code>将不会对图产生任何影响。<br>　　此外，当图初始化结束之后，图中的顶点并不会连接其自身，也就是说，对于图中的顶点<code>v</code>来说，<code>matrix_[v][v]</code>的值为<code>false</code>。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div></pre></td><td class="code"><pre><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;exception&gt;</div><div class="line">#include "Edge.hpp"</div><div class="line"></div><div class="line">class MatrixGraph</div><div class="line">&#123;  </div><div class="line">private:</div><div class="line">    class InvalidEdgeException: public std::exception &#123;</div><div class="line">    public:</div><div class="line">        virtual const char * what() const throw() &#123;</div><div class="line">            return "the specify edge is invalid!";</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    class InvalidVectixException: public std::exception &#123;</div><div class="line">    public:</div><div class="line">        virtual const char * what() const throw() &#123;</div><div class="line">            return "the specify vectix is invalid!";</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    unsigned vectixNum_;                                     // 顶点的数目</div><div class="line">    unsigned edgeNum_;                                       // 边的数目</div><div class="line">    bool isDirected_;                                        // 是否为有向图</div><div class="line">    std::vector&lt;std::vector&lt;bool&gt;&gt; matrix_;                  // 矩阵</div><div class="line"></div><div class="line">public:</div><div class="line">    explicit MatrixGraph( unsigned vectixSize, bool directed = false )</div><div class="line">        : vectixNum_( vectixSize ), edgeNum_( 0 ), </div><div class="line">          isDirected_( directed ), matrix_( vectixSize ) &#123;</div><div class="line">        for( auto &amp;elem : matrix_ ) &#123;</div><div class="line">            elem.assign( vectixSize, false );</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    unsigned vectixSize() const &#123;                             // 顶点的数目</div><div class="line">        return vectixNum_;</div><div class="line">    &#125;</div><div class="line">    bool directed() const &#123;                                   // 判断是否为有向图</div><div class="line">        return isDirected_;</div><div class="line">    &#125;</div><div class="line">    unsigned edgeSize() const &#123;                               // 边的数目</div><div class="line">        return edgeNum_;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void addEdge( const Edge &amp;edge ) &#123;                        // 增加边</div><div class="line">        auto src = edge.src();</div><div class="line">        auto des = edge.des();</div><div class="line">        if( src &gt;= vectixNum_ || des &gt;= vectixNum_) &#123;</div><div class="line">            throw InvalidEdgeException();</div><div class="line">        &#125;</div><div class="line">        if( !matrix_[src][des] ) &#123;</div><div class="line">            ++edgeNum_;</div><div class="line">            matrix_[src][des] = true;</div><div class="line">            if( !isDirected_ ) &#123;</div><div class="line">                matrix_[des][src] = true;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void removeEdge( const Edge &amp;edge ) &#123;                     // 删除边</div><div class="line">        if( !hasEdge( edge ) ) &#123;</div><div class="line">            throw InvalidEdgeException();</div><div class="line">        &#125;</div><div class="line">        auto src = edge.src();</div><div class="line">        auto des = edge.des();</div><div class="line">        --edgeNum_;</div><div class="line">        matrix_[src][des] = false;</div><div class="line">        if( !isDirected_ ) &#123;</div><div class="line">            matrix_[des][src] = false;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    bool hasEdge( const Edge &amp;edge ) const &#123;                 // 判断是否存在指定的边</div><div class="line">        auto src = edge.src();</div><div class="line">        auto des = edge.des();</div><div class="line">        if( src &gt;= vectixNum_ || des &gt;= vectixNum_) &#123;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">        return matrix_[src][des];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    class constIterator</div><div class="line">    &#123;</div><div class="line">        friend class MatrixGraph;</div><div class="line">    public:</div><div class="line">        constIterator( const MatrixGraph *g, unsigned x = 0, unsigned y = 0 )</div><div class="line">            : graph_( g ), posX_( x ), posY_( y ) &#123;</div><div class="line">            for( ; posY_ &lt; graph_-&gt;vectixSize(); ++posY_ ) &#123;</div><div class="line">                if( graph_-&gt;matrix_[posX_][posY_] ) &#123;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        constIterator &amp; operator++() &#123;</div><div class="line">            for( ++posY_; posY_ &lt; graph_-&gt;vectixSize(); ++posY_ ) &#123;</div><div class="line">                if( graph_-&gt;matrix_[posX_][posY_] ) &#123;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            return *this;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        constIterator operator++( int ) &#123;</div><div class="line">            auto tmp = *this;</div><div class="line">            ++( *this );</div><div class="line">            return tmp;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        const unsigned &amp; operator*() const &#123;</div><div class="line">            return posY_;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        bool operator==( const constIterator &amp;other ) const &#123;</div><div class="line">            return graph_ == other.graph_ &amp;&amp; posX_ == other.posX_ &amp;&amp; posY_ == other.posY_;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        bool operator!=( const constIterator &amp;other ) const &#123;</div><div class="line">            return !( *this == other );</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    private:</div><div class="line">        const MatrixGraph *graph_;</div><div class="line">        unsigned posX_;</div><div class="line">        unsigned posY_;</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    constIterator cbegin( unsigned vectix ) const &#123;</div><div class="line">        if( vectix &gt;= vectixNum_ ) &#123;</div><div class="line">            throw InvalidVectixException();</div><div class="line">        &#125;</div><div class="line">        return constIterator( this, vectix );</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    constIterator cend( unsigned vectix ) const &#123;</div><div class="line">        if( vectix &gt;= vectixNum_ ) &#123;</div><div class="line">            throw InvalidVectixException();</div><div class="line">        &#125;</div><div class="line">        return constIterator( this, vectix, vectixNum_ );</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>　　我们可以使用邻接矩阵或邻接链表来构造图。假定图的边数为<code>E</code>，顶点数为<code>V</code>，要是<code>E</code>远远大于<code>V</code>，那么这个图就是密集图。使用邻接矩阵的好处是，可以在常量时间内判断两个顶点之间是否存在边。但是，我们知道，邻接矩阵所需的内存正比于$O(V^2)$，而邻接链表所需的内存正比于<code>V + E</code>。<br>　　对于密集图来说，由于图的边数<code>E</code>很大，因此，邻接矩阵和邻接链表使用的内存比较接近，这时使用邻接矩阵来构造图将带来更好的执行性能。而对于稀疏图来说，图的边数<code>E</code>相对较小，一方面，使用邻接链表来构造图所需的内存相对较小，另一方面，使用邻接矩阵来构造图所需的时间为$O(V^2)$，这时就应当使用邻接链表来构造图。</p>
<h2 id="邻接链表"><a href="#邻接链表" class="headerlink" title="邻接链表"></a>邻接链表</h2><p>　　除了使用矩阵，我们还可以使用邻接链表来构造图。下图显示了我们使用邻接链表来构造无向图，假定图的总顶点数为<code>E</code>，那么我们就创建一个大小为<code>E</code>的数组，数组中的每项元素都是一个链表，每个顶点拥有对应的链表，若这个顶点与其它的多个顶点连接，那么我们就将其它的顶点插入到这个顶点所对应的链表中。<br><img src="/images/data-structure/gc.png" alt="">　　<img src="/images/data-structure/gd.png" alt=""><br>　　我们使用<code>ListGraph</code>来表示邻接链表构造的图，邻接链表所需的内存正比于<code>V + E</code>：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div></pre></td><td class="code"><pre><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;forward_list&gt;</div><div class="line">#include &lt;exception&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">#include "Edge.hpp"</div><div class="line"></div><div class="line">class ListGraph</div><div class="line">&#123;</div><div class="line">private:</div><div class="line">    class InvalidEdgeException: public std::exception &#123;</div><div class="line">    public:</div><div class="line">        virtual const char * what() const throw() &#123;</div><div class="line">            return "the specify edge is invalid!";</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    class InvalidVectixException: public std::exception &#123;</div><div class="line">    public:</div><div class="line">        virtual const char * what() const throw() &#123;</div><div class="line">            return "the specify vectix is invalid!";</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    unsigned vectixNum_;</div><div class="line">    unsigned edgeNum_;</div><div class="line">    bool isDirected_;</div><div class="line">    std::vector&lt;std::forward_list&lt;unsigned&gt;&gt; list_;</div><div class="line"></div><div class="line">public:</div><div class="line">    explicit ListGraph( unsigned vectixSize, bool directed = false )</div><div class="line">        : vectixNum_( vectixSize ), edgeNum_( 0 ), </div><div class="line">          isDirected_( directed ), list_( vectixSize ) &#123; &#125;</div><div class="line"></div><div class="line">    unsigned vectixSize() const &#123;</div><div class="line">        return vectixNum_;</div><div class="line">    &#125;</div><div class="line">    bool directed() const &#123;</div><div class="line">        return isDirected_;</div><div class="line">    &#125;</div><div class="line">    unsigned edgeSize() const &#123;</div><div class="line">        return edgeNum_;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    bool hasEdge( const Edge &amp;edge ) const &#123;</div><div class="line">        auto src = edge.src();</div><div class="line">        auto des = edge.des();</div><div class="line">        if( src &gt;= vectixNum_ || des &gt;= vectixNum_) &#123;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">        return std::find( list_[src].cbegin(), list_[src].cend(), des ) != list_[src].cend();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    void addEdge( const Edge &amp;edge ) &#123;</div><div class="line">        auto src = edge.src();</div><div class="line">        auto des = edge.des();</div><div class="line">        if( src &gt;= vectixNum_ || des &gt;= vectixNum_) &#123;</div><div class="line">            throw InvalidEdgeException();</div><div class="line">        &#125;</div><div class="line">        if( !hasEdge( edge ) ) &#123;</div><div class="line">            ++edgeNum_;</div><div class="line">            list_[src].push_front( des );</div><div class="line">            if( !isDirected_ ) &#123;</div><div class="line">                list_[des].push_front( src );</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    void removeEdge( const Edge &amp;edge ) &#123;</div><div class="line">        if( !hasEdge( edge ) ) &#123;</div><div class="line">            throw InvalidEdgeException();</div><div class="line">        &#125;</div><div class="line">        auto src = edge.src();</div><div class="line">        auto des = edge.des();</div><div class="line">        list_[src].remove( des );</div><div class="line">        --edgeNum_;</div><div class="line">        if( !isDirected_ ) &#123;</div><div class="line">            list_[des].remove( src );</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    std::forward_list&lt;unsigned&gt;::const_iterator cbegin( unsigned vectix ) const &#123;</div><div class="line">        if( vectix &gt;= vectixNum_ ) &#123;</div><div class="line">            throw InvalidVectixException();</div><div class="line">        &#125;</div><div class="line">        return list_[vectix].cbegin();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    std::forward_list&lt;unsigned&gt;::const_iterator cend( unsigned vectix ) const &#123;</div><div class="line">        if( vectix &gt;= vectixNum_ ) &#123;</div><div class="line">            throw InvalidVectixException();</div><div class="line">        &#125;</div><div class="line">        return list_[vectix].cend();</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>　　由于<code>ListGraph</code>中不允许出现重复的边，因此，<code>addEdge()</code>操作是线性时间操作，同样，<code>removeEdge()</code>和<code>hasEdge()</code>也是线性时间操作。由于这些操作是线性时间操作，因此，当图变得密集时，这些操作带来的开销将比较大，因此，<code>ListGraph</code>只适合于稀疏的图，对于稀疏图来说，相较于<code>MatrixGraph</code>，使用<code>ListGraph</code>将比较节省内存。<br>　　注意，在<code>forward_list</code>中查找某一元素是线性时间操作，我们可以使用<code>unordered_set</code>来替代<code>forward_list</code>，因为在<code>unordered_set</code>中查找某一元素是常量时间操作：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div></pre></td><td class="code"><pre><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;unordered_set&gt;</div><div class="line">#include &lt;exception&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">#include "Edge.hpp"</div><div class="line"></div><div class="line">class ListGraph</div><div class="line">&#123;</div><div class="line">private:</div><div class="line">    class InvalidEdgeException: public std::exception &#123;</div><div class="line">    public:</div><div class="line">        virtual const char * what() const throw() &#123;</div><div class="line">            return "the specify edge is invalid!";</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    class InvalidVectixException: public std::exception &#123;</div><div class="line">    public:</div><div class="line">        virtual const char * what() const throw() &#123;</div><div class="line">            return "the specify vectix is invalid!";</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    unsigned vectixNum_;</div><div class="line">    unsigned edgeNum_;</div><div class="line">    bool isDirected_;</div><div class="line">    std::vector&lt;std::unordered_set&lt;unsigned&gt;&gt; list_;</div><div class="line"></div><div class="line">public:</div><div class="line">    explicit ListGraph( unsigned vectixSize, bool directed = false )</div><div class="line">        : vectixNum_( vectixSize ), edgeNum_( 0 ), </div><div class="line">          isDirected_( directed ), list_( vectixSize ) &#123; &#125;</div><div class="line"></div><div class="line">    unsigned vectixSize() const &#123;</div><div class="line">        return vectixNum_;</div><div class="line">    &#125;</div><div class="line">    bool directed() const &#123;</div><div class="line">        return isDirected_;</div><div class="line">    &#125;</div><div class="line">    unsigned edgeSize() const &#123;</div><div class="line">        return edgeNum_;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    bool hasEdge( const Edge &amp;edge ) const &#123;</div><div class="line">        auto src = edge.src();</div><div class="line">        auto des = edge.des();</div><div class="line">        if( src &gt;= vectixNum_ || des &gt;= vectixNum_) &#123;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">        return list_[src].find( des ) != list_[src].end();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    void addEdge( const Edge &amp;edge ) &#123;</div><div class="line">        auto src = edge.src();</div><div class="line">        auto des = edge.des();</div><div class="line">        if( src &gt;= vectixNum_ || des &gt;= vectixNum_) &#123;</div><div class="line">            throw InvalidEdgeException();</div><div class="line">        &#125;</div><div class="line">        if( !hasEdge( edge ) ) &#123;</div><div class="line">            ++edgeNum_;</div><div class="line">            list_[src].insert( des );</div><div class="line">            if( !isDirected_ ) &#123;</div><div class="line">                list_[des].insert( src );</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    void removeEdge( const Edge &amp;edge ) &#123;</div><div class="line">        if( !hasEdge( edge ) ) &#123;</div><div class="line">            throw InvalidEdgeException();</div><div class="line">        &#125;</div><div class="line">        auto src = edge.src();</div><div class="line">        auto des = edge.des();</div><div class="line">        list_[src].erase( des );</div><div class="line">        --edgeNum_;</div><div class="line">        if( !isDirected_ ) &#123;</div><div class="line">            list_[des].erase( src );</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    std::unordered_set&lt;unsigned&gt;::const_iterator cbegin( unsigned vectix ) const &#123;</div><div class="line">        if( vectix &gt;= vectixNum_ ) &#123;</div><div class="line">            throw InvalidVectixException();</div><div class="line">        &#125;</div><div class="line">        return list_[vectix].cbegin();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    std::unordered_set&lt;unsigned&gt;::const_iterator cend( unsigned vectix ) const &#123;</div><div class="line">        if( vectix &gt;= vectixNum_ ) &#123;</div><div class="line">            throw InvalidVectixException();</div><div class="line">        &#125;</div><div class="line">        return list_[vectix].cend();</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="图的生成"><a href="#图的生成" class="headerlink" title="图的生成"></a>图的生成</h2><p>　　实际上，为了测试图算法，经常需要随机地生成图，我们可以使用<code>randomEdgeSparse()</code>来生成稀疏图，而使用<code>randomEdgeDense()</code>来生成密集图：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Graph&gt;</div><div class="line"><span class="keyword">class</span> GraphGenerator</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">randomEdgeSparse</span><span class="params">( Graph &amp;g, <span class="keyword">unsigned</span> edgeNum )</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; edgeNum; ++i ) &#123;</div><div class="line">            <span class="keyword">auto</span> src = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span>&gt;( <span class="built_in">std</span>::rand() / ( <span class="number">1.0</span> + RAND_MAX ) * g.vectixSize() );</div><div class="line">            <span class="keyword">auto</span> des = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span>&gt;( <span class="built_in">std</span>::rand() / ( <span class="number">1.0</span> + RAND_MAX ) * g.vectixSize() );</div><div class="line">            g.addEdge( Edge( src, des ) );</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">randomEdgeDense</span><span class="params">( Graph &amp;g, <span class="keyword">unsigned</span> edgeNum )</span> </span>&#123;</div><div class="line">        <span class="keyword">double</span> probability = <span class="number">2.0</span> * edgeNum / ( ( g.vectixSize() - <span class="number">1</span> ) * g.vectixSize() );</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">unsigned</span> src = <span class="number">0</span>; src &lt; g.vectixSize(); ++src ) &#123;</div><div class="line">            <span class="keyword">for</span>( <span class="keyword">unsigned</span> des = <span class="number">0</span>; des &lt; src; ++des ) &#123;</div><div class="line">                <span class="keyword">if</span>( <span class="built_in">std</span>::rand() &lt; probability * RAND_MAX ) &#123;</div><div class="line">                    g.addEdge( Edge( src, des ) );</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>　　注意到在<code>randomEdgeSparse()</code>中，当<code>edgeNum</code>足够大时，随机生产的边中会经常出现重复的边。我们知道，<code>Graph</code>中不允许出现重复的边，因此，<code>randomEdgeSparse()</code>只适合用来生产稀疏图。相反，<code>randomEdgeDense()</code>中并不会生成重复的边，因此，可以用来生成密集的图。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.amazon.com/Algorithms-Parts-1-4-Fundamentals-Structure/dp/0201350882" target="_blank" rel="external">Algorithms in C++ 3rd Edition by Robert Sedgewick</a><br><a href="http://www.amazon.com/Data-Structures-Algorithm-Analysis-C/dp/013284737X/ref=sr_1_4?s=books&amp;ie=UTF8&amp;qid=1422255950&amp;sr=1-4&amp;keywords=data+structure+and+algorithm+in+c%2B%2B" target="_blank" rel="external">Data Structures and Algorithm Analysis in C++ 4th Edition by Mark A. Weiss</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/02/18/自制STL之排列与组合算法/" itemprop="url">
                  自制STL -- 排列与组合算法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-02-18T14:01:32+08:00" content="2015-02-18">
              2015-02-18
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/自制STL/" itemprop="url" rel="index">
                    <span itemprop="name">自制STL</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="反序排列"><a href="#反序排列" class="headerlink" title="反序排列"></a>反序排列</h2><p>　　可以使用<code>reverse()</code>将输入范围中的元素反序排列，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; lst = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</div><div class="line">mystl::reverse( lst.begin(), lst.end() );</div><div class="line">mystl::copy( lst.cbegin(), lst.cend(), ostream_iterator&lt;<span class="keyword">int</span>&gt;( <span class="built_in">cout</span>, <span class="string">" "</span> ) );</div><div class="line"><span class="comment">// 9 8 7 6 5 3 2 1</span></div></pre></td></tr></table></figure></p>
<p>　　也可以使用<code>reverse_copy()</code>将输入范围中的元素以反序的方式拷贝到输出范围：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; lst = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</div><div class="line">mystl::reverse_copy( lst.cbegin(), lst.cend(), ostream_iterator&lt;<span class="keyword">int</span>&gt;( <span class="built_in">cout</span>, <span class="string">" "</span> ) );</div><div class="line"><span class="comment">// 9 8 7 6 5 3 2 1</span></div></pre></td></tr></table></figure></p>
<p>　　反序算法的实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">namespace</span> mystl &#123;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> BidirectionalIterator&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">( BidirectionalIterator beg, BidirectionalIterator end )</span> </span>&#123;</div><div class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::swap; </div><div class="line">    <span class="keyword">for</span>( <span class="keyword">auto</span> size = <span class="built_in">std</span>::distance( beg, end ); size &gt; <span class="number">1</span>; size -= <span class="number">2</span> ) &#123;</div><div class="line">        swap( *beg++, *--end );            </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> BidirectionalIterator, <span class="keyword">typename</span> OutputIterator&gt;</div><div class="line"><span class="function">OutputIterator <span class="title">reverse_copy</span><span class="params">( BidirectionalIterator beg, BidirectionalIterator end, </span></span></div><div class="line">                             OutputIterator desBeg ) &#123;</div><div class="line">    <span class="keyword">while</span>( end != beg ) &#123;</div><div class="line">        *desBeg++ = *--end;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> desBeg;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;;    <span class="comment">// namespace mystl</span></div></pre></td></tr></table></figure></p>
<h2 id="下一排列"><a href="#下一排列" class="headerlink" title="下一排列"></a>下一排列</h2><p>　　对于排列<code>[1, 2, 3, 4]</code>，我们规定它的下一排列为<code>[1, 2, 4, 3]</code>，同样的道理，<code>[1, 2, 4, 3]</code>的下一排列为<code>[1, 3, 2, 4]</code>。例如，我们从<code>[1, 2, 3, 4]</code>开始推出它的所有下一排列：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</div><div class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line"><span class="keyword">do</span> &#123;</div><div class="line">    mystl::copy( vec.cbegin(), vec.cend(), ostream_iterator&lt;<span class="keyword">int</span>&gt;( <span class="built_in">cout</span>, <span class="string">" "</span> ) );</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; ( ++i % <span class="number">5</span> == <span class="number">0</span> ? <span class="string">"\n"</span> : <span class="string">"\t"</span> );</div><div class="line">&#125; <span class="keyword">while</span>( mystl::next_permutation( vec.begin(), vec.end() ) );</div><div class="line"><span class="comment">/***</span></div><div class="line">1 2 3 4 	1 2 4 3 	1 3 2 4 	1 3 4 2 	1 4 2 3 </div><div class="line">1 4 3 2 	2 1 3 4 	2 1 4 3 	2 3 1 4 	2 3 4 1 </div><div class="line">2 4 1 3 	2 4 3 1 	3 1 2 4 	3 1 4 2 	3 2 1 4 </div><div class="line">3 2 4 1 	3 4 1 2 	3 4 2 1 	4 1 2 3 	4 1 3 2 </div><div class="line">4 2 1 3 	4 2 3 1 	4 3 1 2 	4 3 2 1 </div><div class="line">***/</div></pre></td></tr></table></figure></p>
<p>　　例如，计算<code>[1, 2, 4, 3]</code>的下一排列，那么，我们首先从输入范围的末尾开始，寻找一对相邻的元素<code>*current</code>和<code>*next</code>，使得<code>*current</code>小于<code>*next</code>：<br><img src="/images/data-structure/pe1.png" alt=""><br>　　接着，从输入范围的末尾开始，寻找元素<code>*iter</code>，使得<code>*iter</code>大于<code>*current</code>，那么，这时我们交换这两个元素：<br><img src="/images/data-structure/pe2.png" alt=""><br>　　最后，倒序排列从<code>*next</code>到末尾的所有元素：<br><img src="/images/data-structure/pe3.png" alt=""><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">namespace</span> mystl &#123;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> BidirectionalIterator, <span class="keyword">typename</span> Comp&gt;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">next_permutation</span><span class="params">( BidirectionalIterator beg, BidirectionalIterator end, Comp comp )</span> </span>&#123;</div><div class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::swap;</div><div class="line">    <span class="keyword">if</span>( beg == end ) &#123;                       <span class="comment">// 输入范围为空，则返回 false </span></div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">auto</span> current = beg;</div><div class="line">    <span class="keyword">if</span>( ++current == end ) &#123;                 <span class="comment">// 输入范围只包含一个元素，则返回 false</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    current = end;</div><div class="line">    --current;                               <span class="comment">// current 指向最后一个元素</span></div><div class="line">    <span class="keyword">while</span>( current != beg ) &#123;</div><div class="line">        <span class="keyword">auto</span> next = current;</div><div class="line">        --current;</div><div class="line">        <span class="keyword">if</span>( comp( *current, *next ) ) &#123;</div><div class="line">            <span class="keyword">auto</span> iter = end;</div><div class="line">            <span class="keyword">while</span>( !comp( *current, *--iter ) )</div><div class="line">                ;</div><div class="line">            swap( *current, *iter );</div><div class="line">            mystl::reverse( next, end );</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> BidirectionalIterator&gt;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">next_permutation</span><span class="params">( BidirectionalIterator beg, BidirectionalIterator end )</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> mystl::next_permutation( beg, end, <span class="built_in">std</span>::less&lt;<span class="keyword">decltype</span>(*beg)&gt;&#123;&#125; );</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;;    <span class="comment">// namespace mystl</span></div></pre></td></tr></table></figure></p>
<h2 id="上一排列"><a href="#上一排列" class="headerlink" title="上一排列"></a>上一排列</h2><p>　　对于排列<code>[4, 3, 2, 1]</code>，我们规定它的上一排列为<code>[4, 3, 1, 2]</code>，同样的道理，<code>[4, 3, 1, 2]</code>的下一排列为<code>[4, 2, 3, 1]</code>。例如，我们从<code>[4, 3, 2, 1]</code>开始推出它的所有上一排列：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec = &#123; <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span> &#125;;</div><div class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line"><span class="keyword">do</span> &#123;</div><div class="line">    mystl::copy( vec.cbegin(), vec.cend(), ostream_iterator&lt;<span class="keyword">int</span>&gt;( <span class="built_in">cout</span>, <span class="string">" "</span> ) );</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; ( ++i % <span class="number">5</span> == <span class="number">0</span> ? <span class="string">"\n"</span> : <span class="string">"\t"</span> );</div><div class="line">&#125; <span class="keyword">while</span>( mystl::prev_permutation( vec.begin(), vec.end() ) );</div><div class="line"><span class="comment">/***</span></div><div class="line">4 3 2 1 	4 3 1 2 	4 2 3 1 	4 2 1 3 	4 1 3 2 </div><div class="line">4 1 2 3 	3 4 2 1 	3 4 1 2 	3 2 4 1 	3 2 1 4 </div><div class="line">3 1 4 2 	3 1 2 4 	2 4 3 1 	2 4 1 3 	2 3 4 1 </div><div class="line">2 3 1 4 	2 1 4 3 	2 1 3 4 	1 4 3 2 	1 4 2 3 </div><div class="line">1 3 4 2 	1 3 2 4 	1 2 4 3 	1 2 3 4</div><div class="line">***/</div></pre></td></tr></table></figure></p>
<p>　　例如，计算<code>[4, 3, 1, 2]</code>的下一排列，那么，我们首先从输入范围的末尾开始，寻找一对相邻的元素<code>*current</code>和<code>*next</code>，使得<code>*current</code>大于<code>*next</code>：<br><img src="/images/data-structure/pa1.png" alt=""><br>　　接着，从输入范围的末尾开始，寻找元素<code>*iter</code>，使得<code>*iter</code>小于<code>*current</code>，那么，这时我们交换这两个元素：<br><img src="/images/data-structure/pa2.png" alt=""><br>　　最后，倒序排列从<code>*next</code>到末尾的所有元素：<br><img src="/images/data-structure/pa3.png" alt=""><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">namespace</span> mystl &#123;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> BidirectionalIterator, <span class="keyword">typename</span> Comp&gt;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">prev_permutation</span><span class="params">( BidirectionalIterator beg, BidirectionalIterator end, Comp comp )</span> </span>&#123;</div><div class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::swap;</div><div class="line">    <span class="keyword">if</span>( beg == end ) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">auto</span> current = beg;</div><div class="line">    <span class="keyword">if</span>( ++current == end ) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    current = end;</div><div class="line">    --current;                       <span class="comment">// current 指向最后一个元素</span></div><div class="line">    <span class="keyword">while</span>( current != beg ) &#123;</div><div class="line">        <span class="keyword">auto</span> next = current;</div><div class="line">        --current;</div><div class="line">        <span class="keyword">if</span>( comp( *next, *current ) ) &#123;</div><div class="line">            <span class="keyword">auto</span> iter = end;</div><div class="line">            <span class="keyword">while</span>( !comp( *--iter, *current ) )</div><div class="line">                ;</div><div class="line">            swap( *current, *iter );</div><div class="line">            mystl::reverse( next, end );</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> BidirectionalIterator&gt;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">prev_permutation</span><span class="params">( BidirectionalIterator beg, BidirectionalIterator end )</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> mystl::prev_permutation( beg, end, <span class="built_in">std</span>::less&lt;<span class="keyword">decltype</span>(*beg)&gt;&#123;&#125; );</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;;    <span class="comment">// namespace mystl</span></div></pre></td></tr></table></figure></p>
<h2 id="随机打乱"><a href="#随机打乱" class="headerlink" title="随机打乱"></a>随机打乱</h2><p>　　我们可以使用<code>random_shuffle()</code>将输入范围中的元素随机打乱，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</div><div class="line">mystl::random_shuffle( vec.begin(), vec.end() );</div><div class="line">mystl::copy( vec.cbegin(), vec.cend(), ostream_iterator&lt;<span class="keyword">int</span>&gt;( <span class="built_in">cout</span>, <span class="string">" "</span> ) );</div><div class="line"><span class="comment">// 5 4 8 9 1 6 3 2 7</span></div></pre></td></tr></table></figure></p>
<p>　　算法的实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">namespace</span> mystl &#123;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIterator&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">random_shuffle</span><span class="params">( RandomIterator beg, RandomIterator end )</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>( beg == end ) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">auto</span> iter = beg + <span class="number">1</span>; iter != end; ++iter ) &#123;</div><div class="line">        <span class="built_in">std</span>::iter_swap( iter, beg + ( <span class="built_in">std</span>::rand() % ( ( iter - beg )  + <span class="number">1</span> ) ) );</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIterator, <span class="keyword">typename</span> RandomNumberGenerator&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">random_shuffle</span><span class="params">( RandomIterator beg, RandomIterator end, </span></span></div><div class="line">                     RandomNumberGenerator &amp;&amp;rand ) &#123;</div><div class="line">    <span class="keyword">if</span>( beg == end ) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">auto</span> iter = beg + <span class="number">1</span>; iter != end; ++iter ) &#123;</div><div class="line">        <span class="built_in">std</span>::iter_swap( iter, beg + rand( ( iter - beg )  + <span class="number">1</span> ) );</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;;    <span class="comment">// namespace mystl</span></div></pre></td></tr></table></figure></p>
<p>　　此外，我们也可以使用<code>shuffle()</code>来打乱元素，使用<code>shuffle()</code>时，我们需要为其提供随机数引擎，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::default_random_engine engine;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</div><div class="line">mystl::shuffle( vec.begin(), vec.end(), engine );</div><div class="line">mystl::copy( vec.cbegin(), vec.cend(), ostream_iterator&lt;<span class="keyword">int</span>&gt;( <span class="built_in">cout</span>, <span class="string">" "</span> ) );</div><div class="line"><span class="comment">// 8 7 5 6 2 4 9 3 1</span></div></pre></td></tr></table></figure></p>
<p>　　算法的实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">namespace</span> mystl &#123;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIterator, <span class="keyword">typename</span> UniformRandomNumberGenerator&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">shuffle</span><span class="params">( RandomIterator beg, RandomIterator end, </span></span></div><div class="line">              UniformRandomNumberGenerator &amp;&amp;generator ) &#123;</div><div class="line">    <span class="keyword">if</span>( beg == end ) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">std</span>::uniform_int_distribution&lt;<span class="keyword">unsigned</span>&gt; distribution;</div><div class="line">    <span class="keyword">using</span> range_type = <span class="keyword">decltype</span>( distribution )::param_type;</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">auto</span> iter = beg + <span class="number">1</span>; iter != end; ++iter ) &#123;</div><div class="line">        <span class="built_in">std</span>::iter_swap( iter, beg + distribution( generator, range_type( <span class="number">0</span>, iter - beg ) ) );</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;;    <span class="comment">// namespace mystl</span></div></pre></td></tr></table></figure></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://book.douban.com/subject/10440485/" target="_blank" rel="external">The C++ Standard Library Second Edition</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/02/13/自制STL之集合算法/" itemprop="url">
                  自制 STL -- 集合算法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-02-13T21:53:04+08:00" content="2015-02-13">
              2015-02-13
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/自制STL/" itemprop="url" rel="index">
                    <span itemprop="name">自制STL</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>　　集合算法需要对输入的两个集合进行操作，但对集合有所要求：</p>
<ul>
<li>两个输入集合中的元素都必须是有序的。</li>
<li>输入的两个集合中元素是可以重复的。</li>
</ul>
<h2 id="集合包含"><a href="#集合包含" class="headerlink" title="集合包含"></a>集合包含</h2><p>　　我们可以使用<code>includes()</code>算法来判断一个有序集合是否包含另一有序集合，例如：</p>
<pre><code>bool ans = mystl::includes( beg, end, searchBeg, searchEnd );
</code></pre><p>　　只有当需要搜索的所有元素都存在于<code>[beg, end)</code>中时，<code>includes()</code>才会返回<code>true</code>。<br>　　另外，要是<code>[searchBeg, searchEnd)</code>为空集，<code>search()</code>也会返会<code>true</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; coll = &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</div><div class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; search1 = &#123; <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span> &#125;;</div><div class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; search2 = &#123; <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;;</div><div class="line"><span class="keyword">if</span>( mystl::includes( coll.cbegin(), coll.cend(), search1.cbegin(), search1.cend() ) ) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"all elements of search1 are also in coll"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"not all elements of search1 are also in coll"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span>( mystl::includes( coll.cbegin(), coll.cend(), search2.cbegin(), search2.cend() ) ) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"all elements of search2 are also in coll"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"not all elements of search2 are also in coll"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">/***</span></div><div class="line">all elements of search1 are also in coll</div><div class="line">not all elements of search2 are also in coll</div><div class="line">***/</div></pre></td></tr></table></figure></p>
<p>　　可以看到，当<code>[searchBeg, searchEnd)</code>中存在重复的元素时，在<code>[beg, end)</code>中至少也需要存在相同数目的重复元素，<code>includes()</code>才会返回<code>true</code>。例如，在<code>search1</code>中存在两个重复的元素<code>2</code>，那么在<code>coll</code>中至少需要有两个重复的<code>2</code>，这时<code>includes()</code>才会返回<code>true</code>。<br>　　算法的具体实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">namespace</span> mystl &#123;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator1, <span class="keyword">typename</span> InputIterator2&gt;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">includes</span><span class="params">( InputIterator1 beg, InputIterator1 end, </span></span></div><div class="line">               InputIterator2 searchBeg, InputIterator2 searchEnd ) &#123;</div><div class="line">    <span class="keyword">if</span>( searchBeg == searchEnd ) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span>( ( beg = mystl::find( beg, end, *searchBeg ) ) != end ) &#123;</div><div class="line">        <span class="keyword">if</span>( ++searchBeg == searchEnd ) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        ++beg;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator1, <span class="keyword">typename</span> InputIterator2, <span class="keyword">typename</span> BinaryPredicate&gt;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">includes</span><span class="params">( InputIterator1 beg, InputIterator1 end, </span></span></div><div class="line">               InputIterator2 searchBeg, InputIterator2 searchEnd,</div><div class="line">               BinaryPredicate predicate ) &#123;</div><div class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::placeholders::<span class="number">_1</span>;</div><div class="line">    <span class="keyword">if</span>( searchBeg == searchEnd ) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span>( ( beg = mystl::find_if( beg, end, <span class="built_in">std</span>::bind( predicate, <span class="number">_1</span>, *searchBeg ) ) ) != end ) &#123;</div><div class="line">        <span class="keyword">if</span>( ++searchBeg == searchEnd ) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        ++beg;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;;    <span class="comment">// namespace mystl</span></div></pre></td></tr></table></figure></p>
<h2 id="集合求和"><a href="#集合求和" class="headerlink" title="集合求和"></a>集合求和</h2><p>　　我们可以使用<code>set_union()</code>来求两个集合的并集，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec1 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">20</span> &#125;;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec2 = &#123; <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">6</span> &#125;;</div><div class="line">mystl::set_union( vec1.cbegin(), vec1.cend(), vec2.cbegin(), vec2.cend(),</div><div class="line">                  ostream_iterator&lt;<span class="keyword">int</span>&gt;( <span class="built_in">cout</span>, <span class="string">" "</span> ) );</div><div class="line"><span class="comment">// 1 2 2 3 4 6 6 10 20</span></div></pre></td></tr></table></figure></p>
<p>　　每次我们比较两个集合中对应的两个的元素：</p>
<ul>
<li>要是这两个元素相同，就将其中一个元素放到输出集合，并且跳过另外一个元素。</li>
<li>要是这两个元素不同，就将较小的那个元素放到输出集合。</li>
</ul>
<p><img src="/images/data-structure/setunion.png" alt=""><br>　　算法具体的实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">namespace</span> mystl &#123;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator1, <span class="keyword">typename</span> InputIterator2,</div><div class="line">          <span class="keyword">typename</span> OutputIterator, <span class="keyword">typename</span> Comp&gt;</div><div class="line"><span class="function">OutputIterator <span class="title">set_union</span><span class="params">( InputIterator1 srcBeg1, InputIterator1 srcEnd1,</span></span></div><div class="line">                          InputIterator2 srcBeg2, InputIterator2 srcEnd2,</div><div class="line">                          OutputIterator desBeg, Comp comp ) &#123;</div><div class="line">    <span class="keyword">while</span>( srcBeg1 != srcEnd1 &amp;&amp; srcBeg2 != srcEnd2 ) &#123;</div><div class="line">        <span class="keyword">if</span>( comp( *srcBeg1, *srcBeg2 ) ) &#123;</div><div class="line">            *desBeg++ = *srcBeg1++;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>( comp( *srcBeg2, *srcBeg1 ) ) &#123;</div><div class="line">            *desBeg++ = *srcBeg2++;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            *desBeg++ = *srcBeg1++;</div><div class="line">            ++srcBeg2;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>( srcBeg1 != srcEnd1 ) &#123;</div><div class="line">        <span class="keyword">return</span> mystl::copy( srcBeg1, srcEnd1, desBeg );</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> mystl::copy( srcBeg2, srcEnd2, desBeg );</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator1, <span class="keyword">typename</span> InputIterator2,</div><div class="line">          <span class="keyword">typename</span> OutputIterator&gt;</div><div class="line"><span class="function">OutputIterator <span class="title">set_union</span><span class="params">( InputIterator1 srcBeg1, InputIterator1 srcEnd1,</span></span></div><div class="line">                          InputIterator2 srcBeg2, InputIterator2 srcEnd2,</div><div class="line">                          OutputIterator desBeg ) &#123;</div><div class="line">    <span class="keyword">while</span>( srcBeg1 != srcEnd1 &amp;&amp; srcBeg2 != srcEnd2 ) &#123;</div><div class="line">        <span class="keyword">if</span>( *srcBeg1 &lt; *srcBeg2 ) &#123;</div><div class="line">            *desBeg++ = *srcBeg1++;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>( *srcBeg2 &lt; *srcBeg1 ) &#123;</div><div class="line">            *desBeg++ = *srcBeg2++; </div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            *desBeg++ = *srcBeg1++;</div><div class="line">            ++srcBeg2;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>( srcBeg1 != srcEnd1 ) &#123;</div><div class="line">        <span class="keyword">return</span> mystl::copy( srcBeg1, srcEnd1, desBeg );</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> mystl::copy( srcBeg2, srcEnd2, desBeg );</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;;    <span class="comment">// namespace mystl</span></div></pre></td></tr></table></figure></p>
<h2 id="集合求差"><a href="#集合求差" class="headerlink" title="集合求差"></a>集合求差</h2><p>　　可以使用<code>set_difference()</code>来求两个集合的差集，这个差集中的元素存在于第一个集合中，但不存在于第二个集合：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec1 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">20</span> &#125;;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec2 = &#123; <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">6</span> &#125;;</div><div class="line"><span class="built_in">std</span>::set_difference( vec1.cbegin(), vec1.cend(), vec2.cbegin(), vec2.cend(),</div><div class="line">                     ostream_iterator&lt;<span class="keyword">int</span>&gt;( <span class="built_in">cout</span>, <span class="string">" "</span> ) );</div><div class="line"><span class="comment">// 1 4 10 20</span></div></pre></td></tr></table></figure></p>
<p>　　每次我们比较两个集合中对应的两个的元素：</p>
<ul>
<li>要是这两个元素相同，那么就同时跳过这两个元素。</li>
<li>要是第一个元素小于第二个元素，那么就将第一个元素放到输出集合中。</li>
<li>要是第一个元素大于第二个元素，那么就跳过第二个元素。</li>
</ul>
<p><img src="/images/data-structure/setdif.png" alt=""><br>　　算法的实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">namespace</span> mystl &#123;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator1, <span class="keyword">typename</span> InputIterator2, </div><div class="line">          <span class="keyword">typename</span> OutputIterator, <span class="keyword">typename</span> Comp&gt;</div><div class="line"><span class="function">OutputIterator <span class="title">set_difference</span><span class="params">( InputIterator1 srcBeg1, InputIterator1 srcEnd1, </span></span></div><div class="line">                               InputIterator2 srcBeg2, InputIterator2 srcEnd2, </div><div class="line">                               OutputIterator desBeg, Comp comp ) &#123;</div><div class="line">    <span class="keyword">while</span>( srcBeg1 != srcEnd1 &amp;&amp; srcBeg2 != srcEnd2 ) &#123;</div><div class="line">        <span class="keyword">if</span>( comp( *srcBeg1, *srcBeg2 ) ) &#123;</div><div class="line">            *desBeg++ = *srcBeg1++;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>( comp( *srcBeg2, *srcBeg1 ) ) &#123;</div><div class="line">            ++srcBeg2;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            ++srcBeg1;</div><div class="line">            ++srcBeg2;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> mystl::copy( srcBeg1, srcEnd1, desBeg );</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator1, <span class="keyword">typename</span> InputIterator2, </div><div class="line">          <span class="keyword">typename</span> OutputIterator&gt;</div><div class="line"><span class="function">OutputIterator <span class="title">set_difference</span><span class="params">( InputIterator1 srcBeg1, InputIterator1 srcEnd1, </span></span></div><div class="line">                               InputIterator2 srcBeg2, InputIterator2 srcEnd2, </div><div class="line">                               OutputIterator desBeg ) &#123;</div><div class="line">    <span class="keyword">while</span>( srcBeg1 != srcEnd1 &amp;&amp; srcBeg2 != srcEnd2 ) &#123;</div><div class="line">        <span class="keyword">if</span>( *srcBeg1 &lt; *srcBeg2 ) &#123;</div><div class="line">            *desBeg++ = *srcBeg1++;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>( *srcBeg2 &lt; *srcBeg1 ) &#123;</div><div class="line">            ++srcBeg2;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            ++srcBeg1;</div><div class="line">            ++srcBeg2;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> mystl::copy( srcBeg1, srcEnd1, desBeg );</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;;    <span class="comment">// namespace mystl</span></div></pre></td></tr></table></figure></p>
<h2 id="交集求解"><a href="#交集求解" class="headerlink" title="交集求解"></a>交集求解</h2><p>　　可以使用<code>set_intersection()</code>来求两个集合的交集，交集中的元素为两个集合所共有：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec1 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">20</span> &#125;;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec2 = &#123; <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">6</span> &#125;;</div><div class="line">mystl::set_intersection( vec1.cbegin(), vec1.cend(), vec2.cbegin(), vec2.cend(),</div><div class="line">                         ostream_iterator&lt;<span class="keyword">int</span>&gt;( <span class="built_in">cout</span>, <span class="string">" "</span> ) );</div><div class="line"><span class="comment">// 2 3 6</span></div></pre></td></tr></table></figure></p>
<p>　　每次我们比较两个集合中对应的两个的元素：</p>
<ul>
<li>要是第一个元素小于第二个元素，那么就跳过第一个元素。</li>
<li>要是第二个元素小于第一个元素，那么就跳过第二个元素。</li>
<li>要是两个元素相等，那么就将其中一个元素放到输出集合，并且跳过另一元素。</li>
</ul>
<p><img src="/images/data-structure/setin.png" alt=""><br>　　算法的实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">namespace</span> mystl &#123;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator1, <span class="keyword">typename</span> InputIterator2, </div><div class="line">          <span class="keyword">typename</span> OutputIterator, <span class="keyword">typename</span> Comp&gt;</div><div class="line"><span class="function">OutputIterator <span class="title">set_intersection</span><span class="params">( InputIterator1 srcBeg1, InputIterator1 srcEnd1, </span></span></div><div class="line">                                 InputIterator2 srcBeg2, InputIterator2 srcEnd2,</div><div class="line">                                 OutputIterator desBeg, Comp comp ) &#123;</div><div class="line">    <span class="keyword">while</span>( srcBeg1 != srcEnd1 &amp;&amp; srcBeg2 != srcEnd2 ) &#123;</div><div class="line">        <span class="keyword">if</span>( comp( *srcBeg1, *srcBeg2 ) ) &#123;</div><div class="line">            ++srcBeg1;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>( comp( *srcBeg2, *srcBeg1 ) ) &#123;</div><div class="line">            ++srcBeg2;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            *desBeg++ = *srcBeg1++;</div><div class="line">            ++srcBeg2;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> desBeg;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator1, <span class="keyword">typename</span> InputIterator2, <span class="keyword">typename</span> OutputIterator&gt;</div><div class="line"><span class="function">OutputIterator <span class="title">set_intersection</span><span class="params">( InputIterator1 srcBeg1, InputIterator1 srcEnd1, </span></span></div><div class="line">                                 InputIterator2 srcBeg2, InputIterator2 srcEnd2,</div><div class="line">                                 OutputIterator desBeg ) &#123;</div><div class="line">    <span class="keyword">while</span>( srcBeg1 != srcEnd1 &amp;&amp; srcBeg2 != srcEnd2 ) &#123;</div><div class="line">        <span class="keyword">if</span>( *srcBeg1 &lt; *srcBeg2 ) &#123;</div><div class="line">            ++srcBeg1;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>( *srcBeg2 &lt; *srcBeg1 ) &#123;</div><div class="line">            ++srcBeg2;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            *desBeg++ = *srcBeg1++;</div><div class="line">            ++srcBeg2;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> desBeg;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;;    <span class="comment">// namespace mystl</span></div><div class="line">```　　</div><div class="line">## 对称差集</div><div class="line">　　我们知道，两个集合的交集中的元素为这两个集合所共有。与此相反，要是两个集合其各自的元素没有重复出现时，这时，这两个集合的对称差集中的元素，只存在于这两个集合中的一个，我们可以使用`set_symmetric_difference()`来求两个集合的对称差集：</div><div class="line">```c++</div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec1 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">20</span> &#125;;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec2 = &#123; <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">6</span> &#125;;</div><div class="line">mystl::set_symmetric_difference( vec1.cbegin(), vec1.cend(), vec2.cbegin(), vec2.cend(),</div><div class="line">                                 ostream_iterator&lt;<span class="keyword">int</span>&gt;( <span class="built_in">cout</span>, <span class="string">" "</span> ) );</div><div class="line"><span class="comment">// 1 2 4 6 10 20</span></div></pre></td></tr></table></figure></p>
<p>　　另外，在输入范围中可以出现重复的元素，例如，在集合<code>vec1</code>中<code>2</code>出现的次数为<code>1</code>，而在集合<code>vec2</code>中<code>2</code>出现的次数为<code>2</code>，那么在输出集合中，<code>2</code>的出现次数为<code>2 - 1 = 1</code>次。<br>　　每次我们比较两个集合中对应的两个的元素：</p>
<ul>
<li>要是第一个元素小于第二个元素，那么就将第一个元素放到输出集合中。</li>
<li>要是第二个元素小于第一个元素，那么就将第二个元素放到输出集合中。</li>
<li>要是两个元素相等，那么就跳过这两个元素。</li>
</ul>
<p><img src="/images/data-structure/setsym.png" alt=""><br>　　算法的实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">namespace</span> mystl &#123;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator1, <span class="keyword">typename</span> InputIterator2, <span class="keyword">typename</span> OutputIterator&gt;</div><div class="line"><span class="function">OutputIterator <span class="title">set_symmetric_difference</span><span class="params">( InputIterator1 srcBeg1, InputIterator1 srcEnd1,</span></span></div><div class="line">                                         InputIterator2 srcBeg2, InputIterator2 srcEnd2, </div><div class="line">                                         OutputIterator desBeg ) &#123;</div><div class="line">    <span class="keyword">while</span>( srcBeg1 != srcEnd1 &amp;&amp; srcBeg2 != srcEnd2 ) &#123;</div><div class="line">        <span class="keyword">if</span>( *srcBeg1 &lt; *srcBeg2 ) &#123;</div><div class="line">            *desBeg++ = *srcBeg1++;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>( *srcBeg2 &lt; *srcBeg1 ) &#123;</div><div class="line">            *desBeg++ = *srcBeg2++;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            ++srcBeg1;</div><div class="line">            ++srcBeg2;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>( srcBeg1 != srcEnd1 ) &#123;</div><div class="line">        <span class="keyword">return</span> mystl::copy( srcBeg1, srcEnd1, desBeg );</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> mystl::copy( srcBeg2, srcEnd2, desBeg );</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator1, <span class="keyword">typename</span> InputIterator2, </div><div class="line">          <span class="keyword">typename</span> OutputIterator, <span class="keyword">typename</span> Comp&gt;</div><div class="line"><span class="function">OutputIterator <span class="title">set_symmetric_difference</span><span class="params">( InputIterator1 srcBeg1, InputIterator1 srcEnd1,</span></span></div><div class="line">                                         InputIterator2 srcBeg2, InputIterator2 srcEnd2,</div><div class="line">                                         OutputIterator desBeg, Comp comp ) &#123;</div><div class="line">    <span class="keyword">while</span>( srcBeg1 != srcEnd1 &amp;&amp; srcBeg2 != srcEnd2 ) &#123;</div><div class="line">        <span class="keyword">if</span>( comp( *srcBeg1, *srcBeg2 ) ) &#123;</div><div class="line">            *desBeg++ = *srcBeg1++;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>( comp( *srcBeg2, *srcBeg1 ) ) &#123;</div><div class="line">            *desBeg++ = *srcBeg2++;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            ++srcBeg1;</div><div class="line">            ++srcBeg2;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>( srcBeg1 != srcEnd1 ) &#123;</div><div class="line">        <span class="keyword">return</span> mystl::copy( srcBeg1, srcEnd1, desBeg );</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> mystl::copy( srcBeg2, srcEnd2, desBeg );</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;;    <span class="comment">// namespace mystl</span></div></pre></td></tr></table></figure></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://book.douban.com/subject/10440485/" target="_blank" rel="external">The C++ Standard Library Second Edition</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/02/10/自制STL之优先队列/" itemprop="url">
                  自制 STL -- 优先队列
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-02-10T15:37:14+08:00" content="2015-02-10">
              2015-02-10
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/自制STL/" itemprop="url" rel="index">
                    <span itemprop="name">自制STL</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><p>　　在<a href="http://senlinzhan.github.io/2015/02/09/%E8%87%AA%E5%88%B6STL%E4%B9%8B%E5%A0%86%E7%AE%97%E6%B3%95/" target="_blank" rel="external">自制 STL – 堆算法</a>里面，我们实现了与堆相关的算法。实际上，优先队列<code>priority_queue</code>使用<code>vector</code>作为底层容器，这样，我们可以使用堆算法，将<code>vector</code>构建成二叉堆，作为优先队列的底层数据结构。<br>　　在优先队列中，最大的节点位于其的头部，而最小的节点位于其尾部，每次调用成员函数<code>pop()</code>会将最大的节点从头部移出，而成员函数<code>push()</code>则可以往优先队列中增加新的节点，并将节点移动到合适的位置。<br>　　例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"priority_queue.hpp"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">std</span>::uniform_int_distribution&lt;<span class="keyword">unsigned</span>&gt; u&#123; <span class="number">1</span>, <span class="number">1000</span> &#125;; </div><div class="line">    <span class="built_in">std</span>::default_random_engine e; </div><div class="line">    mystl::priority_queue&lt;<span class="keyword">unsigned</span>&gt; pq;</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i ) &#123;</div><div class="line">        pq.push( u( e ) );</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span>( !pq.empty() ) &#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; pq.top() &lt;&lt; <span class="string">" "</span>;</div><div class="line">        pq.pop();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 935 831 756 680 679 672 533 530 520 459 384 384 219 132 67 54 48 35 8 1</span></div></pre></td></tr></table></figure></p>
<p>　　可以看到，在优先队列中，元素按从大到小的顺序出列。<code>priority_queue</code>中的元素是按照特定次序排列的，为了维持这种次序，<code>priority_queue</code>并不提供迭代器，也就是说用户无法使用迭代器来修改优先队列中的元素，因为修改元素将会破坏优先队列的内部结构。</p>
<h2 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h2><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div></pre></td><td class="code"><pre><div class="line">// priority_queue.hpp</div><div class="line">#ifndef _PRIORITY_QUEUE_H_</div><div class="line">#define _PRIORITY_QUEUE_H_</div><div class="line"></div><div class="line">#include "algorithm.hpp"</div><div class="line">#include "vector.hpp"</div><div class="line"></div><div class="line">namespace mystl &#123;</div><div class="line"></div><div class="line">template &lt;typename T, typename Container = mystl::vector&lt;T&gt;, </div><div class="line">          typename Comp = std::less&lt;typename Container::value_type&gt;&gt;</div><div class="line">class priority_queue</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    using container_type = Container;</div><div class="line">    using value_type = typename Container::value_type;</div><div class="line">    using reference = typename Container::reference;</div><div class="line">    using const_reference = typename Container::const_reference;</div><div class="line">    using size_type = typename Container::size_type;</div><div class="line"></div><div class="line">protected:</div><div class="line">    Comp comp_;                                     // 比较器</div><div class="line">    Container container_;                           // 底层容器</div><div class="line"></div><div class="line">public:</div><div class="line">    explicit priority_queue( const Comp &amp;comp = Comp&#123;&#125;, const Container &amp;c = Container&#123;&#125; )</div><div class="line">        : comp_( comp ), container_( c ) &#123;</div><div class="line">        mystl::make_heap( container_.begin(), container_.end(), comp_ );</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    explicit priority_queue( const Comp &amp;comp, Container &amp;&amp;container ) </div><div class="line">        : comp_( comp ), container_( std::move( container ) ) &#123;</div><div class="line">        mystl::make_heap( container_.begin(), container_.end(), comp_ );</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    template &lt;typename InputIterator&gt;</div><div class="line">    priority_queue( InputIterator beg, InputIterator end, </div><div class="line">                    const Comp &amp;comp = Comp(), const Container &amp;container = Container() )</div><div class="line">        : comp_( comp ), container_( container ) &#123;</div><div class="line">        container_.insert( container_.end(), beg, end );</div><div class="line">        mystl::make_heap( container_.begin(), container_.end(), comp_ );</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    template &lt;typename InputIterator&gt;</div><div class="line">    priority_queue( InputIterator beg, InputIterator end, </div><div class="line">                    const Comp &amp;comp, Container &amp;&amp;container )</div><div class="line">        : comp_( comp ), container_( std::move( container ) ) &#123;</div><div class="line">        container_.insert( container_.end(), beg, end );</div><div class="line">        mystl::make_heap( container_.begin(), container_.end(), comp_ );</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    bool empty() const &#123;</div><div class="line">        return container_.empty();</div><div class="line">    &#125;</div><div class="line">    size_type size() const &#123;</div><div class="line">        return container_.size();</div><div class="line">    &#125;</div><div class="line">    const_reference top() const &#123;</div><div class="line">        return container_.front();</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    /*   </div><div class="line">        priority_queue 并不允许用户修改元素，因此，不提供成员函数 reference top();</div><div class="line">    */</div><div class="line"></div><div class="line">    void pop() &#123;</div><div class="line">        mystl::pop_heap( container_.begin(), container_.end(), comp_ );</div><div class="line">        container_.pop_back();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void push( const value_type &amp;elem ) &#123;</div><div class="line">        container_.push_back( elem );</div><div class="line">        mystl::push_heap( container_.begin(), container_.end(), comp_ );</div><div class="line">    &#125;</div><div class="line">    void push( value_type &amp;&amp;elem ) &#123;</div><div class="line">        container_.push_back( std::move( elem ) );</div><div class="line">        mystl::push_heap( container_.begin(), container_.end(), comp_ );</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    template &lt;typename... Args&gt;</div><div class="line">    void emplace( Args&amp;&amp;... args ) &#123;</div><div class="line">        container_.emplace_back( std::forward&lt;Args&gt;( args )... );</div><div class="line">        mystl::push_heap( container_.begin(), container_.end(), comp_ );</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    void swap( priority_queue &amp;other ) </div><div class="line">        noexcept( noexcept( swap( container_, other.container_ ) ) &amp;&amp;</div><div class="line">                  noexcept( swap( comp_, other.comp_ ) ) ) &#123;</div><div class="line">        using std::swap;</div><div class="line">        swap( container_, other.container_ );</div><div class="line">        swap( comp_, other.comp_ );</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">template &lt;typename T, typename Container, typename Comp&gt;</div><div class="line">void swap( priority_queue&lt;T, Container, Comp&gt; &amp;x, priority_queue&lt;T, Container, Comp&gt; &amp;y )</div><div class="line">    noexcept( noexcept( x.swap( y ) ) ) &#123;</div><div class="line">    x.swap( y );</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;;    // namespace mystl</div><div class="line"></div><div class="line">#endif /* _PRIORITY_QUEUE_H_ */</div></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://book.douban.com/subject/10440485/" target="_blank" rel="external">The C++ Standard Library Second Edition</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/02/09/自制STL之堆算法/" itemprop="url">
                  自制 STL -- 堆算法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-02-09T14:59:43+08:00" content="2015-02-09">
              2015-02-09
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/自制STL/" itemprop="url" rel="index">
                    <span itemprop="name">自制STL</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h2><p>　　二叉堆实际上是完全二叉树，通常，可以使用数组来表示二叉堆，例如，对于以下的二叉堆：<br><img src="/images/data-structure/heap1.png" alt=""><br>　　可以表示成为完全二叉树：<br><img src="/images/data-structure/heap2.png" alt=""><br>　　注意，数组的第一个元素下标是<code>0</code>，因此，假定我们知道某个节点的下标是<code>i</code>，那么其左子节点的下标为<code>2i + 1</code>，其右子节点的下标为<code>2i + 2</code>，而其父节点的下标为<code>(i - 1) / 2</code>。例如，节点<code>D</code>的下标为<code>3</code>，那么它的左子节点<code>H</code>的下标为<code>2 * 3 + 1 = 7</code>，其右子节点<code>I</code>的下标为<code>2 * 3 + 2 = 8</code>，而其父节点<code>B</code>的下标为<code>(3 - 1) / 2 = 1</code>。<br>　　二叉堆可分为大根堆<code>(max-heap)</code>和小根堆<code>(min-heap)</code>两种，在大根堆中，每个节点将大于或等于它的两个子节点，因此，根节点为大根堆的最大节点。在小根堆中，每个节点将小于或等于它的两个子节点，因此，根节点为小根堆的最小节点。例如，上图展示的就是小根堆。</p>
<h2 id="压入元素"><a href="#压入元素" class="headerlink" title="压入元素"></a>压入元素</h2><p>　　在大根堆中，若满足每个节点都大于或等于它的两个子节点，那么这个大根堆就是堆有序的。例如，下图是堆有序的大根堆：<br><img src="/images/data-structure/heap7.png" alt=""><br>　　要是我们需要为二叉堆增加元素，那需要怎么做呢？实际上，可以将元素作为最后一个节点插入到大根堆中：<br><img src="/images/data-structure/heap8.png" alt=""><br>　　但是这种做法破坏了堆的有序性，例如，节点<code>88</code>大于其父节点<code>54</code>，为了维持堆的有序性，需要让节点<code>88</code>上升到合适位置：节点<code>88</code>大于它的父节点<code>54</code>，那么就交换这两个节点的位置，接着，节点<code>88</code>大于它的父节点<code>68</code>，同样交换这两个节点，最后，节点<code>88</code>小于它的父节点<code>94</code>，那么这时二叉堆就是有序的了。<br><img src="/images/data-structure/heap4.png" alt=""><br>　　我们使用<code>push_heap()</code>向二叉堆中压入元素，但注意，在执行<code>push_heap()</code>之前，需要保证<code>[beg, end - 1)</code>之间的元素是堆有序的，而<code>*(beg - 1)</code>为需要压入的元素，<code>push_heap()</code>在最坏情况下是对数时间操作。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">namespace</span> mystl &#123;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIterator, <span class="keyword">typename</span> Comp&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_heap</span><span class="params">( RandomIterator beg, RandomIterator end, Comp comp )</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>( end - beg &lt; <span class="number">2</span> ) &#123;                            <span class="comment">// 若元素数目小于 2，则不作处理 </span></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">auto</span> elem = <span class="built_in">std</span>::move( *( end - <span class="number">1</span> ) );           <span class="comment">// elem 为压入的元素</span></div><div class="line">    <span class="keyword">auto</span> elemIndex = end - beg - <span class="number">1</span>;                  <span class="comment">// elemIndex 用来保存 elem 的下标</span></div><div class="line">    <span class="function"><span class="keyword">const</span> <span class="title">decltype</span><span class="params">(elemIndex)</span> rootIndex </span>= <span class="number">0</span>;         <span class="comment">// rootIndex 为根节点的下标</span></div><div class="line">    <span class="keyword">auto</span> parentIndex = ( elemIndex - <span class="number">1</span> ) / <span class="number">2</span>;        <span class="comment">// elem 的父节点下标</span></div><div class="line">    <span class="keyword">while</span>( elemIndex &gt; rootIndex &amp;&amp; comp( *( beg + parentIndex ), elem ) ) &#123;</div><div class="line">        *( beg + elemIndex ) = <span class="built_in">std</span>::move( *( beg + parentIndex ) );</div><div class="line">        elemIndex = parentIndex;</div><div class="line">        parentIndex = ( elemIndex - <span class="number">1</span> ) / <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">    *( beg + elemIndex ) = <span class="built_in">std</span>::move( elem );</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIterator&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_heap</span><span class="params">( RandomIterator beg, RandomIterator end )</span> </span>&#123;</div><div class="line">    mystl::push_heap( beg, end, <span class="built_in">std</span>::less&lt;<span class="keyword">decltype</span>(*beg)&gt;() );</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;;    <span class="comment">// namespace mystl</span></div></pre></td></tr></table></figure></p>
<p>　　例如，向二叉堆中压入元素：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec = &#123; <span class="number">94</span>, <span class="number">68</span>, <span class="number">76</span>, <span class="number">68</span>, <span class="number">54</span>, <span class="number">22</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">46</span>, <span class="number">14</span> &#125;;</div><div class="line">vec.push_back( <span class="number">88</span> );</div><div class="line">mystl::push_heap( vec.begin(), vec.end() );</div><div class="line">copy( vec.cbegin(), vec.cend(), ostream_iterator&lt;<span class="keyword">int</span>&gt;( <span class="built_in">cout</span>, <span class="string">" "</span> ) );</div><div class="line"><span class="comment">// 94 88 76 68 68 22 5 1 46 14 54</span></div></pre></td></tr></table></figure></p>
<h2 id="弹出元素"><a href="#弹出元素" class="headerlink" title="弹出元素"></a>弹出元素</h2><p>　　在大根堆中，我们知道根节点是最大的节点，这样，当需要从大根堆中弹出元素时，很显然，弹出的是根节点的元素。<br>　　我们使用<code>pop_heap()</code>，将根节点与最后一个节点进行交换：<br><img src="/images/data-structure/heap10.png" alt=""><br>　　可以看到，原来的根节点成了最后一个节点，而新的根节点为原来堆的最后一个节点，这时堆并不是堆有序的。在<code>pop_heap()</code>中，我们使用<code>fixDown()</code>来使根节点下沉到合适位置，注意，<code>size</code>表示元素的总个数，但<strong>不包含</strong>被弹出的元素：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">namespace</span> mystl &#123;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIterator, <span class="keyword">typename</span> Comp&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_heap</span><span class="params">( RandomIterator beg, RandomIterator end, Comp comp )</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>( end - beg &lt; <span class="number">2</span> ) &#123;                         <span class="comment">// 元素数目小于2，则不做处理</span></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">std</span>::swap( *beg, *( --end ) );                <span class="comment">// 交换根节点与尾节点</span></div><div class="line">    <span class="keyword">auto</span> size = end - beg;                        <span class="comment">// size 为剩下的元素的个数</span></div><div class="line">    <span class="keyword">decltype</span>(size) index = <span class="number">0</span>;                     <span class="comment">// index 为根节点的下标</span></div><div class="line">    mystl::fixDown( beg, size, index, comp );     <span class="comment">// 将根节点下沉到合适位置</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIterator&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_heap</span><span class="params">( RandomIterator beg, RandomIterator end )</span> </span>&#123;</div><div class="line">    mystl::pop_heap( beg, end, <span class="built_in">std</span>::less&lt;<span class="keyword">decltype</span>(*beg)&gt;() );</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;;    <span class="comment">// namespace mystl</span></div></pre></td></tr></table></figure></p>
<p>　　我们可以使根节点下沉到合适的位置，来恢复二叉堆的堆有序性，需要注意，由于节点<code>84</code>已被弹出，因此，在节点<code>1</code>下沉的过程中不需要考虑节点<code>84</code>。<br>　　节点<code>1</code>拥有两个子节点<code>53</code>和<code>68</code>，在节点下沉的过程中，需要将节点与两个子节点的较大者进行交换，因此，我们将节点<code>1</code>与节点<code>68</code>进行交换，接着，由于节点<code>1</code>只存在一个子节点<code>4</code>，并且节点<code>1</code>小于节点<code>4</code>，因此将节点<code>1</code>与节点<code>4</code>交换：<br><img src="/images/data-structure/heap11.png" alt=""><br>　　那么这时二叉堆就是堆有序的了。需要注意，在节点下沉的过程中，只有当节点存在大于这个节点的子节点，才需要将节点与子节点进行交换，<strong>否则节点将不会继续下沉</strong>。我们使用<code>fixDown()</code>表示下沉操作，<code>startIndex</code>为需要下沉的节点的下标，<code>size</code>元素的总个数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">namespace</span> mystl &#123;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIterator, <span class="keyword">typename</span> Distance, <span class="keyword">typename</span> Comp&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fixDown</span><span class="params">( RandomIterator beg, Distance size, Distance startIndex, Comp comp )</span> </span>&#123;</div><div class="line">    <span class="keyword">auto</span> elem = <span class="built_in">std</span>::move( *( beg + startIndex ) ); <span class="comment">// elem 为需要下沉的元素</span></div><div class="line">    <span class="keyword">auto</span> nodeIndex = startIndex;                    <span class="comment">// nodeIndex 表示 elem 的下标         </span></div><div class="line">    <span class="keyword">auto</span> rightChild = startIndex;                   <span class="comment">// rightChild 表示 elem 的右子节点的下标</span></div><div class="line">    <span class="keyword">while</span>( rightChild * <span class="number">2</span> + <span class="number">2</span> &lt; size ) &#123;</div><div class="line">        rightChild = <span class="number">2</span> * rightChild + <span class="number">2</span>;        </div><div class="line">        <span class="keyword">if</span>( comp( *( beg + rightChild ), *( beg + rightChild - <span class="number">1</span> ) ) ) &#123;</div><div class="line">            --rightChild;                           <span class="comment">// rightChild 指向两个子节点的较大者</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>( !comp( elem, *( beg + rightChild ) ) ) &#123;</div><div class="line">            <span class="keyword">break</span>;                                  <span class="comment">// 若节点大于或等于其子节点，则下沉操作结束</span></div><div class="line">        &#125;</div><div class="line">        *( beg + nodeIndex ) = <span class="built_in">std</span>::move( *( beg + rightChild ) );   <span class="comment">// 子节点上移</span></div><div class="line">        nodeIndex = rightChild;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> ( rightChild * <span class="number">2</span> + <span class="number">2</span> == size ) &#123;             <span class="comment">// 只有左子节点，没有右子节点</span></div><div class="line">        rightChild = <span class="number">2</span> * rightChild + <span class="number">1</span>;            <span class="comment">// 使 rightChild 指向左子节点</span></div><div class="line">        <span class="keyword">if</span>( comp( elem, *( beg + rightChild ) ) ) &#123;</div><div class="line">            *(beg + nodeIndex ) = <span class="built_in">std</span>::move( *( beg + rightChild ) );</div><div class="line">            nodeIndex = rightChild;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    *( beg + nodeIndex ) = <span class="built_in">std</span>::move( elem );       </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIterator, <span class="keyword">typename</span> Distance&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fixDown</span><span class="params">( RandomIterator beg, Distance size, Distance startIndex )</span> </span>&#123;</div><div class="line">    mystl::fixDown( beg, size, startIndex, <span class="built_in">std</span>::less&lt;<span class="keyword">decltype</span>(*beg)&gt;() );</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;;    <span class="comment">// namespace mystl</span></div></pre></td></tr></table></figure></p>
<p>　　例如，从大根堆中弹出根节点：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec = &#123; <span class="number">84</span>, <span class="number">53</span>, <span class="number">68</span>, <span class="number">6</span>, <span class="number">52</span>, <span class="number">4</span>, <span class="number">1</span> &#125;;</div><div class="line">mystl::pop_heap( vec.begin(), vec.end() );</div><div class="line">vec.pop_back();</div><div class="line">copy( vec.cbegin(), vec.cend(), ostream_iterator&lt;<span class="keyword">int</span>&gt;( <span class="built_in">cout</span>, <span class="string">" "</span> ) );</div><div class="line"><span class="comment">// 68 53 4 6 52 1</span></div></pre></td></tr></table></figure></p>
<h2 id="排序二叉堆"><a href="#排序二叉堆" class="headerlink" title="排序二叉堆"></a>排序二叉堆</h2><p>　　有时我们需要对二叉堆进行排序，使得元素在数组中按从小到达的次序排列，注意，在排序之前，需要保证二叉堆是<strong>堆有序</strong>的，在排序过后，二叉堆将不再合法，这时我们得到一个有序数组。<br>　　我们使用<code>sort_heap()</code>来排序二叉堆，首先使用<code>pop_heap()</code>将根节点移动到二叉堆的最后一个，那么最大的元素就到了数组最后一个位置，接着再将新的根节点移动倒数第二个位置，不断重复这个过程：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">namespace</span> mystl &#123;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> RandomIterator, <span class="keyword">typename</span> Comp&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort_heap</span><span class="params">( RandomIterator beg, RandomIterator end, Comp comp )</span> </span>&#123;</div><div class="line">    <span class="keyword">while</span>( end - beg &gt; <span class="number">1</span> ) &#123;</div><div class="line">        mystl::pop_heap(beg, end--, comp );</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> RandomIterator&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort_heap</span><span class="params">( RandomIterator beg, RandomIterator end )</span> </span>&#123;</div><div class="line">    mystl::sort_heap( beg, end, <span class="built_in">std</span>::less&lt;<span class="keyword">decltype</span>(*beg)&gt;() );</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;;    <span class="comment">// namespace mystl</span></div></pre></td></tr></table></figure></p>
<p>　　例如，我们对大根堆进行排序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec = &#123; <span class="number">84</span>, <span class="number">53</span>, <span class="number">68</span>, <span class="number">6</span>, <span class="number">52</span> &#125;;    </div><div class="line">mystl::sort_heap( vec, vec.begin(), vec.end() ); </div><div class="line">copy( vec.cbegin(), vec.cend(), ostream_iterator&lt;<span class="keyword">int</span>&gt;( <span class="built_in">cout</span>, <span class="string">" "</span> ) );</div><div class="line"><span class="comment">// 6 52 53 68 84</span></div></pre></td></tr></table></figure></p>
<h2 id="构造二叉堆"><a href="#构造二叉堆" class="headerlink" title="构造二叉堆"></a>构造二叉堆</h2><p>　　我们可以将任意的数组构造成为二叉堆，例如，对于以下数组：<br><img src="/images/data-structure/heap12.png" alt=""><br>　　可以使用<strong>自底而上</strong>的方式构造二叉堆，我们知道，要是节点包含子节点，那么这个节点和它的所有子节点之间就可以构成一个二叉堆。例如，节点<code>52</code>和它的子节点<code>94</code>就构成了二叉堆。同样，节点<code>46</code>拥有两个子节点<code>68</code>和<code>68</code>，那么这三个节点就构成了一个二叉堆。<br>　　由于数组最后一个下标为<code>9</code>，那么可以计算最后一个拥有子节点的节点其坐标是<code>(9 - 1) / 2 = 4</code>，也就是节点<code>52</code>，那么我们利用节点<code>52</code>跟它的子节点构造成根节点为<code>94</code>的大根堆，接着，将节点<code>46</code>和它的所有子节点构造成为根节点为<code>68</code>的大根堆：<br><img src="/images/data-structure/heap13.png" alt=""><br>　　同样，我们通过节点<code>76</code>跟它的子节点构造成根节点为<code>76</code>的大根堆，接着，将节点<code>14</code>连同它的所有子节点构造成根节点为<code>94</code>的大根堆：<br><img src="/images/data-structure/heap14.png" alt=""><br>　　最后，通过节点<code>1</code>和它的所有子节点构造成大根堆，根节点为<code>94</code>：<br><img src="/images/data-structure/heap15.png" alt=""><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">namespace</span> mystl &#123;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIterator, <span class="keyword">typename</span> Comp&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_heap</span><span class="params">( RandomIterator beg, RandomIterator end, Comp comp )</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>( end - beg &lt; <span class="number">2</span> ) &#123;</div><div class="line">        <span class="keyword">return</span>;        </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> size = end - beg;                            <span class="comment">// 节点的总个数</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> lastIndex = size - <span class="number">1</span>;                        <span class="comment">// 最后一个节点的下标</span></div><div class="line">    <span class="keyword">for</span>( <span class="keyword">auto</span> index = ( lastIndex - <span class="number">1</span> ) / <span class="number">2</span>; index &gt;= <span class="number">0</span>; --index ) &#123;</div><div class="line">        mystl::fixDown( beg, size, index, comp );           <span class="comment">// 将 index 指向的节点下沉</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIterator&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_heap</span><span class="params">( RandomIterator beg, RandomIterator end )</span> </span>&#123;</div><div class="line">    mystl::make_heap( beg, end, <span class="built_in">std</span>::less&lt;<span class="keyword">decltype</span>(*beg)&gt;() );</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;;    <span class="comment">// namespace mystl</span></div></pre></td></tr></table></figure></p>
<p>　　例如，可以将任意数组构造成大根堆：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">uniform_int_distribution&lt;<span class="keyword">unsigned</span>&gt; u&#123; <span class="number">1</span>, <span class="number">100</span> &#125;;</div><div class="line">default_random_engine e;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</div><div class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i ) &#123;</div><div class="line">    vec.push_back( u(e) );</div><div class="line">&#125;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"before mystl::make_heap() : "</span>;</div><div class="line">copy( vec.cbegin(), vec.cend(), ostream_iterator&lt;<span class="keyword">int</span>&gt;( <span class="built_in">cout</span>, <span class="string">" "</span> ) );</div><div class="line">mystl::make_heap( vec.begin(), vec.end() );</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\nafter mystl::make_heap() : "</span>;</div><div class="line">copy( vec.cbegin(), vec.cend(), ostream_iterator&lt;<span class="keyword">int</span>&gt;( <span class="built_in">cout</span>, <span class="string">" "</span> ) );</div><div class="line"><span class="comment">/***</span></div><div class="line">before mystl::make_heap() : 1 14 76 46 54 22 5 68 68 94 </div><div class="line">after mystl::make_heap() : 94 68 76 68 54 22 5 1 46 14 </div><div class="line">***/</div></pre></td></tr></table></figure></p>
<p>　　同样，我们也可以构造小根堆：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">uniform_int_distribution&lt;<span class="keyword">unsigned</span>&gt; u&#123; <span class="number">1</span>, <span class="number">100</span> &#125;;</div><div class="line">default_random_engine e;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</div><div class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i ) &#123;</div><div class="line">    vec.push_back( u(e) );</div><div class="line">&#125;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"before mystl::make_heap() : "</span>;</div><div class="line">copy( vec.cbegin(), vec.cend(), ostream_iterator&lt;<span class="keyword">int</span>&gt;( <span class="built_in">cout</span>, <span class="string">" "</span> ) );</div><div class="line">mystl::make_heap( vec.begin(), vec.end(), greater&lt;<span class="keyword">int</span>&gt;() );</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\nafter mystl::make_heap() : "</span>;</div><div class="line">copy( vec.cbegin(), vec.cend(), ostream_iterator&lt;<span class="keyword">int</span>&gt;( <span class="built_in">cout</span>, <span class="string">" "</span> ) );</div><div class="line"><span class="comment">/***</span></div><div class="line">before mystl::make_heap() : 1 14 76 46 54 22 5 68 68 94 </div><div class="line">after mystl::make_heap() : 1 14 5 46 54 22 76 68 68 94 </div><div class="line">***/</div></pre></td></tr></table></figure></p>
<h2 id="堆排序算法"><a href="#堆排序算法" class="headerlink" title="堆排序算法"></a>堆排序算法</h2><p>　　我们知道，可以使用<code>mystl::make_heap()</code>将任意数组构造成为二叉堆，并且可以使用<code>mystl::sort_heap()</code>对二叉堆排序，那么，利用这两个例程，对任意数组排序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">namespace</span> mystl &#123;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIterator, <span class="keyword">typename</span> Comp&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">( RandomIterator beg, RandomIterator end, Comp comp )</span> </span>&#123;</div><div class="line">    mystl::make_heap( beg, end, comp );                 <span class="comment">// 构造二叉堆</span></div><div class="line">    mystl::sort_heap( beg, end, comp );                 <span class="comment">// 排序二叉堆</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIterator&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">( RandomIterator beg, RandomIterator end )</span> </span>&#123;</div><div class="line">    mystl::heap_sort( beg, end, <span class="built_in">std</span>::less&lt;<span class="keyword">decltype</span>(*beg)&gt;() );</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;;    <span class="comment">// namespace mystl</span></div></pre></td></tr></table></figure></p>
<p>　　例如，对任意数组进行排序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">uniform_int_distribution&lt;<span class="keyword">unsigned</span>&gt; u&#123; <span class="number">1</span>, <span class="number">100</span> &#125;;</div><div class="line">default_random_engine e;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</div><div class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i ) &#123;</div><div class="line">    vec.push_back( u(e) );</div><div class="line">&#125;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"before mystl::heap_sort() : "</span>;</div><div class="line">copy( vec.cbegin(), vec.cend(), ostream_iterator&lt;<span class="keyword">int</span>&gt;( <span class="built_in">cout</span>, <span class="string">" "</span> ) );</div><div class="line">mystl::heap_sort( vec.begin(), vec.end() );</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\nafter mystl::heap_sort() : "</span>;</div><div class="line">copy( vec.cbegin(), vec.cend(), ostream_iterator&lt;<span class="keyword">int</span>&gt;( <span class="built_in">cout</span>, <span class="string">" "</span> ) );</div><div class="line"><span class="comment">/***</span></div><div class="line">before mystl::heap_sort() : 1 14 76 46 54 22 5 68 68 94 </div><div class="line">after mystl::heap_sort() : 1 5 14 22 46 54 68 68 76 94 </div><div class="line">***/</div></pre></td></tr></table></figure></p>
<h2 id="判断堆有序"><a href="#判断堆有序" class="headerlink" title="判断堆有序"></a>判断堆有序</h2><p>　　我们可以使用<code>is_heap()</code>来判断输入范围<code>[beg, end)</code>是否构成二叉堆，此外，用<code>is_heap_until()</code>来返回一个迭代器，其指向的元素为第一个破坏堆有序性的元素，若二叉堆是堆有序的，则<code>is_heap_until()</code>将返回<code>end</code>迭代器。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">namespace</span> mystl &#123;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIterator, <span class="keyword">typename</span> BinaryPredicate&gt;</div><div class="line"><span class="function">RandomIterator <span class="title">is_heap_until</span><span class="params">( RandomIterator beg, RandomIterator end, </span></span></div><div class="line">                              BinaryPredicate predicate ) &#123;</div><div class="line">    <span class="keyword">if</span>( end - beg &lt; <span class="number">2</span> ) &#123;</div><div class="line">        <span class="keyword">return</span> end;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">auto</span> size = end - beg;</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">decltype</span>(size) index = <span class="number">1</span>; index &lt; size; ++index ) &#123;</div><div class="line">        <span class="keyword">auto</span> parentIndex = ( index - <span class="number">1</span> ) / <span class="number">2</span>;</div><div class="line"></div><div class="line">        <span class="comment">// 若父节点小于子节点，则返回指向子节点的迭代器</span></div><div class="line">        <span class="keyword">if</span>( predicate( *( beg + parentIndex ), *( beg + index ) ) ) &#123;</div><div class="line">            <span class="keyword">return</span> beg + index;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> end;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIterator&gt;</div><div class="line"><span class="function">RandomIterator <span class="title">is_heap_until</span><span class="params">( RandomIterator beg, RandomIterator end )</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> mystl::is_heap_until( beg, end, <span class="built_in">std</span>::less&lt;<span class="keyword">decltype</span>(*beg)&gt;&#123;&#125; );</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIterator, <span class="keyword">typename</span> BinaryPredicate&gt;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_heap</span><span class="params">( RandomIterator beg, RandomIterator end, BinaryPredicate predicate )</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> mystl::is_heap_until( beg, end, predicate ) == end;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIterator&gt;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_heap</span><span class="params">( RandomIterator beg, RandomIterator end )</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> mystl::is_heap( beg, end, <span class="built_in">std</span>::less&lt;<span class="keyword">decltype</span>(*beg)&gt;&#123;&#125; );</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;;    <span class="comment">// namespace mystl</span></div></pre></td></tr></table></figure></p>
<p>　　例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; coll1 = &#123; <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span> &#125;;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; coll2 = &#123; <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">6</span> &#125;;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; boolalpha &lt;&lt; <span class="string">"coll1 is heap: "</span> </div><div class="line">     &lt;&lt; mystl::is_heap( coll1.cbegin(), coll1.cend() ) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"coll2 is heap: "</span></div><div class="line">     &lt;&lt; mystl::is_heap( coll2.cbegin(), coll2.cend() ) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"><span class="keyword">auto</span> pos = mystl::is_heap_until( coll2.cbegin(), coll2.cend() );</div><div class="line"><span class="keyword">if</span> ( pos != coll2.end() ) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"first non-heap element: "</span> &lt;&lt; *pos &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">/***</span></div><div class="line">coll1 is heap: true</div><div class="line">coll2 is heap: false</div><div class="line">first non-heap element: 4</div><div class="line">***/</div></pre></td></tr></table></figure></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://book.douban.com/subject/10440485/" target="_blank" rel="external">The C++ Standard Library Second Edition</a></li>
<li><a href="http://www.amazon.com/Algorithms-Parts-1-4-Fundamentals-Structure/dp/0201350882" target="_blank" rel="external">Algorithms in C++ 3rd Edition by Robert Sedgewick</a></li>
<li><a href="http://www.amazon.com/Algorithms-4th-Robert-Sedgewick/dp/032157351X/ref=sr_1_2?ie=UTF8&amp;qid=1419737520&amp;sr=8-2&amp;keywords=algorithm" target="_blank" rel="external">Algorithms 4th Edition by Robert Sedgewick</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/02/09/自制STL之删除算法/" itemprop="url">
                  自制 STL -- 删除算法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-02-09T09:08:56+08:00" content="2015-02-09">
              2015-02-09
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/自制STL/" itemprop="url" rel="index">
                    <span itemprop="name">自制STL</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="删除特定元素"><a href="#删除特定元素" class="headerlink" title="删除特定元素"></a>删除特定元素</h2><p>　　可以使用<code>remove()</code>将指定元素从输入范围中移去，例如，假定存在容器：</p>
<pre><code>vector&lt;int&gt; coll = { 9, 8, 5, 6, 7, 5, 7, 7, 5, 4, 2, 1 };
</code></pre><p><img src="/images/data-structure/remove1.png" alt=""><br>　　那么，我们可以使用以下语句移去元素<code>5</code>：</p>
<pre><code>auto end = mystl::remove( coll.begin(), coll.end(), 5 );
</code></pre><p>　　可以看到，执行<code>remove()</code>移去元素<code>5</code>之后，<code>remove()</code>将返回一个新的<code>off-the-end</code>迭代器，但注意，实际上元素并没有真正被移去，因为这时，<code>coll.end()</code>返回的迭代器指向的位置并没有改变：<br><img src="/images/data-structure/remove2.png" alt=""><br>　　为了使元素真正地从容器中删除，可以执行容器的<code>erase()</code>操作，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; coll = &#123; <span class="number">9</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span> &#125;;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"before remove: "</span>;</div><div class="line">copy( coll.cbegin(), coll.cend(), ostream_iterator&lt;<span class="keyword">int</span>&gt;( <span class="built_in">cout</span>, <span class="string">" "</span> ) );</div><div class="line"><span class="keyword">auto</span> end = mystl::remove( coll.begin(), coll.end(), <span class="number">5</span> );</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\nafter remove 5: "</span>;</div><div class="line">copy( coll.begin(), end, ostream_iterator&lt;<span class="keyword">int</span>&gt;( <span class="built_in">cout</span>, <span class="string">" "</span> ) );</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\nnumber of removed elements: "</span> &lt;&lt; distance( end, coll.end() ) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">coll.erase( end, coll.end() );                         <span class="comment">// 真正删除元素</span></div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"after erase: "</span>;</div><div class="line">copy( coll.begin(), coll.end(), ostream_iterator&lt;<span class="keyword">int</span>&gt;( <span class="built_in">cout</span>, <span class="string">" "</span> ) );</div><div class="line"><span class="comment">/***</span></div><div class="line">before remove: 9 8 5 6 7 5 7 7 5 4 2 1 </div><div class="line">after remove 5: 9 8 6 7 7 7 4 2 1 </div><div class="line">number of removed elements: 3</div><div class="line">after erase: 9 8 6 7 7 7 4 2 1 </div><div class="line">***/</div></pre></td></tr></table></figure></p>
<p>　　实现<code>remove()</code>算法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">namespace</span> mystl &#123;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator, <span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function">ForwardIterator <span class="title">remove</span><span class="params">( ForwardIterator beg, ForwardIterator end, <span class="keyword">const</span> T &amp;elem )</span> </span>&#123;</div><div class="line">    <span class="keyword">auto</span> pos = mystl::find( beg, end, elem );</div><div class="line">    <span class="keyword">if</span>( pos == end ) &#123;                          <span class="comment">// 若 elem 不存在，则返回</span></div><div class="line">        <span class="keyword">return</span> end;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">auto</span> newEnd = pos;</div><div class="line">    <span class="keyword">for</span>( ++pos; pos != end; ++pos ) &#123;</div><div class="line">        <span class="keyword">if</span>( *pos != elem ) &#123;</div><div class="line">            *newEnd++ = <span class="built_in">std</span>::move( *pos );</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> newEnd;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator, <span class="keyword">typename</span> UnaryPredicate&gt;</div><div class="line"><span class="function">ForwardIterator <span class="title">remove_if</span><span class="params">( ForwardIterator beg, ForwardIterator end, UnaryPredicate predicate )</span> </span>&#123;</div><div class="line">    <span class="keyword">auto</span> pos = mystl::find_if( beg, end, predicate );</div><div class="line">    <span class="keyword">if</span>( pos == end ) &#123;</div><div class="line">        <span class="keyword">return</span> end;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">auto</span> newEnd = pos;</div><div class="line">    <span class="keyword">for</span>( ++pos; pos != end; ++pos ) &#123;</div><div class="line">        <span class="keyword">if</span>( !predicate( *pos ) ) &#123;</div><div class="line">            *newEnd++ = <span class="built_in">std</span>::move( *pos );</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> newEnd;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;;    <span class="comment">// namespace mystl</span></div></pre></td></tr></table></figure></p>
<p>　　由于<code>remove()</code>算法将会修改容器，因此，<strong>不能</strong>将其应用于关联容器或无序容器。</p>
<h2 id="拷贝删除算法"><a href="#拷贝删除算法" class="headerlink" title="拷贝删除算法"></a>拷贝删除算法</h2><p>　　<code>remove_copy()</code>算法会将输入范围中的元素拷贝到输出范围，但不会对指定的元素执行拷贝，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; coll = &#123; <span class="number">9</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span> &#125;;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"all elements except 5: "</span>;</div><div class="line">mystl::remove_copy( coll.cbegin(), coll.cend(), ostream_iterator&lt;<span class="keyword">int</span>&gt;( <span class="built_in">cout</span>, <span class="string">" "</span> ), <span class="number">5</span> );</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\nall odd elements: "</span>;</div><div class="line">mystl::remove_copy_if( coll.cbegin(), coll.cend(), ostream_iterator&lt;<span class="keyword">int</span>&gt;( <span class="built_in">cout</span>, <span class="string">" "</span> ),</div><div class="line">                       []( <span class="keyword">int</span> elem ) &#123;</div><div class="line">                           <span class="keyword">return</span> elem % <span class="number">2</span> == <span class="number">0</span>;</div><div class="line">                       &#125;);</div><div class="line"><span class="comment">/***</span></div><div class="line">all elements except 5: 9 8 6 7 7 7 4 2 1 </div><div class="line">all odd elements: 9 5 7 5 7 7 5 1</div><div class="line">***/</div></pre></td></tr></table></figure></p>
<p>　　<code>remove_copy()</code>返回一个迭代器，指向输出范围最后一个元素之后的一个位置，算法的实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">namespace</span> mystl &#123;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> OutputIterator, <span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function">OutputIterator <span class="title">remove_copy</span><span class="params">( InputIterator srcBeg, InputIterator srcEnd, </span></span></div><div class="line">                            OutputIterator desBeg, <span class="keyword">const</span> T &amp;elem ) &#123;</div><div class="line">    <span class="keyword">while</span>( srcBeg != srcEnd ) &#123;</div><div class="line">        <span class="keyword">auto</span> copy = *srcBeg++;</div><div class="line">        <span class="keyword">if</span>( copy != elem ) &#123;</div><div class="line">            *desBeg++ = copy;</div><div class="line">        &#125; </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> desBeg;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> OutputIterator, <span class="keyword">typename</span> UnaryPredicate&gt;</div><div class="line"><span class="function">OutputIterator <span class="title">remove_copy_if</span><span class="params">( InputIterator srcBeg, InputIterator srcEnd, </span></span></div><div class="line">                               OutputIterator desBeg, UnaryPredicate predicate ) &#123;</div><div class="line">    <span class="keyword">while</span>( srcBeg != srcEnd ) &#123;</div><div class="line">        <span class="keyword">auto</span> copy = *srcBeg++;</div><div class="line">        <span class="keyword">if</span>( !predicate( copy ) ) &#123;</div><div class="line">            *desBeg++ = copy;</div><div class="line">        &#125; </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> desBeg;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;;    <span class="comment">// namespace mystl</span></div></pre></td></tr></table></figure></p>
<h2 id="删除连续重复值"><a href="#删除连续重复值" class="headerlink" title="删除连续重复值"></a>删除连续重复值</h2><p>　　使用<code>unique()</code>能将连续的重复元素移除，因此，相邻的重复元素只保留一个，例如，对于以下数组：<br><img src="/images/data-structure/unique1.png" alt=""><br>　　执行<code>unique()</code>之后：<br><img src="/images/data-structure/unique2.png" alt=""><br>　　移去相邻的重复元素：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec = &#123; <span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">4</span> &#125;;</div><div class="line"><span class="keyword">auto</span> end = mystl::unique( vec.begin(), vec.end() );</div><div class="line">copy( vec.begin(), end, ostream_iterator&lt;<span class="keyword">int</span>&gt;( <span class="built_in">cout</span>, <span class="string">" "</span> ) );</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">vec.erase( mystl::unique( vec.begin(), end, greater&lt;<span class="keyword">int</span>&gt;&#123;&#125; ), vec.end() );</div><div class="line">copy( vec.begin(), vec.end(), ostream_iterator&lt;<span class="keyword">int</span>&gt;( <span class="built_in">cout</span>, <span class="string">" "</span> ) );</div><div class="line"><span class="comment">/***</span></div><div class="line">1 4 6 1 2 3 1 6 5 7 5 4 </div><div class="line">1 4 6 6 7 </div><div class="line">***/</div></pre></td></tr></table></figure></p>
<p>　　具体的实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">namespace</span> mystl &#123;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator, <span class="keyword">typename</span> BinaryPredicate&gt;</div><div class="line"><span class="function">ForwardIterator <span class="title">unique</span><span class="params">( ForwardIterator beg, ForwardIterator end, BinaryPredicate predicate )</span> </span>&#123;</div><div class="line">    beg = mystl::adjacent_find( beg, end, predicate );</div><div class="line">    <span class="keyword">if</span>( beg == end ) &#123;</div><div class="line">        <span class="keyword">return</span> end;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">auto</span> newEnd = beg++;</div><div class="line">    <span class="keyword">while</span>( ++beg != end ) &#123;</div><div class="line">        <span class="keyword">if</span>( !predicate( *newEnd, *beg ) ) &#123;</div><div class="line">            *(++newEnd) = <span class="built_in">std</span>::move( *beg );</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ++newEnd;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator&gt;</div><div class="line"><span class="function">ForwardIterator <span class="title">unique</span><span class="params">( ForwardIterator beg, ForwardIterator end )</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> mystl::unique( beg, end, <span class="built_in">std</span>::equal_to&lt;<span class="keyword">decltype</span>(*beg)&gt;() );</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;;    <span class="comment">// namespace mystl</span></div></pre></td></tr></table></figure></p>
<h2 id="唯一拷贝算法"><a href="#唯一拷贝算法" class="headerlink" title="唯一拷贝算法"></a>唯一拷贝算法</h2><p>　　可以使用<code>unique_copy()</code>将输入范围中的元素拷贝到输出范围，但相邻的重复元素只保留一个，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec = &#123; <span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">4</span> &#125;;</div><div class="line">mystl::unique_copy( vec.cbegin(), vec.cend(), ostream_iterator&lt;<span class="keyword">int</span>&gt;( <span class="built_in">cout</span>, <span class="string">" "</span> ) );</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">mystl::unique_copy( vec.cbegin(), vec.cend(), ostream_iterator&lt;<span class="keyword">int</span>&gt;( <span class="built_in">cout</span>, <span class="string">" "</span> ),</div><div class="line">                    []( <span class="keyword">int</span> first, <span class="keyword">int</span> second ) &#123;</div><div class="line">                        <span class="keyword">return</span> first + <span class="number">1</span> == second || first - <span class="number">1</span> == second;</div><div class="line">                    &#125;); </div><div class="line"><span class="comment">/***</span></div><div class="line">1 4 6 1 2 3 1 6 5 7 5 4 </div><div class="line">1 4 4 6 1 3 1 6 6 6 4 4</div><div class="line">***/</div></pre></td></tr></table></figure></p>
<p>　　具体的实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">namespace</span> mystl &#123;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> OutputIterator, <span class="keyword">typename</span> BinaryPredicate&gt;</div><div class="line"><span class="function">OutputIterator <span class="title">unique_copy</span><span class="params">( InputIterator srcBeg, InputIterator srcEnd, </span></span></div><div class="line">                            OutputIterator desBeg, BinaryPredicate predicate ) &#123;</div><div class="line">    <span class="keyword">if</span>( srcBeg == srcEnd ) &#123;</div><div class="line">        <span class="keyword">return</span> desBeg;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">auto</span> lastOutputElem = *srcBeg++;</div><div class="line">    *desBeg++ = lastOutputElem;</div><div class="line">    <span class="keyword">while</span>( srcBeg != srcEnd ) &#123;</div><div class="line">        <span class="keyword">auto</span> currentElem = *srcBeg++;</div><div class="line">        <span class="keyword">if</span>( !predicate( lastOutputElem, currentElem ) ) &#123;</div><div class="line">            *desBeg++ = currentElem;</div><div class="line">            lastOutputElem = <span class="built_in">std</span>::move( currentElem );</div><div class="line">        &#125;</div><div class="line">    &#125; </div><div class="line">    <span class="keyword">return</span> desBeg;</div><div class="line">&#125; </div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> OutputIterator&gt;</div><div class="line"><span class="function">OutputIterator <span class="title">unique_copy</span><span class="params">( InputIterator srcBeg, InputIterator srcEnd,</span></span></div><div class="line">                            OutputIterator desBeg ) &#123;</div><div class="line">    <span class="keyword">return</span> mystl::unique_copy( srcBeg, srcEnd, desBeg, <span class="built_in">std</span>::equal_to&lt;<span class="keyword">decltype</span>(*srcBeg)&gt;&#123;&#125; );</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;;    <span class="comment">// namespace mystl</span></div></pre></td></tr></table></figure></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://book.douban.com/subject/10440485/" target="_blank" rel="external">The C++ Standard Library Second Edition</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="John Doe" />
          <p class="site-author-name" itemprop="name">John Doe</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">97</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">14</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">17</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  

  

  

  

</body>
</html>
