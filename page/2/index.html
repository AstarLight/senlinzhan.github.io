<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/page/2/"/>

  <title> Hexo </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Hexo</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/02/20/go类型系统/" itemprop="url">
                  Go语言：类型系统
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-02-20T12:00:46+08:00" content="2016-02-20">
              2016-02-20
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/编程语言/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h2><p>　　Go 允许用户自定义类型，可以定义 struct 类型：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</div><div class="line">    name      <span class="keyword">string</span></div><div class="line">    email     <span class="keyword">string</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　创建 user 类型变量：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> joker user     <span class="comment">// joker 的每个 filed 都将被初始化成相应的 zero value</span></div></pre></td></tr></table></figure></p>
<p>　　创建 user 类型的变量并且对其进行初始化：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">joker := user&#123;</div><div class="line">    name:    <span class="string">"joker"</span>,</div><div class="line">    email:   <span class="string">"joker@gmail.com"</span>,</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　也可以这样做，不过初始化每个字段时，要注意字段的次序：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">joker := user&#123; <span class="string">"joker"</span>, <span class="string">"joker@gmail.com"</span>&#125;</div></pre></td></tr></table></figure></p>
<p>　　我们也可以将 user 类型的变量作为另一 struct 的字段：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> admin <span class="keyword">struct</span> &#123;</div><div class="line">    person user</div><div class="line">    level  <span class="keyword">string</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　创建 admin 类型变量并初始化：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">jack := admin&#123;</div><div class="line">    person: user&#123;</div><div class="line">        name:  <span class="string">"jack"</span>,</div><div class="line">        email: <span class="string">"jack@gmail.com"</span>,</div><div class="line">    &#125;,</div><div class="line">    level: <span class="string">"super"</span>,</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　除了通过 struct 来自定义类型，还可以使用 type 自定义类型：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Duration <span class="keyword">int64</span></div></pre></td></tr></table></figure></p>
<p>　　尽管 Duration 和 int64 的作用一样，但它们却是两种完全不同的类型。因此我们不能将 int64 的值赋给 Duration 类型的变量。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">type</span> Duration <span class="keyword">int64</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> dur Duration</div><div class="line">	dur = <span class="keyword">int64</span>(<span class="number">1000</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// prog.go:7: cannot use int64(1000) (type int64) as type Duration in assignment</span></div></pre></td></tr></table></figure></p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>　　我们可以为 user 类型定义方法：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// value receiver</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u user)</span> <span class="title">notify</span><span class="params">()</span></span> &#123;</div><div class="line">    fmt.Printf(<span class="string">"Sending User Email To %s&lt;%s&gt;\n"</span>, u.name, u.email)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// pointer receiver</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *user)</span> <span class="title">changeEmail</span><span class="params">(email <span class="keyword">string</span>)</span></span> &#123;</div><div class="line">    u.email = email</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　notify 方法接受的是 user 类型值，所以当你调用 notify 方法时，notify 操作的是这个 user 值的副本。而 changeEmail 接受的是 user 类型指针，所以当你调用 changeEmail 方法是，changeEmail 操作的是这个 user 值本身。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">bill := user&#123;<span class="string">"bill"</span>, <span class="string">"bill@gmail.com"</span>&#125;</div><div class="line">bill.notify()</div><div class="line">bill.changeEmail(<span class="string">"bill@163.com"</span>)</div></pre></td></tr></table></figure></p>
<p>　　bill 是 user 类型值，但 changeEmail 方法接受的是 user 指针，编译器帮我们做了额外的转换：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(&amp;bill).changeEmail(<span class="string">"bill@163.com"</span>)</div></pre></td></tr></table></figure></p>
<p>　　另一方面，notify 方法接受 user 类型值：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sill := &amp;user&#123;<span class="string">"sill"</span>, <span class="string">"sill@gmail.com"</span>&#125;</div><div class="line">sill.notify()</div><div class="line">sill.changeEmail(<span class="string">"sill@163.com"</span>)</div></pre></td></tr></table></figure></p>
<p>　　编译器帮我们做了额外的操作：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(*sill).notify()</div></pre></td></tr></table></figure></p>
<h2 id="类型的性质"><a href="#类型的性质" class="headerlink" title="类型的性质"></a>类型的性质</h2><p>　　如果一个方法需要创建变量的副本，并对这个副本进行修改，那么使用 value receiver。如果一个方法需要修改变量自身，那么使用 pointer receiver。</p>
<p>　　对于基本类型包括 string 来说，我们将这些类型的变量传递给函数或方法时，这个函数或方法应当创建变量的副本。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Trim</span><span class="params">(s <span class="keyword">string</span>, cutset <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> s == <span class="string">""</span> || cutset == <span class="string">""</span> &#123;</div><div class="line">		<span class="keyword">return</span> s</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> TrimFunc(s, makeCutsetFunc(cutset))</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　Go 中的引用类型为 slice，map，channel，interface 和 func 类型。这些类型的变量内部都包含指针，指向底层数据结构，此外还可能包含其它字段用于管理底层的数据结构。当引用类型值被拷贝时，实际上我们无法拷贝底层的数据结构。因此，我们应当传递引用类型值的副本给函数或者方法。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// in file golang.org/src/net/ip.go</span></div><div class="line"><span class="keyword">type</span> IP []<span class="keyword">byte</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ip IP)</span> <span class="title">MarshalText</span><span class="params">()</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(ip) == <span class="number">0</span> &#123;</div><div class="line">		<span class="keyword">return</span> []<span class="keyword">byte</span>(<span class="string">""</span>), <span class="literal">nil</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(ip) != IPv4len &amp;&amp; <span class="built_in">len</span>(ip) != IPv6len &#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"invalid IP address"</span>)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> []<span class="keyword">byte</span>(ip.String()), <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ipEmptyString is like ip.String except that it returns</span></div><div class="line"><span class="comment">// an empty string when ip is unset.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">ipEmptyString</span><span class="params">(ip IP)</span> <span class="title">string</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(ip) == <span class="number">0</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="string">""</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> ip.String()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　对于 struct 来说，当我们想改变 struct 变量，但不想改变变量自身，这时这种类型 struct 拥有基本类型的性质。当我们将这种类型的变量传递给函数或方法时，应当按值传递这个变量。同样，从函数或方法中返回时，应当按值返回。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// in file golang.org/src/time/time.go</span></div><div class="line"><span class="keyword">type</span> Time <span class="keyword">struct</span> &#123;</div><div class="line">	<span class="comment">// sec gives the number of seconds elapsed since</span></div><div class="line">	<span class="comment">// January 1, year 1 00:00:00 UTC.</span></div><div class="line">	sec <span class="keyword">int64</span></div><div class="line"></div><div class="line">	<span class="comment">// nsec specifies a non-negative nanosecond</span></div><div class="line">	<span class="comment">// offset within the second named by Seconds.</span></div><div class="line">	<span class="comment">// It must be in the range [0, 999999999].</span></div><div class="line">	nsec <span class="keyword">int32</span></div><div class="line"></div><div class="line">	<span class="comment">// loc specifies the Location that should be used to</span></div><div class="line">	<span class="comment">// determine the minute, hour, month, day, and year</span></div><div class="line">	<span class="comment">// that correspond to this Time.</span></div><div class="line">	<span class="comment">// Only the zero Time has a nil Location.</span></div><div class="line">	<span class="comment">// In that case it is interpreted to mean UTC.</span></div><div class="line">	loc *Location</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 按值返回</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Now</span><span class="params">()</span> <span class="title">Time</span></span> &#123;</div><div class="line">	sec, nsec := now()</div><div class="line">	<span class="keyword">return</span> Time&#123;sec + unixToInternal, nsec, Local&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 按值返回</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Add</span><span class="params">(d Duration)</span> <span class="title">Time</span></span> &#123;</div><div class="line">	t.sec += <span class="keyword">int64</span>(d / <span class="number">1e9</span>)</div><div class="line">	nsec := <span class="keyword">int32</span>(t.nsec) + <span class="keyword">int32</span>(d%<span class="number">1e9</span>)</div><div class="line">	<span class="keyword">if</span> nsec &gt;= <span class="number">1e9</span> &#123;</div><div class="line">		t.sec++</div><div class="line">		nsec -= <span class="number">1e9</span></div><div class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> nsec &lt; <span class="number">0</span> &#123;</div><div class="line">		t.sec--</div><div class="line">		nsec += <span class="number">1e9</span></div><div class="line">	&#125;</div><div class="line">	t.nsec = nsec</div><div class="line">	<span class="keyword">return</span> t          </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　但是大多数的 struct 类型并不像基本类型那样，对这种类型的 struct 变量修改时，将改变变量自身。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// in file golang.org/src/os/file_unix.go</span></div><div class="line"></div><div class="line"><span class="comment">// File represents an open file descriptor.</span></div><div class="line"><span class="keyword">type</span> File <span class="keyword">struct</span> &#123;</div><div class="line">	*file</div><div class="line">&#125;</div><div class="line"><span class="comment">// file is the real representation of *File.</span></div><div class="line"><span class="comment">// The extra level of indirection ensures that no clients of os</span></div><div class="line"><span class="comment">// can overwrite this data, which could cause the finalizer</span></div><div class="line"><span class="comment">// to close the wrong file descriptor.</span></div><div class="line"><span class="keyword">type</span> file <span class="keyword">struct</span> &#123;</div><div class="line">	fd <span class="keyword">int</span></div><div class="line">	name <span class="keyword">string</span></div><div class="line">	dirinfo *dirInfo <span class="comment">// nil unless directory being read</span></div><div class="line">	nepipe <span class="keyword">int32</span> <span class="comment">// number of consecutive EPIPE in Write</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　标准库 file 类型实际上并不允许被拷贝，因此 File 是 file 的指针，防止用户拷贝 file。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// in file golang.org/src/os/file.go</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(file *File, err error)</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> OpenFile(name, O_RDONLY, <span class="number">0</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　Open 函数返回 File 指针，当工厂函数返回指针时，正好说明了 File 类型（实际上是 file 类型）是 nonprimitive 的。</p>
<p>　　即使函数或方法并不会直接修改 nonprimitive 值的状态，仍需传递指针：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 尽管 Chdir 不会修改 File，但 File 拥有 nonprimitive 性质，因此使用 pointer receiver</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Chdir</span><span class="params">()</span> <span class="title">error</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> f == <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> ErrInvalid</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> e := syscall.Fchdir(f.fd); e != <span class="literal">nil</span> &#123;</div><div class="line">		<span class="keyword">return</span> &amp;PathError&#123;<span class="string">"chdir"</span>, f.name, e&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　当 struct 类型拥有 primitive 性质时，方法使用 value receiver，若拥有 nonprimitive 性质，则使用 pointer receiver。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>　　Go 的多态使我们更容易写出通用代码。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// in file golang.org/src/io/io.go</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteString</span><span class="params">(w Writer, s <span class="keyword">string</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</div><div class="line">	<span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　无论任何类型，只要实现了 Writer 接口，就可以用在 WriteString 函数中。</p>
<p>　　fmt.Fprintf 函数第一个参数的类型是 io.Writer，因此，任何实现了 io.Writer 接口的类型都可以传递给 fmt.Fprintf 函数。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"bytes"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"io"</span></div><div class="line">	<span class="string">"os"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> b bytes.Buffer</div><div class="line"></div><div class="line">	<span class="comment">// Write a string to the buffer.</span></div><div class="line">	b.Write([]<span class="keyword">byte</span>(<span class="string">"Hello"</span>))</div><div class="line"></div><div class="line">	<span class="comment">// Use Fprintf to concatenate a string to the Buffer.</span></div><div class="line">	fmt.Fprintf(&amp;b, <span class="string">"World!"</span>)</div><div class="line"></div><div class="line">	<span class="comment">// Write the content of the Buffer to stdout.</span></div><div class="line">	io.Copy(os.Stdout, &amp;b)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　bytes.Buffer 实现了 Writer 接口，因此可以将 bytes.Buffer 变量传递给 fmt.Fprintf 函数。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Copy</span><span class="params">(dst Writer, src Reader)</span> <span class="params">(written <span class="keyword">int64</span>, err error)</span></span></div></pre></td></tr></table></figure></p>
<p>　　同样，bytes.Buffer 实现了 Reader 接口，因此可以将 bytes.Buffer 变量作为 Copy 第二个参数。</p>
<hr>
<p>　　程序中并不总是可以得到一个值的地址：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> duration <span class="keyword">int</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *duration)</span> <span class="title">pretty</span><span class="params">()</span> <span class="title">string</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">"Duration: %d"</span>, *d)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	duration(<span class="number">42</span>).pretty()</div><div class="line"></div><div class="line">	<span class="comment">// go: cannot call pointer method on duration(42)</span></div><div class="line">	<span class="comment">// go: cannot take the address of duration(42)</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　程序无法得到 duration(42) 的地址，因此程序编译出错。</p>
<p>　　user 实现了 notifier 接口，user 使用 pointer receiver 来实现 notify 方法：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> notifier <span class="keyword">interface</span> &#123;</div><div class="line">	notify()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</div><div class="line">	name  <span class="keyword">string</span></div><div class="line">	email <span class="keyword">string</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// notify implements a method with a pointer receiver.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *user)</span> <span class="title">notify</span><span class="params">()</span></span> &#123;</div><div class="line">	fmt.Printf(<span class="string">"Sending user email to %s&lt;%s&gt;\n"</span>, u.name, u.email)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="comment">// Create a value of type User and send a notification.</span></div><div class="line">	u := user&#123;<span class="string">"Bill"</span>, <span class="string">"bill@email.com"</span>&#125;</div><div class="line"></div><div class="line">	sendNotification(u)</div><div class="line"></div><div class="line">	<span class="comment">//   go: cannot use u (type user) as type</span></div><div class="line">	<span class="comment">//                     notifier in argument to sendNotification:</span></div><div class="line">	<span class="comment">//   user does not implement notifier</span></div><div class="line">	<span class="comment">//                          (notify method has pointer receiver)</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendNotification</span><span class="params">(n notifier)</span></span> &#123;</div><div class="line">	n.notify()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　编译出错，显示 user 并没有实现 notifier 接口。前面说到，程序并不总是能获得一个值的地址，user 通过 pointer receiver 实现 notify 方法，因此需要知道 user 值的地址，才能调用它的 notify 方法。所以我们需要传递 user 变量的地址给 sendNotification 函数。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sendNotification(&amp;u)</div></pre></td></tr></table></figure></p>
<p>　　若一个 struct 类型 T 实现了接口 U 的方法：</p>
<ul>
<li>若通过 value receiver 实现 U 接口的方法，那么 T 和 *T 都实现了 U 接口。</li>
<li>若通过 pointer receiver 实现 U 接口的方法，那么只有 *T 实现了 U 接口。</li>
</ul>
<hr>
<p>　　Go 支持类型嵌套，即是拓展一个既存的类型，并改变其行为。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</div><div class="line">	name  <span class="keyword">string</span></div><div class="line">	email <span class="keyword">string</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *user)</span> <span class="title">notify</span><span class="params">()</span></span> &#123;</div><div class="line">	fmt.Printf(<span class="string">"Sending user email to %s&lt;%s&gt;\n"</span>, u.name, u.email)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> admin <span class="keyword">struct</span> &#123;</div><div class="line">	user  <span class="comment">// 嵌套类型</span></div><div class="line">	level <span class="keyword">string</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	ad := admin&#123;</div><div class="line">		user: user&#123;</div><div class="line">			name:  <span class="string">"john smith"</span>,</div><div class="line">			email: <span class="string">"john@yahoo.com"</span>,</div><div class="line">		&#125;,</div><div class="line">		level: <span class="string">"super"</span>,</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	ad.user.notify()</div><div class="line"></div><div class="line">	<span class="comment">// 内部类型的方法得到提升</span></div><div class="line">	ad.notify()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　user 是 admin 的内部类型，我们可以直接通过 admin 变量访问 user 的字段和方法。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ad.notify()</div><div class="line">fmt.Println(ad.name)</div></pre></td></tr></table></figure></p>
<p>　　如果 user 实现 notifier 接口，那么 admin 也会间接地实现了 notifier 接口：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> notifier <span class="keyword">interface</span> &#123;</div><div class="line">	notify()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendNotification</span><span class="params">(n notifier)</span></span> &#123;</div><div class="line">	n.notify()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	ad := admin&#123;</div><div class="line">		user: user&#123;</div><div class="line">			name:  <span class="string">"john smith"</span>,</div><div class="line">			email: <span class="string">"john@yahoo.com"</span>,</div><div class="line">		&#125;,</div><div class="line">		level: <span class="string">"super"</span>,</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	sendNotification(&amp;ad)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　外部类型声明与内部类型相同的方法，这将会覆写内部类型的方法：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *admin)</span> <span class="title">notify</span><span class="params">()</span></span> &#123;</div><div class="line">	fmt.Printf(<span class="string">"Sending admin email to %s&lt;%s&gt;\n"</span>, a.name, a.email)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line">sendNotification(&amp;ad)       <span class="comment">// Sending Admin Email To john smith&lt;john@yahoo.com&gt;</span></div><div class="line">ad.user.notify()            <span class="comment">// Sending user email to john smith&lt;john@yahoo.com&gt;</span></div><div class="line">ad.notify()                 <span class="comment">// Sending admin email to john smith&lt;john@yahoo.com&gt;</span></div></pre></td></tr></table></figure></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.amazon.com/Go-Action-William-Kennedy/dp/1617291781/ref=sr_1_1?ie=UTF8&amp;qid=1455965297&amp;sr=8-1&amp;keywords=go+in+action" target="_blank" rel="external">Go in Action</a>
　　</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/02/12/go-in-action-并发/" itemprop="url">
                  【翻译】Go in Action：并发
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-02-12T16:00:46+08:00" content="2016-02-12">
              2016-02-12
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/编程语言/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>　　通常一个程序能被编写成直线型代码，用于执行完成单个任务。若这样做是可能的，应当总是选择这样做，因为这种类型的程序通常易于编写和维护。但也有时候并发地执行多个任务会带来更大的好处。一个例子是 web service 在同一时间能够接受多个 socket 上的数据请求。每个 socket 都是独一无二的，并且能够被独立地处理而无需互相依赖。拥有这种并发地处理请求的能力，就能极大地提高这种类型的系统的性能。有了这个想法，Go 语言及其运行时已经直接提供了对并发的支持。</p>
<p>　　Go 的并发使得函数不用相互依赖地独立运行。将一个函数创建成 goroutine，那么它将被当成独立的工作单元，并且之后将会在可用的逻辑处理器上执行。Go 的运行时调度器是复杂的软件，用于管理那些需要处理器时间的 goroutine。调度器位于操作系统之上，将操作系统的线程绑定到用于执行 goroutine 的逻辑处理器上。在任何时间，调度器都将控制与“哪个 goroutine 运行在哪个逻辑处理器”相关的所有事。</p>
<p>　　并发的同步来自一个范式，这个范式是 communication sequential processes 即 CSP。CSP 是一个消息传递模型，用于在 goroutine 之间进行数据通信，而不是对数据上锁来提供同步访问。用于在 goroutine 之间同步和传递消息的关键数据类型是 channel。对于那些从未使用过 channel 来编写并发程序的许多开发者来说，它们将感到敬畏和兴奋，你也将感同身受。使用 channel 使得编写并发的程序变得更加简单，并且更少出现错误。</p>
<h2 id="并发-VS-并行"><a href="#并发-VS-并行" class="headerlink" title="并发 VS 并行"></a>并发 VS 并行</h2><p>　　让我们从宏观的角度了解操作系统的进程和线程分别是什么。这会帮助你理解 Go 运行时的调度器和操作系统是怎样并发地运行 goroutine 的。当你运行一个应用程序，例如 IDE 或编辑器，操作系统将会为它启动一个进程。你可以将进程想象一个容器，用来容纳程序执行时使用和管理的所有资源。</p>
<p>　　图 6.1 显示了一个包含了通用资源的进程，这些资源可由进程分配。这些资源包含但不限于内存地址空间，文件句柄，设备和线程。线程是一个执行路径，操作系统调度线程去执行你在函数中所写的代码。每个进程至少包含一个线程，并且每个进程的初始化线程称为主线程。当主线程终结，则程序终结，因为这个执行路径是程序的起始点。操作系统调度线程运行在处理器上，而不用管这些线程属于哪个进程。不同操作系统所使用的线程调度算法总是在改变的，并且对程序员来说是抽象的。<br><img src="/images/data-structure/go-6.1.png" alt=""></p>
<p>　　操作系统调度线程运行在物理处理器上，Go 的运行时则调度 goroutine 运行在逻辑处理器之上，每个逻辑处理器分别绑定到一个操作系统的线程。在 Go 1.5 版本中，默认情况下是为每个可用的物理处理器都分配一个逻辑处理器，而在 1.5 版本之前，默认则是只分配一个逻辑处理器。这些逻辑处理器用来执行所有创建的 goroutine。即使在单个逻辑处理器，成千上万的 goroutine 也可以被调度成并发地运行，同时拥有惊人的高效和性能。</p>
<p>　　在图 6.2 中，你可以看到操作系统线程，逻辑处理器和本地运行队列之间的关系。当 goroutine 被创建并准备运行时，它们将被放置在调度器的全局运行队列。接下来，它们将赋给逻辑处理器，并放置在逻辑处理器的本地运行队列。在此之后，goroutine 将等待被逻辑处理器执行。<br><img src="/images/data-structure/go-6.2.png" alt=""></p>
<p>　　有时一个正在运行中的 goroutine 可能需要执行阻塞的系统调用，例如打开文件，这时线程和 goroutine 将从逻辑处理器中分离，线程将继续阻塞，等待系统调用返回。在这个期间，这个逻辑处理器没有绑定线程，所以调度器将创建新的线程，并将它绑定到逻辑处理器，接着调度器将从本地运行队列中选择另一个 goroutine，并运行它。一旦系统调用返回，goroutine 将放置在本地运行队列，并且线程将被放置到一边，用于将来使用。</p>
<p>　　如果 goroutine 需要执行网络 I/O 调用，这个过程将有所不同。在这种情况下，goroutine 将从逻辑处理器上分离，并移动到集成于运行时的网络 poller。一旦 poller 发觉网络的读或写的操作准备好了，goroutine 将重新赋给逻辑处理器，用于处理这些操作。调度器并没有限定可以创建的逻辑处理器的数目。但运行时默认情况下限定每个程序最多能拥有 10000 个线程。这个值可以通过 runtime/debug 包中的 SetMaxThreads 函数来改变。如果任何程序需要使用更多的线程，那么程序将会 crashes。</p>
<p>　　并发不同于并行。只有当多个代码段分别在不同的物理处理器上同时执行的时候，才称作是并行。并行是关于同一时间做很多事情，并发则是关于同一时间管理很多事情。在很多情况下，并发可以超过并行，因为它对操作系统和硬件的压力更小，这允许系统去做得更多。这就是经常所说的 less-is-more 的哲学。</p>
<p>　　如果你想要以并行的方式运行 goroutine，你使用的逻辑处理器必须多于一个。如果有多个逻辑处理器，那么调度器则会将这些 goroutine 平均分配给这些逻辑处理器。这将使得这些 goroutine 运行在不同的线程中。但为了实现真实的并行，你仍然需要将你的程序运行在拥有多个物理处理器的机器上。如果不是这样，即使 Go 的运行时使用多个线程，这些 goroutine 仍会并发地在单个物理处理器上运行。</p>
<p>　　图 6.3 显示了在单个逻辑处理器上并发地执行 goroutine 和在两个逻辑处理器上并行地执行协程之间的区别。实际上并不推荐盲目地改变运行时为逻辑处理器设定的默认配置。调度器包含智能的算法，随着每次 Go 新版本的发布，这个算法都会得到更新和改善。如果你发现性能的问题，并且这个问题可以通过改变逻辑处理器的数目来解决，那么你可以去改变它。接下来你将学到更多。<br><img src="/images/data-structure/go-6.3.png" alt=""></p>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>　　让我们了解更多调度器的行为，以及怎样创建 goroutine 并管理它们的生命周期。在讨论如何并行地运行 goroutine 之前，我们将展示一个例子，这个例子使用单个逻辑处理器。这个程序创建两个 goroutine，以并发的方式分别展示大写和小写的英文字母表。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// This sample program demonstrates how to create goroutines and</span></div><div class="line"><span class="comment">// how the scheduler behaves.</span></div><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"runtime"</span></div><div class="line">	<span class="string">"sync"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// main is the entry point for all Go programs.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="comment">// Allocate 1 logical processor for the scheduler to use.</span></div><div class="line">	runtime.GOMAXPROCS(<span class="number">1</span>)</div><div class="line"></div><div class="line">	<span class="comment">// wg is used to wait for the program to finish.</span></div><div class="line">	<span class="comment">// Add a count of two, one for each goroutine.</span></div><div class="line">	<span class="keyword">var</span> wg sync.WaitGroup</div><div class="line">	wg.Add(<span class="number">2</span>)</div><div class="line"></div><div class="line">	fmt.Println(<span class="string">"Start Goroutines"</span>)</div><div class="line"></div><div class="line">	<span class="comment">// Declare an anonymous function and create a goroutine.</span></div><div class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		<span class="comment">// Schedule the call to Done to tell main we are done.</span></div><div class="line">		<span class="keyword">defer</span> wg.Done()</div><div class="line"></div><div class="line">		<span class="comment">// Display the alphabet three times</span></div><div class="line">		<span class="keyword">for</span> count := <span class="number">0</span>; count &lt; <span class="number">3</span>; count++ &#123;</div><div class="line">			<span class="keyword">for</span> char := <span class="string">'a'</span>; char &lt; <span class="string">'a'</span>+<span class="number">26</span>; char++ &#123;</div><div class="line">				fmt.Printf(<span class="string">"%c "</span>, char)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;()</div><div class="line"></div><div class="line">	<span class="comment">// Declare an anonymous function and create a goroutine.</span></div><div class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		<span class="comment">// Schedule the call to Done to tell main we are done.</span></div><div class="line">		<span class="keyword">defer</span> wg.Done()</div><div class="line"></div><div class="line">		<span class="comment">// Display the alphabet three times</span></div><div class="line">		<span class="keyword">for</span> count := <span class="number">0</span>; count &lt; <span class="number">3</span>; count++ &#123;</div><div class="line">			<span class="keyword">for</span> char := <span class="string">'A'</span>; char &lt; <span class="string">'A'</span>+<span class="number">26</span>; char++ &#123;</div><div class="line">				fmt.Printf(<span class="string">"%c "</span>, char)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;()</div><div class="line"></div><div class="line">	<span class="comment">// Wait for the goroutines to finish.</span></div><div class="line">	fmt.Println(<span class="string">"Waiting To Finish"</span>)</div><div class="line">	wg.Wait()</div><div class="line"></div><div class="line">	fmt.Println(<span class="string">"\nTerminating Program"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　在第 14 行，可以看到调用了 runtime 包的 GOMAXPROCS 函数，这个函数允许程序更改由调度器使用的逻辑处理器的数目。如果你不想在程序中显示地调用这个函数，也可以设置同名的环境变量。通过传递 1 这个值，我们告诉调度器使用单个逻辑处理器。</p>
<p>　　24 到 37 行，我们声明了两个匿名函数用来展示英文字母表。通过使用 go 关键词，这两个函数均被创建成 goroutine。你可以从程序的输出看到每个 goroutine 中的代码都并发地运行在单个处理器上。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Start Goroutines</div><div class="line">Waiting To Finish</div><div class="line">A B C D E F G H I J K L M N O P Q R S T U V W X Y Z A B C D E F G H I J K L M</div><div class="line">N O P Q R S T U V W X Y Z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z</div><div class="line">a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m</div><div class="line">n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z </div><div class="line">Terminating Program</div></pre></td></tr></table></figure></p>
<p>　　第一个 goroutine 展示完字母表的时间是非常短的，因此在调度器换出到第二个 goroutine 之前，第一个 goroutine 已经完成了它的任务。这就是为什么你先看到大写的字母表，其次才看到小写的字母表。我们创建的两个 goroutine 并发地运行，一个接着一个地执行它们各自展示字母表的任务。</p>
<p>　　一旦两个匿名函数被创建成 goroutine，main 函数中的代码将保持运行。这意味着在两个 goroutine 完成它们的工作之前，main 函数可以退出。若这种情况发生，在两个 goroutine 有机会运行之前，程序将会终止。因此在第 51 行中，main 函数将会使用 WaitGroup 等待两个 goroutine 完成它们的工作。</p>
<p>　　WaitGroup 是一个计数的信号量，用来为运行的 goroutine 维持记录。当 WaitGroup 的值大于 0，Wait 函数将会阻塞。第 26 行和 39 行在 defer 语句作用域中调用 Done 方法，将使得 WaitGroup 的值减少并最终退出 main 函数。</p>
<p>　　当正在执行的函数返回时，这个函数中由 defer 指定的函数将被调度运行。在程序中，我们使用 defer 关键词保证，一旦每个 goroutine 完成它的任务之后，Done 方法将被调用。</p>
<p>　　基于调度器的内部算法，一个正在运行的 goroutine 在完成它的任务之前，可以被停止并且再次被调度成运行状态。调度器这样做是为了防止单个 goroutine 劫持了逻辑处理器。调度器会停止当前运行的 goroutine，并且为另一个 runnable 的 goroutine 提供机会去运行。</p>
<p>　　图 6.4 从逻辑处理器的观点来看待这个场景。在 Step 1 中，调度器开始执行 goroutine A 而 goroutine B 则在运行队列中等待轮到它运行。接着，在 Step 2 中，调度器将为 goroutine B 换出 goroutine A。由于 goroutine A 还没有执行结束，它将被放置在运行队列的末尾。接着，在 Step 3 中，goroutine B 完成了它的任务并消失了。这就允许了 goroutine A 继续运行。<br><img src="/images/data-structure/go-6.4.png" alt=""><br>　　调度器可以在单个逻辑处理器上并发地运行多个 goroutine。像前面所说的，Go 的标准库的 runtime 包中拥有 GOMAXPROCS 函数，允许你指定由调度器使用的逻辑处理器的个数。这就是你怎样改变运行时（ runtime ）去为每个可用的物理处理器分配一个逻辑处理器。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"runtime"</span></div><div class="line"></div><div class="line"><span class="comment">// Allocate a logical processor for every available core.</span></div><div class="line">runtime.GOMAXPROCS(runtime.NumCPU())</div></pre></td></tr></table></figure></p>
<p>　　runtime 包提供支持用于改变 Go 运行时的配置参数。NumCPU 函数返回可用的物理处理器的个数。因此，上面的语句调用 GOMAXPROCS 来为每个可用的物理处理器分配一个逻辑处理器。有一点需要注意，使用超过一个逻辑处理器并不一定意味着更好的性能。当你改变任何的 runtime 配置参数，你需要一个基准用于衡量程序的性能变化。</p>
<p>　　如果我们给调度器使用的逻辑处理器多于一个，我们将看到不同的输出。让我们将逻辑处理器的数目改成 2，并且运行第一个例子，用于输出英文字母表。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// This sample program demonstrates how to create goroutines and</span></div><div class="line"><span class="comment">// how the goroutine scheduler behaves with two logical processor.</span></div><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"runtime"</span></div><div class="line">	<span class="string">"sync"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// main is the entry point for all Go programs.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="comment">// Allocate two logical processors for the scheduler to use.</span></div><div class="line">	runtime.GOMAXPROCS(<span class="number">2</span>)</div><div class="line"></div><div class="line">	<span class="comment">// wg is used to wait for the program to finish.</span></div><div class="line">	<span class="comment">// Add a count of two, one for each goroutine.</span></div><div class="line">	<span class="keyword">var</span> wg sync.WaitGroup</div><div class="line">	wg.Add(<span class="number">2</span>)</div><div class="line"></div><div class="line">	fmt.Println(<span class="string">"Start Goroutines"</span>)</div><div class="line"></div><div class="line">	<span class="comment">// Declare an anonymous function and create a goroutine.</span></div><div class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		<span class="comment">// Schedule the call to Done to tell main we are done.</span></div><div class="line">		<span class="keyword">defer</span> wg.Done()</div><div class="line"></div><div class="line">		<span class="comment">// Display the alphabet three times.</span></div><div class="line">		<span class="keyword">for</span> count := <span class="number">0</span>; count &lt; <span class="number">3</span>; count++ &#123;</div><div class="line">			<span class="keyword">for</span> char := <span class="string">'a'</span>; char &lt; <span class="string">'a'</span>+<span class="number">26</span>; char++ &#123;</div><div class="line">				fmt.Printf(<span class="string">"%c "</span>, char)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;()</div><div class="line"></div><div class="line">	<span class="comment">// Declare an anonymous function and create a goroutine.</span></div><div class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		<span class="comment">// Schedule the call to Done to tell main we are done.</span></div><div class="line">		<span class="keyword">defer</span> wg.Done()</div><div class="line"></div><div class="line">		<span class="comment">// Display the alphabet three times.</span></div><div class="line">		<span class="keyword">for</span> count := <span class="number">0</span>; count &lt; <span class="number">3</span>; count++ &#123;</div><div class="line">			<span class="keyword">for</span> char := <span class="string">'A'</span>; char &lt; <span class="string">'A'</span>+<span class="number">26</span>; char++ &#123;</div><div class="line">				fmt.Printf(<span class="string">"%c "</span>, char)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;()</div><div class="line"></div><div class="line">	<span class="comment">// Wait for the goroutines to finish.</span></div><div class="line">	fmt.Println(<span class="string">"Waiting To Finish"</span>)</div><div class="line">	wg.Wait()</div><div class="line"></div><div class="line">	fmt.Println(<span class="string">"\nTerminating Program"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　程序中通过 GOMAXPROCS 函数创建两个逻辑处理器，这允许了 goroutine 以并行的方式运行。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Start Goroutines</div><div class="line">Waiting To Finish</div><div class="line">A B C D E F G H I J K a L b M c N d O e P f Q g R h S i T j U k V l W m X n Y</div><div class="line">o Z p A q B r C s D t E u F v G w H x I y J z K a L b M c N d O e P f Q g R h</div><div class="line">S i T j U k V l W m X n Y o Z p A q B r C s D t E u F v G w H x I y J z K a L</div><div class="line">b M c N d O e P f Q g R h S i T j U k V l W m X n Y o Z p q r s t u v w x y z </div><div class="line">Terminating Program</div></pre></td></tr></table></figure></p>
<p>　　如果你仔细看上面的输出，你会看到 goroutine 并行地执行。两个 goroutine 开始运行，并且交互地输出字母。我们的程序运行在八核的机器上，所以每个 goroutine 都运行它自己的核上。记住，只有当逻辑处理器的个数多于一个，并且存在可用的物理处理器能够同时运行每个 goroutine，那么这些 goroutine 才能并行地运行。</p>
<h2 id="竞争条件"><a href="#竞争条件" class="headerlink" title="竞争条件"></a>竞争条件</h2><p>　　当两个或更多的 goroutine 没有同步地访问共享资源，并试图同时读取和写入共享资源，这就称为竞争条件。并发程序之所以复杂和有很大的潜在 bug 就是因为竞争条件。对共享资源的读和写必须总是原子的，也就是说，在同一时间只能有一个 goroutine 执行这些操作。</p>
<p>　　这个程序包含了竞争条件。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// This sample program demonstrates how to create race</span></div><div class="line"><span class="comment">// conditions in our programs. We don't want to do this.</span></div><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"runtime"</span></div><div class="line">	<span class="string">"sync"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> (</div><div class="line">	<span class="comment">// counter is a variable incremented by all goroutines.</span></div><div class="line">	counter <span class="keyword">int</span></div><div class="line"></div><div class="line">	<span class="comment">// wg is used to wait for the program to finish.</span></div><div class="line">	wg sync.WaitGroup</div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// main is the entry point for all Go programs.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="comment">// Add a count of two, one for each goroutine.</span></div><div class="line">	wg.Add(<span class="number">2</span>)</div><div class="line"></div><div class="line">	<span class="comment">// Create two goroutines.</span></div><div class="line">	<span class="keyword">go</span> incCounter(<span class="number">1</span>)</div><div class="line">	<span class="keyword">go</span> incCounter(<span class="number">2</span>)</div><div class="line"></div><div class="line">	<span class="comment">// Wait for the goroutines to finish.</span></div><div class="line">	wg.Wait()</div><div class="line">	fmt.Println(<span class="string">"Final Counter:"</span>, counter)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// incCounter increments the package level counter variable.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">incCounter</span><span class="params">(id <span class="keyword">int</span>)</span></span> &#123;</div><div class="line">	<span class="comment">// Schedule the call to Done to tell main we are done.</span></div><div class="line">	<span class="keyword">defer</span> wg.Done()</div><div class="line"></div><div class="line">	<span class="keyword">for</span> count := <span class="number">0</span>; count &lt; <span class="number">2</span>; count++ &#123;</div><div class="line">		<span class="comment">// Capture the value of Counter.</span></div><div class="line">		value := counter</div><div class="line"></div><div class="line">		<span class="comment">// Yield the thread and be placed back in queue.</span></div><div class="line">		runtime.Gosched()</div><div class="line"></div><div class="line">		<span class="comment">// Increment our local value of Counter.</span></div><div class="line">		value++</div><div class="line"></div><div class="line">		<span class="comment">// Store the value back into Counter.</span></div><div class="line">		counter = value</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　程序输出：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Final Counter: 2</div></pre></td></tr></table></figure></p>
<p>　　counter 变量被读取和写入 4 次，每次 goroutine 2 次，但当程序结束时，counter 的值是 2。图 6.5 说明了为什么会这样。<br><img src="/images/data-structure/go1.png" alt=""></p>
<p>　　每个协程覆写了另一 goroutine 的工作，这发生在当 goroutine 交换的时候。每个 goroutine 都得到它自己的 counter 变量的副本，之后换出到另一 goroutine。当 goroutine 得到时间再次运行时，counter 变量已经被修改，但 goroutine 并没有更新它的 counter 副本的值。相反，goroutine 增加它拥有的 counter 副本的值，并将这个副本的值写入到原来 counter 变量，这样就覆盖了另一 goroutine 所做的工作。</p>
<p>　　Go 拥有特殊的工具用于侦测代码中的竞争条件。这时极有用的工具用来查找这类的 bug。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">go build -race    // Build the code using the race detector flag</div><div class="line">./example         // Run the code</div><div class="line"></div><div class="line">==================</div><div class="line">WARNING: DATA RACE</div><div class="line">Write by goroutine 5:</div><div class="line"></div><div class="line">main.incCounter()</div><div class="line">/example/main.go:49 +0x96</div><div class="line">Previous read by goroutine 6:</div><div class="line">main.incCounter()</div><div class="line">/example/main.go:40 +0x66</div><div class="line">Goroutine 5 (running) created at:</div><div class="line">main.main()</div><div class="line">/example/main.go:25 +0x5c</div><div class="line">Goroutine 6 (running) created at:</div><div class="line">main.main()</div><div class="line">/example/main.go:26 +0x73</div><div class="line">==================</div><div class="line">Final Counter: 2</div><div class="line">Found 1 data race(s)</div></pre></td></tr></table></figure></p>
<p>　　竞争侦测器指出了下面 4 行代码：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Line 49: counter = value</div><div class="line">Line 40: value := counter</div><div class="line">Line 25: go incCounter(1)</div><div class="line">Line 26: go incCounter(2)</div></pre></td></tr></table></figure></p>
<p>　　竞争侦测器告诉我们哪个 goroutine 导致了数据竞争，并且哪两行代码产生了冲突。</p>
<h2 id="为共享资源上锁"><a href="#为共享资源上锁" class="headerlink" title="为共享资源上锁"></a>为共享资源上锁</h2><p>　　Go 提供了传统的同步 goroutine 的方式，即是对共享资源的访问上锁。如果你需要顺序地访问整数变量或代码段，那么 atomic 和 sync 包中的函数则是很好的选择。我们会看下 atomic 包中的函数，和 sync 包中的 mutex 类型。</p>
<h3 id="原子函数"><a href="#原子函数" class="headerlink" title="原子函数"></a>原子函数</h3><p>　　原子函数提供了底层的上锁机制，用于同步访问整数和指针。我们可以使用原子函数来解决竞争条件。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// This sample program demonstrates how to use the atomic</span></div><div class="line"><span class="comment">// package to provide safe access to numeric types.</span></div><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"runtime"</span></div><div class="line">	<span class="string">"sync"</span></div><div class="line">	<span class="string">"sync/atomic"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> (</div><div class="line">	<span class="comment">// counter is a variable incremented by all goroutines.</span></div><div class="line">	counter <span class="keyword">int64</span></div><div class="line"></div><div class="line">	<span class="comment">// wg is used to wait for the program to finish.</span></div><div class="line">	wg sync.WaitGroup</div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// main is the entry point for all Go programs.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="comment">// Add a count of two, one for each goroutine.</span></div><div class="line">	wg.Add(<span class="number">2</span>)</div><div class="line"></div><div class="line">	<span class="comment">// Create two goroutines.</span></div><div class="line">	<span class="keyword">go</span> incCounter(<span class="number">1</span>)</div><div class="line">	<span class="keyword">go</span> incCounter(<span class="number">2</span>)</div><div class="line"></div><div class="line">	<span class="comment">// Wait for the goroutines to finish.</span></div><div class="line">	wg.Wait()</div><div class="line"></div><div class="line">	<span class="comment">// Display the final value.</span></div><div class="line">	fmt.Println(<span class="string">"Final Counter:"</span>, counter)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// incCounter increments the package level counter variable.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">incCounter</span><span class="params">(id <span class="keyword">int</span>)</span></span> &#123;</div><div class="line">	<span class="comment">// Schedule the call to Done to tell main we are done.</span></div><div class="line">	<span class="keyword">defer</span> wg.Done()</div><div class="line"></div><div class="line">	<span class="keyword">for</span> count := <span class="number">0</span>; count &lt; <span class="number">2</span>; count++ &#123;</div><div class="line">		<span class="comment">// Safely Add One To Counter.</span></div><div class="line">		atomic.AddInt64(&amp;counter, <span class="number">1</span>)</div><div class="line"></div><div class="line">		<span class="comment">// Yield the thread and be placed back in queue.</span></div><div class="line">		runtime.Gosched()</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　程序的输出：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Final Counter: 4</div></pre></td></tr></table></figure></p>
<p>　　程序第 43 行中使用 atomic 中的 AddInt64 函数，这个函数强制在同一时间内，只有一个 goroutine 来执行并完成增加操作，因此这个函数能以同步的方式来增加整数的值。当 goroutine 试图调用任何原子函数，它们自动地同步所引用的变量。现在我们得到正确的值 4。</p>
<p>　　atomic 中另外两个有用的函数是 LoadInt64 和 StoreInt64。这些函数提供了安全的方式用于读取和写入整数变量的值。下面的例子使用 LoadInt64 和 StoreInt64 函数来创建一个同步标志，这个标志代表程序的特殊条件，以此来改变 goroutine 的行为。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// This sample program demonstrates how to use the atomic</span></div><div class="line"><span class="comment">// package functions Store and Load to provide safe access</span></div><div class="line"><span class="comment">// to numeric types.</span></div><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"sync"</span></div><div class="line">	<span class="string">"sync/atomic"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> (</div><div class="line">	<span class="comment">// shutdown is a flag to alert running goroutines to shutdown.</span></div><div class="line">	shutdown <span class="keyword">int64</span></div><div class="line"></div><div class="line">	<span class="comment">// wg is used to wait for the program to finish.</span></div><div class="line">	wg sync.WaitGroup</div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// main is the entry point for all Go programs.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="comment">// Add a count of two, one for each goroutine.</span></div><div class="line">	wg.Add(<span class="number">2</span>)</div><div class="line"></div><div class="line">	<span class="comment">// Create two goroutines.</span></div><div class="line">	<span class="keyword">go</span> doWork(<span class="string">"A"</span>)</div><div class="line">	<span class="keyword">go</span> doWork(<span class="string">"B"</span>)</div><div class="line"></div><div class="line">	<span class="comment">// Give the goroutines time to run.</span></div><div class="line">	time.Sleep(<span class="number">1</span> * time.Second)</div><div class="line"></div><div class="line">	<span class="comment">// Safely flag it is time to shutdown.</span></div><div class="line">	fmt.Println(<span class="string">"Shutdown Now"</span>)</div><div class="line">	atomic.StoreInt64(&amp;shutdown, <span class="number">1</span>)</div><div class="line"></div><div class="line">	<span class="comment">// Wait for the goroutines to finish.</span></div><div class="line">	wg.Wait()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// doWork simulates a goroutine performing work and</span></div><div class="line"><span class="comment">// checking the Shutdown flag to terminate early.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">doWork</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</div><div class="line">	<span class="comment">// Schedule the call to Done to tell main we are done.</span></div><div class="line">	<span class="keyword">defer</span> wg.Done()</div><div class="line"></div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		fmt.Printf(<span class="string">"Doing %s Work\n"</span>, name)</div><div class="line">		time.Sleep(<span class="number">250</span> * time.Millisecond)</div><div class="line"></div><div class="line">		<span class="comment">// Do we need to shutdown.</span></div><div class="line">		<span class="keyword">if</span> atomic.LoadInt64(&amp;shutdown) == <span class="number">1</span> &#123;</div><div class="line">			fmt.Printf(<span class="string">"Shutting %s Down\n"</span>, name)</div><div class="line">			<span class="keyword">break</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　这个例子启动两个 goroutine 并开始执行一些工作。在 goroutine 各自循环的每次迭代中，在第 52 行中 goroutine 通过 LoadInt64 来检测 shutdown 变量的值。这个函数返回 shutdown 变量的一个安全的拷贝，如果这个值等于 1，goroutine 将退出循环并终止。</p>
<p>　　在第 35 行中，main 函数使用 StoreInt64 函数来安全地改变 shutdown 变量的值。在 main 函数调用 StoreInt64 函数的同时，如果任何一个 goroutine 试图调用 LoadInt64 函数，那么这些原子函数将会同步这些调用，并操持所有的操作都是安全的，不会出现竞争条件的。</p>
<h3 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h3><p>　　另一种方式来同步访问共享资源则是使用互斥量。互斥量是根据互相排斥来命名的。为代码中的关键部分创建互斥量，可以保证同一时间只有一个 goroutine 能执行这个关键部分的代码。我们可以使用互斥量来改正程序中出现的竞争条件。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// This sample program demonstrates how to use a mutex</span></div><div class="line"><span class="comment">// to define critical sections of code that need synchronous</span></div><div class="line"><span class="comment">// access.</span></div><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"runtime"</span></div><div class="line">	<span class="string">"sync"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">var</span> (</div><div class="line">	<span class="comment">// counter is a variable incremented by all goroutines.</span></div><div class="line">	counter <span class="keyword">int</span></div><div class="line"></div><div class="line">	<span class="comment">// wg is used to wait for the program to finish.</span></div><div class="line">	wg sync.WaitGroup</div><div class="line"></div><div class="line">	<span class="comment">// mutex is used to define a critical section of code.</span></div><div class="line">	mutex sync.Mutex</div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// main is the entry point for all Go programs.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="comment">// Add a count of two, one for each goroutine.</span></div><div class="line">	wg.Add(<span class="number">2</span>)</div><div class="line"></div><div class="line">	<span class="comment">// Create two goroutines.</span></div><div class="line">	<span class="keyword">go</span> incCounter(<span class="number">1</span>)</div><div class="line">	<span class="keyword">go</span> incCounter(<span class="number">2</span>)</div><div class="line"></div><div class="line">	<span class="comment">// Wait for the goroutines to finish.</span></div><div class="line">	wg.Wait()</div><div class="line">	fmt.Printf(<span class="string">"Final Counter: %d\n"</span>, counter)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// incCounter increments the package level Counter variable</span></div><div class="line"><span class="comment">// using the Mutex to synchronize and provide safe access.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">incCounter</span><span class="params">(id <span class="keyword">int</span>)</span></span> &#123;</div><div class="line">	<span class="comment">// Schedule the call to Done to tell main we are done.</span></div><div class="line">	<span class="keyword">defer</span> wg.Done()</div><div class="line"></div><div class="line">	<span class="keyword">for</span> count := <span class="number">0</span>; count &lt; <span class="number">2</span>; count++ &#123;</div><div class="line">		<span class="comment">// Only allow one goroutine through this</span></div><div class="line">		<span class="comment">// critical section at a time.</span></div><div class="line">		mutex.Lock()</div><div class="line">		&#123;</div><div class="line">			<span class="comment">// Capture the value of counter.</span></div><div class="line">			value := counter</div><div class="line"></div><div class="line">			<span class="comment">// Yield the thread and be placed back in queue.</span></div><div class="line">			runtime.Gosched()</div><div class="line"></div><div class="line">			<span class="comment">// Increment our local value of counter.</span></div><div class="line">			value++</div><div class="line"></div><div class="line">			<span class="comment">// Store the value back into counter.</span></div><div class="line">			counter = value</div><div class="line">		&#125;</div><div class="line">		mutex.Unlock()</div><div class="line">		<span class="comment">// Release the lock and allow any</span></div><div class="line">		<span class="comment">// waiting goroutine through.</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　对 counter 变量执行的操作现在被保护在 Lock() 和 Unklock() 之间。使用花括号仅仅是确保这个关键部分更容易被看见，花括号不是必须的。每次只能有一个 goroutine 能进入这个关键部分。直到 Unlock() 函数调用之后，另一个 goroutine 才能进入这个关键部分。当线程在第 52 行被让出时，调度器将让另一个相同的 goroutine 继续运行。在程序终止之后，我们得到正确的值 4，不会出现竞争条件。</p>
<h2 id="Channels"><a href="#Channels" class="headerlink" title="Channels"></a>Channels</h2><p>　　尽管原子函数和互斥量可以工作，但它们并没有使得并发的程序变得更加简单，更少错误或更有趣。在 Go 中，你并不只有原子函数和互斥量用来保持共享资源安全和消除竞争条件。当 goroutine 之间需要发送和接收它们需要共享的资源时，你还可以使用 channels 来同步 goroutine。</p>
<p>　　当资源需要在 goroutine 之间共享，channel 将充当 goroutine 之间的导管，提供一种机制用于保证同步的数据交换。当我们声明一个 channel，要指定需要共享的数据的类型。内置类型，命名类型，struct 和引用类型的值和指针都能通过 channel 共享。</p>
<p>　　在 Go 中创建 channel 需要使用内置的 make 函数。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Unbuffered channel of integers.</span></div><div class="line">unbuffered := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</div><div class="line"></div><div class="line"><span class="comment">// Buffered channel of strings.</span></div><div class="line">buffered := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">10</span>)</div></pre></td></tr></table></figure></p>
<p>　　我们可以看到使用内置的 make 函数来创建 unbuffered 和 buffered channel。make 的第一个参数要求使用 chan 关键词和 channel 允许交换的数据的类型。如果你创建了 buffered channel，那么你要将第二个参数指定未缓冲区的大小。</p>
<p>　　发送一个值或指针给 channel 要求使用 &lt;- 操作符。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Buffered channel of strings.</span></div><div class="line">buffered := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">10</span>)</div><div class="line"></div><div class="line"><span class="comment">// Send a string through the channel.</span></div><div class="line">buffered &lt;- <span class="string">"Gopher"</span></div></pre></td></tr></table></figure></p>
<p>　　上面的代码创建了 string 类型的 buffered channel，缓冲区大小为 10。接着我们发送字符串 Gopher 给 channel，为了另一 goroutine 能从 channel 中接收字符串，我们使用 &lt;- 操作符，但这次是作为一元操作符使用。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Receive a string from the channel.</span></div><div class="line">value := &lt;-buffered</div></pre></td></tr></table></figure></p>
<p>　　当从 channel 中接收值或指针时，&lt;- 操作符绑定在 channel 变量的左侧。</p>
<h3 id="Unbuffered-channels"><a href="#Unbuffered-channels" class="headerlink" title="Unbuffered channels"></a>Unbuffered channels</h3><p>　　在任何值被接收之前，unbuffered channel 都没有容量去容纳任何值。这种类型的 channel 要求在任何发送或接收操作可以完成之前，发送者 goroutine 和接收者 goroutine 都要同时准备好。如果两个 goroutine 没有同时准备好，channel 将使得执行它各自的发送或接收操作的goroutine首先等待。基于 channel 的发送和接收之间的交互都是同步的。</p>
<p>　　在图 6.6 中，可以看到两个 goroutine 通过 unbuffered channel 来共享一个值。在 Step 1 中，两个 goroutine 都接近 channel，但都没有发起一个发送或请求。在 Step 2 中，左边的 goroutine 将它的手伸入 channel 中，这模拟了一个到 channel 的发送。这个时候，这个 goroutine 锁在了 channel 中，等待两个 goroutine 完成交换。在 Step 3 中，右边的 goroutine 伸手进 channel 中，这模拟了 channel 中的一个接收，这个 goroutine 现在所在了 channel 中，等待两个 goroutine 完成交换。Step 4 和 Step 5 执行了交换，最后，在 Step 6 中，两个 goroutine 可以自由地移开它们的双手，这模拟了锁的释放。<br><img src="/images/data-structure/go-6.6.png" alt=""><br>　　<br>　　为了更清晰的阐述，让我们看看两个例子，使用 unbuffered channel 来同步两个 goroutine 之间的数据交换。</p>
<p>　　在网球比赛中，两个选手将球在彼此间来回打动。两个选手总是处于这两种状态中的一种：等待接收球，或将球打给对方。你可以使用两个 goroutine 来模拟这个比赛，使用 unbuffered channel 来模拟球的交换。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// This sample program demonstrates how to use an unbuffered</span></div><div class="line"><span class="comment">// channel to simulate a game of tennis between two goroutines.</span></div><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"math/rand"</span></div><div class="line">	<span class="string">"sync"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// wg is used to wait for the program to finish.</span></div><div class="line"><span class="keyword">var</span> wg sync.WaitGroup</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</div><div class="line">	rand.Seed(time.Now().UnixNano())</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// main is the entry point for all Go programs.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="comment">// Create an unbuffered channel.</span></div><div class="line">	court := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</div><div class="line"></div><div class="line">	<span class="comment">// Add a count of two, one for each goroutine.</span></div><div class="line">	wg.Add(<span class="number">2</span>)</div><div class="line"></div><div class="line">	<span class="comment">// Launch two players.</span></div><div class="line">	<span class="keyword">go</span> player(<span class="string">"Nadal"</span>, court)</div><div class="line">	<span class="keyword">go</span> player(<span class="string">"Djokovic"</span>, court)</div><div class="line"></div><div class="line">	<span class="comment">// Start the set.</span></div><div class="line">	court &lt;- <span class="number">1</span></div><div class="line"></div><div class="line">	<span class="comment">// Wait for the game to finish.</span></div><div class="line">	wg.Wait()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// player simulates a person playing the game of tennis.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">player</span><span class="params">(name <span class="keyword">string</span>, court <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</div><div class="line">	<span class="comment">// Schedule the call to Done to tell main we are done.</span></div><div class="line">	<span class="keyword">defer</span> wg.Done()</div><div class="line"></div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		<span class="comment">// Wait for the ball to be hit back to us.</span></div><div class="line">		ball, ok := &lt;-court</div><div class="line">		<span class="keyword">if</span> !ok &#123;</div><div class="line">			<span class="comment">// If the channel was closed we won.</span></div><div class="line">			fmt.Printf(<span class="string">"Player %s Won\n"</span>, name)</div><div class="line">			<span class="keyword">return</span></div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">// Pick a random number and see if we miss the ball.</span></div><div class="line">		n := rand.Intn(<span class="number">100</span>)</div><div class="line">		<span class="keyword">if</span> n%<span class="number">13</span> == <span class="number">0</span> &#123;</div><div class="line">			fmt.Printf(<span class="string">"Player %s Missed\n"</span>, name)</div><div class="line"></div><div class="line">			<span class="comment">// Close the channel to signal we lost.</span></div><div class="line">			<span class="built_in">close</span>(court)</div><div class="line">			<span class="keyword">return</span></div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">// Display and then increment the hit count by one.</span></div><div class="line">		fmt.Printf(<span class="string">"Player %s Hit %d\n"</span>, name, ball)</div><div class="line">		ball++</div><div class="line"></div><div class="line">		<span class="comment">// Hit the ball back to the opposing player.</span></div><div class="line">		court &lt;- ball</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　当你运行程序，得到下面的输出：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Player Djokovic Hit 1</div><div class="line">Player Nadal Hit 2</div><div class="line">Player Djokovic Hit 3</div><div class="line">Player Nadal Missed</div><div class="line">Player Djokovic Won</div></pre></td></tr></table></figure></p>
<p>　　第 22 行创建 int 类型的 unbuffered channel，用来同步两个 goroutine 之间球的交换。第 28 和 29 行创建了两个用于打比赛的 goroutine，这个时候两个 goroutine 都被锁住，用于等待接收球。第 32 行球发送到 channel 中，这时比赛开始了，直到其中一个 goroutine 关闭比赛才结束。</p>
<p>　　在 palyer 函数中，可以看到一个无穷的 for 循环，在循环中比赛正在进行中。第 45 行，goroutine 等待从 channel 中接收球。这将锁住 goroutine，直到 channel 执行发送操作。一旦 channel 的接收操作返回，第 46 行将检测 ok 是否为 false，若 ok 为 false，说明 channel 已经关闭并且比赛已经结束。第 53 行到 60 行，生成随机数用于判断 goroutine 是否击中了球，若球被击中，那么第 64 行中球的值将加 1，在 67 行中球将被击回对方选手，这时两个 goroutine 将被锁定直到交换完成。最后，第 58 行中，其中一个 goroutine 将错失球，同时 channel 将关闭。这时两个 goroutine 都将返回，defer 语句中的 Done 方法将被调用，程序终止。</p>
<hr>
<p>　　另一个例子使用不同的模式来同步 goroutine，通过 unbuffered channel 来模拟接力赛。在接力赛中，4 个选手轮流绕着跑道跑。第二、第三、第四个选手在接到前一个选手的接力棒之后才能起跑。接力棒的传递是接力赛中重要的一环，并且需要同步。为了这个同步顺利发生，交换接力棒的两个选手需要确切地在同一时间准备好。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// This sample program demonstrates how to use an unbuffered</span></div><div class="line"><span class="comment">// channel to simulate a relay race between four goroutines.</span></div><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"sync"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// wg is used to wait for the program to finish.</span></div><div class="line"><span class="keyword">var</span> wg sync.WaitGroup</div><div class="line"></div><div class="line"><span class="comment">// main is the entry point for all Go programs.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="comment">// Create an unbuffered channel.</span></div><div class="line">	baton := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</div><div class="line"></div><div class="line">	<span class="comment">// Add a count of one for the last runner.</span></div><div class="line">	wg.Add(<span class="number">1</span>)</div><div class="line"></div><div class="line">	<span class="comment">// First runner to his mark.</span></div><div class="line">	<span class="keyword">go</span> Runner(baton)</div><div class="line"></div><div class="line">	<span class="comment">// Start the race.</span></div><div class="line">	baton &lt;- <span class="number">1</span></div><div class="line"></div><div class="line">	<span class="comment">// Wait for the race to finish.</span></div><div class="line">	wg.Wait()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Runner simulates a person running in the relay race.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Runner</span><span class="params">(baton <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> newRunner <span class="keyword">int</span></div><div class="line"></div><div class="line">	<span class="comment">// Wait to receive the baton.</span></div><div class="line">	runner := &lt;-baton</div><div class="line"></div><div class="line">	<span class="comment">// Start running around the track.</span></div><div class="line">	fmt.Printf(<span class="string">"Runner %d Running With Baton\n"</span>, runner)</div><div class="line"></div><div class="line">	<span class="comment">// New runner to the line.</span></div><div class="line">	<span class="keyword">if</span> runner != <span class="number">4</span> &#123;</div><div class="line">		newRunner = runner + <span class="number">1</span></div><div class="line">		fmt.Printf(<span class="string">"Runner %d To The Line\n"</span>, newRunner)</div><div class="line">		<span class="keyword">go</span> Runner(baton)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// Running around the track.</span></div><div class="line">	time.Sleep(<span class="number">100</span> * time.Millisecond)</div><div class="line"></div><div class="line">	<span class="comment">// Is the race over.</span></div><div class="line">	<span class="keyword">if</span> runner == <span class="number">4</span> &#123;</div><div class="line">		fmt.Printf(<span class="string">"Runner %d Finished, Race Over\n"</span>, runner)</div><div class="line">		wg.Done()</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// Exchange the baton for the next runner.</span></div><div class="line">	fmt.Printf(<span class="string">"Runner %d Exchange With Runner %d\n"</span>,</div><div class="line">		runner,</div><div class="line">		newRunner)</div><div class="line"></div><div class="line">	baton &lt;- newRunner</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　运行程序，将得到这样的输出：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Runner 1 Running With Baton</div><div class="line">Runner 2 To The Line</div><div class="line">Runner 1 Exchange With Runner 2</div><div class="line">Runner 2 Running With Baton</div><div class="line">Runner 3 To The Line</div><div class="line">Runner 2 Exchange With Runner 3</div><div class="line">Runner 3 Running With Baton</div><div class="line">Runner 4 To The Line</div><div class="line">Runner 3 Exchange With Runner 4</div><div class="line">Runner 4 Running With Baton</div><div class="line">Runner 4 Finished, Race Over</div></pre></td></tr></table></figure></p>
<p>　　在 main 函数第 17 行中，创建了 int 类型的 unbuffered channel 用来同步接力棒的交换。第 20 行中，我们为 WaitGroup 增加 1，因此 main 函数能够等待最后一位选手跑完。第 23 行创建 goroutine，表示第一位选手到达跑道的位置，第 26 行接力棒交给了这位选手，比赛开始了。最后，第 29 行，main 函数中 WaitGroup 等待最后一位选手跑完。</p>
<p>　　在 Runner goroutine 中，你可以看到接力棒是如何从一位选手传递到另一位选手的。第 37 行中，goroutine 通过 channel 用于等待接收接力棒。一旦接收到接力棒，除非 goroutine 代表第 4 位选手，否则第 46 行中下一位选手将到达他的起跑位置。第 50 行选手将用 100 毫秒来跑完跑道。第 55 行如果第 4 位选手跑完，将调用 Done 方法使 WaitGroup 的值将减 1，这时 goroutine 返回。如果 goroutine 不是第 4 位选手，那么第 64 行接力棒将传递给下一位正在等待的选手，此时两个 goroutine 将被锁住直到完成了接力棒的交换。</p>
<p>　　在上面的两个例子，我们使用 unbuffered channel 来同步 goroutine，用于模拟网球比赛和接力赛。现在你知道了 unbuffered channel 是怎样工作的，接下来将学习 buffered channel 是怎样工作的。</p>
<h3 id="Buffered-channels"><a href="#Buffered-channels" class="headerlink" title="Buffered channels"></a>Buffered channels</h3><p>　　当一个或多个值被接收之前，buffered channel 有容量去容纳它们。这种类型的 channel 不会强迫两个 goroutine 在同一时间准备好去执行发送和接收操作。发送或接收操作会阻塞的条件也是不同的。如果 channel 中没有值可以接收，那么接收操作就会阻塞。当 channel 中没有足够的缓冲区去放置 goroutine 发送的值，这时发送操作才会阻塞。这导致了 unbuffered 和 buffered channel 之间的较大差异：unbuffered channel 保证了当发送和接收操作发生的同一时间，两个 goroutine 将会进行数据交换，而 buffered channel 则不会这样保证。</p>
<p>　　从图 6.7 可以看到，两个 goroutine 各自从 buffered channel 中增加和删除值。Step 1 中，右边的 goroutine 正从 channel 中接收值。在 Step 2 中，右边的 goroutine 能够完成接收操作，左边的 goroutine 发送新的值到 channel 中，这两个操作互相独立。Step 3 中，左边的 goroutine 正发送新的值到 channel 中，右边的 goroutine 正接收不同的值，这两个操作之间并不是同步的，也不会阻塞。最后，在 Step 4 中，所有发送和接收操作都完成了，channel 中拥有几个值，还有空间容纳更多的值。<br><img src="/images/data-structure/go6.7.png" alt=""><br>　　下面的例子使用 buffered channel 来管理一系列 goroutine，用于接收和处理任务。buffered channel 提供了一种间接和直观的方式来实现程序代码。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// This sample program demonstrates how to use a buffered</span></div><div class="line"><span class="comment">// channel to work on multiple tasks with a predefined number</span></div><div class="line"><span class="comment">// of goroutines.</span></div><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"math/rand"</span></div><div class="line">	<span class="string">"sync"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">const</span> (</div><div class="line">	numberGoroutines = <span class="number">4</span>  <span class="comment">// Number of goroutines to use.</span></div><div class="line">	taskLoad         = <span class="number">10</span> <span class="comment">// Amount of work to process.</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// wg is used to wait for the program to finish.</span></div><div class="line"><span class="keyword">var</span> wg sync.WaitGroup</div><div class="line"></div><div class="line"><span class="comment">// init is called to initialize the package by the</span></div><div class="line"><span class="comment">// Go runtime prior to any other code being executed.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="comment">// Seed the random number generator.</span></div><div class="line">	rand.Seed(time.Now().Unix())</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// main is the entry point for all Go programs.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="comment">// Create a buffered channel to manage the task load.</span></div><div class="line">	tasks := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, taskLoad)</div><div class="line"></div><div class="line">	<span class="comment">// Launch goroutines to handle the work.</span></div><div class="line">	wg.Add(numberGoroutines)</div><div class="line">	<span class="keyword">for</span> gr := <span class="number">1</span>; gr &lt;= numberGoroutines; gr++ &#123;</div><div class="line">		<span class="keyword">go</span> worker(tasks, gr)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// Add a bunch of work to get done.</span></div><div class="line">	<span class="keyword">for</span> post := <span class="number">1</span>; post &lt;= taskLoad; post++ &#123;</div><div class="line">		tasks &lt;- fmt.Sprintf(<span class="string">"Task : %d"</span>, post)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// Close the channel so the goroutines will quit</span></div><div class="line">	<span class="comment">// when all the work is done.</span></div><div class="line">	<span class="built_in">close</span>(tasks)</div><div class="line"></div><div class="line">	<span class="comment">// Wait for all the work to get done.</span></div><div class="line">	wg.Wait()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// worker is launched as a goroutine to process work from</span></div><div class="line"><span class="comment">// the buffered channel.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(tasks <span class="keyword">chan</span> <span class="keyword">string</span>, worker <span class="keyword">int</span>)</span></span> &#123;</div><div class="line">	<span class="comment">// Report that we just returned.</span></div><div class="line">	<span class="keyword">defer</span> wg.Done()</div><div class="line"></div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		<span class="comment">// Wait for work to be assigned.</span></div><div class="line">		task, ok := &lt;-tasks</div><div class="line">		<span class="keyword">if</span> !ok &#123;</div><div class="line">			<span class="comment">// This means the channel is empty and closed.</span></div><div class="line">			fmt.Printf(<span class="string">"Worker: %d : Shutting Down\n"</span>, worker)</div><div class="line">			<span class="keyword">return</span></div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">// Display we are starting the work.</span></div><div class="line">		fmt.Printf(<span class="string">"Worker: %d : Started %s\n"</span>, worker, task)</div><div class="line"></div><div class="line">		<span class="comment">// Randomly wait to simulate work time.</span></div><div class="line">		sleep := rand.Int63n(<span class="number">100</span>)</div><div class="line">		time.Sleep(time.Duration(sleep) * time.Millisecond)</div><div class="line"></div><div class="line">		<span class="comment">// Display we finished the work.</span></div><div class="line">		fmt.Printf(<span class="string">"Worker: %d : Completed %s\n"</span>, worker, task)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　运行程序，将得到这样的输出。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">Worker: 1 : Started Task : 1</div><div class="line">Worker: 2 : Started Task : 3</div><div class="line">Worker: 3 : Started Task : 4</div><div class="line">Worker: 4 : Started Task : 2</div><div class="line">Worker: 1 : Completed Task : 1</div><div class="line">Worker: 1 : Started Task : 5</div><div class="line">Worker: 4 : Completed Task : 2</div><div class="line">Worker: 4 : Started Task : 6</div><div class="line">Worker: 1 : Completed Task : 5</div><div class="line">Worker: 1 : Started Task : 7</div><div class="line">Worker: 1 : Completed Task : 7</div><div class="line">Worker: 1 : Started Task : 8</div><div class="line">Worker: 3 : Completed Task : 4</div><div class="line">Worker: 3 : Started Task : 9</div><div class="line">Worker: 2 : Completed Task : 3</div><div class="line">Worker: 2 : Started Task : 10</div><div class="line">Worker: 4 : Completed Task : 6</div><div class="line">Worker: 4 : Shutting Down</div><div class="line">Worker: 2 : Completed Task : 10</div><div class="line">Worker: 2 : Shutting Down</div><div class="line">Worker: 1 : Completed Task : 8</div><div class="line">Worker: 1 : Shutting Down</div><div class="line">Worker: 3 : Completed Task : 9</div><div class="line">Worker: 3 : Shutting Down</div></pre></td></tr></table></figure></p>
<p>　　由于程序的随机性和 Go 的调度器，每次运行时程序的输出都会不同的。但使用 4 个 goroutine 来处理 buffered channel 中的任务则是不变的。你可以从输出中观察到goroutine是怎样接收 channel 分配的任务的。</p>
<p>　　第 31 行创建了 string 类型的 buffered channel，其容量为 10。第 34 行给定 WaitGroup 数值为 4，对应于将要创建的 4 个goroutine。第 35 到 37 行，创建了 4 个goroutine，并且传递 channel 给它们，用于从中接收任务。第 40 行到 42 行，10 个字符串被发送到 channel 中，用于模拟 goroutine 将接收的任务。一旦最后一个字符串发送到 channel 中，第 46 行将会关闭 channel，第 49 行 main 函数将会等待所有的工作完成。</p>
<p>　　第 46 行关闭 channel 是至关重要的，当 channel 关闭时，goroutine仍然能从 channel 中接收，但却不能发送给 channel。能够从已关闭的 channel 中接收是很重要的，因为这样允许在以后的接收中，channel 能够清空它的所有值，所以 channel 中不会丢失任何值。从已经关闭和空的 channel 中执行接收总会立即返回，并提供一个零值，其类型是这个 channel 声明的类型。从 channel 中接收，若你还要可选的标志，那么你能通过这个标志得到 channel 的状态信息。</p>
<p>　　在 worker 函数的 for 循环中，所有接收的任务都将被处理。第 60 行，每个 goroutine 将阻塞，等待从 channel 中接收任务。一旦接收返回，ok 标志将用来检测 channel 是否已经关闭并且是空的。若 ok 为 false，则 goroutine 将终止，这将导致 56 行中的 defer 语句调用 Done 方法。</p>
<p>　　若 ok 标志是 true，那么接收到的值是合法的。第 71 和 72 行模拟了处理任务的场景，一旦任务完成了，第 60 行 goroutine 将再次阻塞，等待从 channel 中接收。一旦 channel 关闭并且是空的，从 channel 中接收将立即返回并且 goroutine 将终止其自身。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/02/05/Python并发/" itemprop="url">
                  【翻译】Effective Python：并发与并行
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-02-05T18:42:51+08:00" content="2016-02-05">
              2016-02-05
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/编程语言/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>　　并发指的是计算机似乎可以同时做很多不同的事情。例如，在拥有单个 CPU 核的计算机，操作系统可以快速地更换运行在这个处理器上的程序。程序之间的穿插执行，造成了一种这些程序同时运行的错觉。</p>
<p>　　并行指的是计算机实际上可以同时做很多不同的事情。拥有多个 CPU 核的计算机可以同时执行多个程序。每个 CPU 核执行一个独立程序的指令，这使得在同一时间段内每个程序都能够持续执行。</p>
<p>　　在单个程序内，并发为程序员提供了一种能够更容易解决特定类型问题的工具。</p>
<p>　　并发和并行的主要差别在于加速。当一个程序以两条不同的执行路径并行地执行，程序做完所有工作所花费的时间将会减半。</p>
<p>　　Python 使我们更容易编写并发的程序。</p>
<h2 id="使用-subprocess-来管理子进程"><a href="#使用-subprocess-来管理子进程" class="headerlink" title="使用 subprocess 来管理子进程"></a>使用 subprocess 来管理子进程</h2><p>　　多年来，Python 有过很多方式来运行子进程，包括 popen, popen2 和 os.exec*。现今的 Python 提供了更好和更方便的工具用来管理子进程，就是使用 subprocess 内置模块。</p>
<p>　　使用 subprocess 来运行子进程是很简单的。这里的 Popen 构造器将启动进程。communicate 方法将读取子进程的输出并等待进程终止。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">proc = subprocess.Popen([<span class="string">'echo'</span>, <span class="string">'Hello from the child'</span>],</div><div class="line">                        stdout=subprocess.PIPE)</div><div class="line">out, err = proc.communicate()</div><div class="line">print(out.decode(<span class="string">'utf-8'</span>))</div><div class="line"></div><div class="line">&gt;&gt;&gt;</div><div class="line">Hello <span class="keyword">from</span> the child</div></pre></td></tr></table></figure></p>
<p>　　子进程将独立于它们的父进程（即 Python 解析器）而运行，当 Python 在执行其它工作时，我们可以定期地轮询这些子进程的状态值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">proc = subprocess.Popen([<span class="string">'sleep'</span>, <span class="string">'0.3'</span>])</div><div class="line"><span class="keyword">while</span> proc.poll() <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">    print(<span class="string">'Working...'</span>)</div><div class="line">    <span class="comment"># Some time-consuming work here</span></div><div class="line">    <span class="comment"># ...</span></div><div class="line"></div><div class="line">print(<span class="string">'Exit status'</span>, proc.poll())</div><div class="line"></div><div class="line">&gt;&gt;&gt;</div><div class="line">Working...</div><div class="line">Working...</div><div class="line">Exit status <span class="number">0</span></div></pre></td></tr></table></figure></p>
<p>　　将子进程从父进程中解耦出来，意味着父进程能自由地以并行的方式执行很多子进程。你可以这样做借由提前将所有的子进程一起启动。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_sleep</span><span class="params">(period)</span>:</span></div><div class="line">    proc = subprocess.Popen([<span class="string">'sleep'</span>, str(period)])</div><div class="line">    <span class="keyword">return</span> proc</div><div class="line"></div><div class="line">start = time()</div><div class="line">procs = []</div><div class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>):</div><div class="line">    proc = run_sleep(<span class="number">0.1</span>)</div><div class="line">    procs.append(proc)</div></pre></td></tr></table></figure></p>
<p>　　之后，你可以通过 communicate 方法来等待它们完成 I/O 操作并终止。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> proc <span class="keyword">in</span> procs:</div><div class="line">    proc.communicate()</div><div class="line">end = time()</div><div class="line"></div><div class="line">print(<span class="string">'Finished in %.3f seconds'</span> % (end - start))</div><div class="line"></div><div class="line">&gt;&gt;&gt;</div><div class="line">Finished <span class="keyword">in</span> <span class="number">0.112</span> seconds</div></pre></td></tr></table></figure></p>
<hr>
<p><strong>注意</strong><br>　　如果这些进程顺序地执行，则总共的延迟会是 1 秒，而不是这里测量的将近 0.1 秒。</p>
<hr>
<p>　　你也可以通过管道将 Python 程序的数据导入子进程，并获得它的输出。这允许你充分利用其它程序去执行并行的工作，例如，假设你想要使用 openssl 命令行工具来加密一些数据。使用命令行参数和 I/O 管道来启动子进程是很简单的。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_openssl</span><span class="params">(data)</span>:</span></div><div class="line">    env = os.environ.copy()</div><div class="line">    env[<span class="string">'password'</span>] = <span class="string">b'\xe24U\n\xd0Ql3S\x11'</span></div><div class="line">    proc = subprocess.Popen([<span class="string">'openssl'</span>, <span class="string">'enc'</span>, <span class="string">'-des3'</span>, <span class="string">'-pass'</span>, <span class="string">'env:password'</span>],</div><div class="line">                            env=env, stdin=subprocess.PIPE, stdout=subprocess.PIPE)</div><div class="line">    proc.stdin.write(data)</div><div class="line">    proc.stdin.flush()  <span class="comment"># Ensure the child gets input</span></div><div class="line">    <span class="keyword">return</span> proc</div></pre></td></tr></table></figure></p>
<p>　　这里，我将随机生成的多个字节导入加密函数，但在实践中则会导入用户输入，文件句柄，网络 socket 等等。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">procs = []</div><div class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">3</span>):</div><div class="line">    data = os.urandom(<span class="number">10</span>)</div><div class="line">    proc = run_openssl(data)</div><div class="line">    procs.append(proc)</div></pre></td></tr></table></figure></p>
<p>　　这些子进程会以并行的方式执行并消耗它们的输入，这里，我等待它们完成并获得它们最后的输出：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> proc <span class="keyword">in</span> procs:</div><div class="line">    out, err = proc.communicate()</div><div class="line">    print(out[<span class="number">-10</span>:])</div><div class="line"></div><div class="line">&gt;&gt;&gt;</div><div class="line"><span class="string">b'o4,G\x91\x95\xfe\xa0\xaa\xb7'</span></div><div class="line"><span class="string">b'\x0b\x01\\\xb1\xb7\xfb\xb2C\xe1b'</span></div><div class="line"><span class="string">b'ds\xc5\xf4;j\x1f\xd0c-'</span></div></pre></td></tr></table></figure></p>
<p>　　你也可以创建类似于 Unix 管道的并行进程链，将一个子进程的输出作为另一子进程的输入，以此类推。这里的函数将启动一个子进程，通过 md5 命令行工具来消耗输入流：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_md5</span><span class="params">(input_stdin)</span>:</span></div><div class="line">    proc = subprocess.Popen([<span class="string">'md5'</span>], </div><div class="line">                            stdin=input_stdin, </div><div class="line">                            stdout=subprocess.PIPE)</div><div class="line">    <span class="keyword">return</span> proc</div></pre></td></tr></table></figure></p>
<hr>
<p><strong>注意</strong><br>　　Python 的 hashlib 内置模块提供了 md5 函数，因此像这样运行子进程并不总是必须的。这里的目的是为了阐释子进程是怎样通过管道来联系输入和输出的。</p>
<hr>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/09/04/hello-world/" itemprop="url">
                  Hello World
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-09-04T20:33:37+08:00" content="2015-09-04">
              2015-09-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Devops/" itemprop="url" rel="index">
                    <span itemprop="name">Devops</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/08/27/数据结构六-二叉树迭代器的设计/" itemprop="url">
                  数据结构（六）-- 设计二叉树迭代器
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-08-27T20:01:10+08:00" content="2015-08-27">
              2015-08-27
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="中序历遍"><a href="#中序历遍" class="headerlink" title="中序历遍"></a>中序历遍</h2><p>　　我们希望以升序的方式历遍二叉树，这种历遍方式就是<strong>中序</strong>历遍，好了，那看看中序历遍的<strong>非递归</strong>实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> UnaryFuncion&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorderTraverse</span><span class="params">( UnaryFuncion visit )</span> <span class="keyword">const</span> </span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">auto</span> curr = root_;        </div><div class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;node_ptr&gt; nodeStack;</div><div class="line">    </div><div class="line">    <span class="keyword">while</span>( curr || !nodeStack.empty() )</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">while</span>( curr )</div><div class="line">        &#123;</div><div class="line">            nodeStack.push( curr );</div><div class="line">            curr = curr-&gt;left;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">auto</span> top = nodeStack.top();</div><div class="line">        nodeStack.pop();</div><div class="line">        visit( top-&gt;value );</div><div class="line">        curr = top-&gt;right;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　可以想到，将中序历遍分成两部分，初始化阶段，以及迭代阶段。先看看<strong>初始化</strong>阶段：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> curr = root;</div><div class="line"><span class="keyword">while</span>( curr )</div><div class="line">&#123;</div><div class="line">    nodeStack.push( curr );</div><div class="line">    curr = curr-&gt;left;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　还有，<strong>迭代</strong>阶段：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> curr = <span class="built_in">stack</span>.top();</div><div class="line"><span class="built_in">stack</span>.pop();</div><div class="line"></div><div class="line">curr = curr-&gt;right;</div><div class="line"><span class="keyword">while</span>( curr )</div><div class="line">&#123;</div><div class="line">    <span class="built_in">stack</span>.push( curr );</div><div class="line">    curr = curr-&gt;left;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="迭代器设计"><a href="#迭代器设计" class="headerlink" title="迭代器设计"></a>迭代器设计</h2><p>　　二叉树的迭代器是 input iterator，可以这样设计：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> const_iterator</div><div class="line">&#123;</div><div class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> BinaryTree;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">using</span> value_type          = T;</div><div class="line">    <span class="keyword">using</span> pointer             = <span class="keyword">const</span> T*;</div><div class="line">    <span class="keyword">using</span> reference           = <span class="keyword">const</span> T&amp;;</div><div class="line">    <span class="keyword">using</span> iterator_category   = <span class="built_in">std</span>::input_iterator_tag;        </div><div class="line"></div><div class="line">    reference <span class="keyword">operator</span>*() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    const_iterator &amp;<span class="keyword">operator</span>++();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> const_iterator <span class="keyword">operator</span>++(<span class="keyword">int</span>);</div><div class="line"></div><div class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==( <span class="keyword">const</span> const_iterator &amp;other ) <span class="keyword">const</span> <span class="keyword">noexcept</span>;</div><div class="line"></div><div class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!=( <span class="keyword">const</span> const_iterator &amp;other ) <span class="keyword">const</span> <span class="keyword">noexcept</span>;</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    const_iterator( <span class="keyword">const</span> BinaryTree *t, <span class="keyword">bool</span> end ) </div><div class="line">        : tree( t ), index( <span class="number">0</span> ) </div><div class="line">    &#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> BinaryTree             *tree;</div><div class="line">    size_type                    index;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;node_ptr&gt;         <span class="built_in">stack</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>　　你可能觉得奇怪，为什么有一个成员变量<code>index</code>，考虑一下，我们要怎样比较两个迭代器相等？<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==( <span class="keyword">const</span> const_iterator &amp;other ) <span class="keyword">const</span> <span class="keyword">noexcept</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> tree == other.tree &amp;&amp; <span class="built_in">stack</span> == other.<span class="built_in">stack</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　比较两个栈是否相等的<strong>开销</strong>比较大，使用<code>index</code>表示元素的编号，我们可以将其改成这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==( <span class="keyword">const</span> const_iterator &amp;other ) <span class="keyword">const</span> <span class="keyword">noexcept</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> tree == other.tree &amp;&amp; index == other.index;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>!=( <span class="keyword">const</span> const_iterator &amp;other ) <span class="keyword">const</span> <span class="keyword">noexcept</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> !( *<span class="keyword">this</span> == other );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　接着看看构造函数，<code>end</code>为<code>true</code>的时候，表示我们创建的是由<code>end()</code>返回的迭代器：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">const_iterator( <span class="keyword">const</span> BinaryTree *t, <span class="keyword">bool</span> end ) </div><div class="line">    : tree( t ), index( <span class="number">0</span> )</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>( end || tree-&gt;empty() )</div><div class="line">    &#123;</div><div class="line">        index = tree-&gt;size();</div><div class="line">    &#125; </div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">auto</span> curr = tree-&gt;root_;</div><div class="line">        <span class="keyword">while</span>( curr )</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">stack</span>.push( curr );</div><div class="line">            curr = curr-&gt;left;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　可以这样创建迭代器：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> &#123; <span class="keyword">this</span>, <span class="literal">false</span> &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> &#123; <span class="keyword">this</span>, <span class="literal">true</span> &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　迭代器的操作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">reference <span class="keyword">operator</span>*() <span class="keyword">const</span></div><div class="line">&#123; </div><div class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>.top()-&gt;value;</div><div class="line">&#125;</div><div class="line"></div><div class="line">pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> &amp;( <span class="keyword">operator</span>*() );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="自增操作"><a href="#自增操作" class="headerlink" title="自增操作"></a>自增操作</h2><p>　　首先，看一下自增操作符：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">const_iterator &amp;<span class="keyword">operator</span>++();                  <span class="comment">// 前缀自增，例如 ++i</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> const_iterator <span class="keyword">operator</span>++(<span class="keyword">int</span>);          <span class="comment">// 后缀自增，例如 i++</span></div></pre></td></tr></table></figure></p>
<p>　　使用后缀自增形式时，编译器会自动传递参数 0 给它：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> iter = tree.begin();</div><div class="line">++i;                        <span class="comment">// call iter.operator++();</span></div><div class="line">i++;                        <span class="comment">// call iter.operator++(0);</span></div></pre></td></tr></table></figure></p>
<p>　　为什么后缀自增需要返回一个 <strong>const</strong> 的 const_iterator 呢？让我们看看基本类型后缀自增：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">i++++;                      <span class="comment">// error: expression is not assignable</span></div></pre></td></tr></table></figure></p>
<p>　　如果后缀自增返回的不是 const 的 const_iterator，那么，下面的操作就是合法的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> iter = tree.begin();</div><div class="line">iter++++;                   <span class="comment">// iter.operator++(0).operator++(0)</span></div></pre></td></tr></table></figure></p>
<p>　　这种连续的后缀自增操作十分混淆，比如说<code>iter++</code>返回一个临时对象，接着对这个临时对象执行后缀自增操作，但实际上<code>iter</code>只增加了一次。所以我们让后缀自增返回一个 const 对象，以<strong>禁止</strong><code>iter++++</code>这种操作。</p>
<hr>
<p>　　来看看自增操作的实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">const_iterator &amp;<span class="keyword">operator</span>++() </div><div class="line">&#123;</div><div class="line">    <span class="keyword">auto</span> curr = <span class="built_in">stack</span>.top();</div><div class="line">    <span class="built_in">stack</span>.pop();</div><div class="line">    </div><div class="line">    curr = curr-&gt;right;</div><div class="line">    <span class="keyword">while</span>( curr )</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">stack</span>.push( curr );</div><div class="line">        curr = curr-&gt;left;</div><div class="line">    &#125;</div><div class="line">    ++index;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> const_iterator <span class="keyword">operator</span>++(<span class="keyword">int</span>) </div><div class="line">&#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> oldIter = *<span class="keyword">this</span>;</div><div class="line">    ++(*<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">return</span> oldIter;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p>　　完整的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> const_iterator</div><div class="line">&#123;</div><div class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> BinaryTree;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">using</span> value_type          = T;</div><div class="line">    <span class="keyword">using</span> pointer             = <span class="keyword">const</span> T*;</div><div class="line">    <span class="keyword">using</span> reference           = <span class="keyword">const</span> T&amp;;</div><div class="line">    <span class="keyword">using</span> iterator_category   = <span class="built_in">std</span>::input_iterator_tag;        </div><div class="line"></div><div class="line">    reference <span class="keyword">operator</span>*() <span class="keyword">const</span></div><div class="line">    &#123; </div><div class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>.top()-&gt;value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> &amp;( <span class="keyword">operator</span>*() );</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    const_iterator &amp;<span class="keyword">operator</span>++() </div><div class="line">    &#123;</div><div class="line">        <span class="keyword">auto</span> curr = <span class="built_in">stack</span>.top();</div><div class="line">        <span class="built_in">stack</span>.pop();</div><div class="line">        </div><div class="line">        curr = curr-&gt;right;</div><div class="line">        <span class="keyword">while</span>( curr )</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">stack</span>.push( curr );</div><div class="line">            curr = curr-&gt;left;</div><div class="line">        &#125;</div><div class="line">        ++index;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> const_iterator <span class="keyword">operator</span>++(<span class="keyword">int</span>) </div><div class="line">    &#123;</div><div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> oldIter = *<span class="keyword">this</span>;</div><div class="line">        ++(*<span class="keyword">this</span>);</div><div class="line">        <span class="keyword">return</span> oldIter;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==( <span class="keyword">const</span> const_iterator &amp;other ) <span class="keyword">const</span> <span class="keyword">noexcept</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> tree == other.tree &amp;&amp; index == other.index;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!=( <span class="keyword">const</span> const_iterator &amp;other ) <span class="keyword">const</span> <span class="keyword">noexcept</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> !( *<span class="keyword">this</span> == other );</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    const_iterator( <span class="keyword">const</span> BinaryTree *t, <span class="keyword">bool</span> end ) </div><div class="line">        : tree( t ), index( <span class="number">0</span> )</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>( end || tree-&gt;empty() )</div><div class="line">        &#123;</div><div class="line">            index = tree-&gt;size();</div><div class="line">        &#125; </div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">auto</span> curr = tree-&gt;root_;</div><div class="line">            <span class="keyword">while</span>( curr )</div><div class="line">            &#123;</div><div class="line">                <span class="built_in">stack</span>.push( curr );</div><div class="line">                curr = curr-&gt;left;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">const</span> BinaryTree             *tree;</div><div class="line">    size_type                    index;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;node_ptr&gt;         <span class="built_in">stack</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.amazon.com/More-Effective-Improve-Programs-Designs/dp/020163371X/ref=sr_1_1?ie=UTF8&amp;qid=1441775627&amp;sr=8-1&amp;keywords=more+effective" target="_blank" rel="external">More Effective C++: 35 New Ways to Improve Your Programs and Designs</a></li>
<li><a href="http://www.amazon.com/Data-Structures-Algorithm-Analysis-C/dp/013284737X/ref=sr_1_4?s=books&amp;ie=UTF8&amp;qid=1422255950&amp;sr=1-4&amp;keywords=data+structure+and+algorithm+in+c%2B%2B" target="_blank" rel="external">Data Structures and Algorithm Analysis in C++ 4th Edition by Mark A. Weiss</a>
　　　　</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/08/26/C-11并发编程-原子变量/" itemprop="url">
                  C++11 并发编程（八）-- 原子
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-08-26T10:07:17+08:00" content="2015-08-26">
              2015-08-26
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/并发编程/" itemprop="url" rel="index">
                    <span itemprop="name">并发编程</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>　　<code>volatile</code>变量与并发编程<strong>没有</strong>任何关系，<code>volatile</code>变量与特殊内存有关。</p>
<p>　　对于以下的代码段：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> x = <span class="number">100</span>;</div><div class="line"><span class="keyword">int</span> y = x;          <span class="comment">// read x</span></div><div class="line">y = x;              <span class="comment">// read x again</span></div><div class="line">x = <span class="number">10</span>;             <span class="comment">// write x</span></div><div class="line">x = <span class="number">20</span>;             <span class="comment">// write x again</span></div></pre></td></tr></table></figure></p>
<p>　　编译器可以将这些操作进行优化：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> x = <span class="number">100</span>;</div><div class="line"><span class="keyword">int</span> y = x;          <span class="comment">// read x</span></div><div class="line">x = <span class="number">20</span>;             <span class="comment">// write x</span></div></pre></td></tr></table></figure></p>
<p>　　但有时我们并不想编译器执行这些操作，例如，要是<code>x</code>代表某种传感器的数值，那么，我们可能不想编译器对此进行优化。<code>volatile</code>变量将告诉编译器，这个变量与特殊内存有关，对这个特殊内存的操作不应该进行优化：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> x = <span class="number">100</span>;</div><div class="line"><span class="keyword">int</span> y = x;          <span class="comment">// read x</span></div><div class="line">y = x;              <span class="comment">// read x again ( can't be optimized away ) </span></div><div class="line">x = <span class="number">10</span>;             <span class="comment">// write x</span></div><div class="line">x = <span class="number">20</span>;             <span class="comment">// write x again ( can't be optimized away )</span></div></pre></td></tr></table></figure></p>
<h2 id="atomic"><a href="#atomic" class="headerlink" title="atomic"></a>atomic</h2><p>　　<code>std::atomic&lt;T&gt;</code>表示原子，当我们创建了<code>std::atomic</code>对象之后，我们对它执行的操作都是原子的，也就是说这些操作对其它线程来说都是原子的。与互斥锁相比，使用<code>std::atomic&lt;T&gt;</code>比较高效，因为这些原子操作是由特殊的机器指令去完成的。　　</p>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; i(<span class="number">0</span>);</div><div class="line">i = <span class="number">100</span>;</div><div class="line">++i;</div><div class="line">--i;</div></pre></td></tr></table></figure>
<p>　　<code>++i</code>或<code>--i</code>操作实际上是 read-modify-write ( RMW ) 操作，但是因为<code>i</code>的类型是<code>std::atomic&lt;int&gt;</code>类型，所以<code>++i</code>和<code>--i</code>操作对于其它线程来说都是原子的。 </p>
<hr>
<p>　　我们知道，在 C++ 中语句可以发生乱序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool</span> isReady = <span class="literal">false</span>;</div><div class="line"><span class="keyword">auto</span> value = compute();</div><div class="line">isReady = <span class="literal">true</span>;             <span class="comment">// 告诉其它线程，value 准备好了</span></div></pre></td></tr></table></figure></p>
<p>　　实际中，编译器可以改变语句的次序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool</span> isReady = <span class="literal">false</span>;</div><div class="line">isReady = <span class="literal">true</span>;</div><div class="line"><span class="keyword">auto</span> value = compute();</div></pre></td></tr></table></figure></p>
<p>　　<code>std::atomic</code>的另一个作用则是保证语句的次序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; isReady( <span class="literal">false</span> );</div><div class="line"><span class="keyword">auto</span> value = compute();</div><div class="line">isReady = <span class="literal">true</span>;</div></pre></td></tr></table></figure></p>
<p>　　也就是说，在<code>isReady = true;</code>之前的所有<strong>内存操作</strong>，不管是不是原子的，对于其它线程来说都是可见的。所以将<code>isReady</code>设置成<code>true</code>之前，<code>value</code>的值就已经准备好了，并且其它线程都知道这件事。</p>
<hr>
<p>　　另一方面，<code>std::atomic&lt;T&gt;</code>的 copy constructor 和 copy assignment operator 都是 delete 的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; x( <span class="number">10</span> );</div><div class="line"><span class="keyword">auto</span> y = x;</div><div class="line"><span class="comment">// error: call to deleted constructor of 'std::atomic&lt;int&gt;'</span></div></pre></td></tr></table></figure></p>
<p>　　理解这一点并不难，因为<code>y</code>的类型也是<code>std::atomic&lt;int&gt;</code>，<code>auto y = x</code>表示读取<code>x</code>并写入<code>y</code>，编译器无法将这条语句实现为原子操作。</p>
<p>　　不过我们可以这样做：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; x( <span class="number">100</span> );</div><div class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; y( x.load() );</div></pre></td></tr></table></figure></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.amazon.com/Effective-Modern-Specific-Ways-Improve/dp/1491903996/ref=sr_1_1?ie=UTF8&amp;qid=1428220334&amp;sr=8-1&amp;keywords=effective+modern+c%2B%2B" target="_blank" rel="external">Effective Modern C++: 42 Specific Ways to Improve Your Use of C++11 and C++14 </a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/08/25/C-11并发编程-基于任务的并发/" itemprop="url">
                  C++11 并发编程（七）-- 基于任务的并发
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-08-25T10:07:17+08:00" content="2015-08-25">
              2015-08-25
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/并发编程/" itemprop="url" rel="index">
                    <span itemprop="name">并发编程</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>　　C++11 提供了两种类型的并发：</p>
<ul>
<li>基于线程的并发。</li>
<li>基于任务的并发。</li>
</ul>
<h2 id="基于线程的并发"><a href="#基于线程的并发" class="headerlink" title="基于线程的并发"></a>基于线程的并发</h2><p>　　<code>std::thread</code>用来表示线程，我们可以这样创建一个线程：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">compute</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">t</span><span class="params">( compute )</span></span>;</div><div class="line">t.join();</div></pre></td></tr></table></figure></p>
<p>　　这种基于线程的并发有几个不好的地方：</p>
<ul>
<li><code>compute()</code>有返回值，但我们并没有直接的方式来得到<code>compute()</code>的返回值。</li>
<li>线程是有限的资源，要是程序试图创建过多的线程，则会抛出<code>std::system_error</code>异常。</li>
</ul>
<p>　　另一方面，<code>std::thread</code>对应操作系统的线程，使用<code>std::thread</code>那就表示我们需要确定什么时候创建线程，以及创建多少线程：</p>
<ul>
<li>要是程序创建的线程远多于硬件线程，线程的调度器会不断地在这些线程之间执行上下文切换 ( Contex Switch )，将给系统增加线程管理的成本。</li>
<li>对于多核 CPU 来说，要是程序创建的线程太多，那么，线程的上下文切换太过频繁将会导致 CPU 的高速缓存不能被很好地利用。</li>
</ul>
<p>　　在程序中，我们很难确定软件线程与硬件线程的最佳比率。即使可以确定，也不见得是可以跨平台的，因为硬件线程的个数与具体的平台有关。</p>
<h2 id="基于任务的并发"><a href="#基于任务的并发" class="headerlink" title="基于任务的并发"></a>基于任务的并发</h2><p>　　我们也可以使用基于任务的并发：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">compute</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="keyword">auto</span> fut = <span class="built_in">std</span>::async( compute );</div></pre></td></tr></table></figure></p>
<p>　　<code>std::async()</code>提供了更高层次的抽象：</p>
<ul>
<li><code>std::async()</code>返回一个<code>std::future</code>，这样就可以获得<code>compute()</code>的返回结果，也可以获得<code>compute()</code>抛出的异常。</li>
<li>我们将线程的管理任务移交给<code>std::async()</code>，这样就不用担心线程<strong>耗尽</strong>的问题了。</li>
<li>默认情况下，<code>std::async()</code><strong>不一定</strong>会创建线程，如果系统的负载过大，或者说我们创建的线程远多于硬件线程，调用<code>std::async()</code>的时候很可能不会创建实际的线程，这时候<code>std::async()</code>可能会将<code>compute()</code>交给那些请求得到<code>compute()</code>返回值的线程去执行（ 那些调用<code>std::future</code>的<code>get()</code>或<code>wait()</code>的线程 ）。</li>
</ul>
<p>　　使用基于任务的并发，我们不用手动去管理线程。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.amazon.com/Effective-Modern-Specific-Ways-Improve/dp/1491903996/ref=sr_1_1?ie=UTF8&amp;qid=1428220334&amp;sr=8-1&amp;keywords=effective+modern+c%2B%2B" target="_blank" rel="external">Effective Modern C++: 42 Specific Ways to Improve Your Use of C++11 and C++14 </a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/08/24/C-11并发编程六/" itemprop="url">
                  C++11 并发编程（六）-- 线程安全的队列
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-08-24T10:07:17+08:00" content="2015-08-24">
              2015-08-24
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/并发编程/" itemprop="url" rel="index">
                    <span itemprop="name">并发编程</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="队列的异常安全"><a href="#队列的异常安全" class="headerlink" title="队列的异常安全"></a>队列的异常安全</h2><p>　　考虑一下 STL 中 queue 的接口：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Container = <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;T&gt;&gt;</div><div class="line"><span class="keyword">class</span> <span class="built_in">queue</span></div><div class="line">&#123;</div><div class="line">    T&amp; front();</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">( <span class="keyword">const</span> T &amp;elem )</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// avoid undefined behaviour before calling front() </span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>　　我们知道，<code>front()</code>用来获得队列头部元素，而<code>pop()</code>则令头部元素出列。但是为什么不设计成这样呢：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Container = <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;T&gt;&gt;</div><div class="line"><span class="keyword">class</span> <span class="built_in">queue</span></div><div class="line">&#123;</div><div class="line">    T pop();</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>　　其实这是为了保证异常安全（Exception Safe），像下面这个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">queue</span>&lt;Widget&gt; q;</div><div class="line"><span class="comment">// ... </span></div><div class="line">Widget value = q.top();</div></pre></td></tr></table></figure></p>
<p>　　设想一下，要是<code>top()</code>将元素出列，并且将这个元素赋值给 value 时，若其拷贝构造函数发生了异常，那么，这个元素就会永远丢失了。</p>
<h2 id="关于实现的细节"><a href="#关于实现的细节" class="headerlink" title="关于实现的细节"></a>关于实现的细节</h2><p>　　我们将设计一个 ThreadQueue，并且具有以下的特点：</p>
<ul>
<li>允许多个读者 ( Reader ) 和多个写者 ( Writer ) 并发地访问队列。</li>
<li>元素出列的操作将会阻塞，直到队列不为空。</li>
<li>元素出列时保证异常安全性。</li>
</ul>
<hr>
<p>　　我们知道，在调用<code>std::queue&lt;T&gt;</code>的<code>front()</code>之前，我们需要保证队列不为空，否则这种行为是未定义的。但是在多线程环境下，我们通常不需要<code>front()</code>操作，而只是调用<code>pop()</code>将元素返回。<code>pop()</code>操作是阻塞的，也就是说，在调用<code>pop()</code>时，要是队列没有元素，那么<code>pop()</code>将会阻塞，以等待新元素入列：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Container = <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;T&gt;&gt;</div><div class="line"><span class="keyword">class</span> ThreadQueue</div><div class="line">&#123;</div><div class="line">    T pop();</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>　　但是，我们知道，<code>pop()</code>并不是异常安全的，那怎么实现异常安全的<code>pop()</code>呢？<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Container = <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;T&gt;&gt;</div><div class="line"><span class="keyword">class</span> ThreadQueue</div><div class="line">&#123;</div><div class="line">    T pop( T &amp;elem );</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>　　在调用<code>pop()</code>之前，我们需要传递一个元素作为参数，以存储将要出列的元素：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ThreadQueue&lt;Widget&gt; q;</div><div class="line"><span class="comment">// ...</span></div><div class="line">Widget widget;</div><div class="line">q.pop( widget );</div></pre></td></tr></table></figure></p>
<h2 id="阻塞队列的实现"><a href="#阻塞队列的实现" class="headerlink" title="阻塞队列的实现"></a>阻塞队列的实现</h2><p>　　阻塞队列实际上就是典型的<strong>生产者－消费者</strong>模型，可想而知，应当使用条件变量：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Container = <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;T&gt;&gt;</div><div class="line"><span class="keyword">class</span> ThreadQueue</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">using</span> container_type           = Container;</div><div class="line">    <span class="keyword">using</span> value_type               = <span class="keyword">typename</span> Container::value_type;</div><div class="line">    <span class="keyword">using</span> reference                = <span class="keyword">typename</span> Container::reference;</div><div class="line">    <span class="keyword">using</span> const_reference          = <span class="keyword">typename</span> Container::const_reference;</div><div class="line">    <span class="keyword">using</span> size_type                = <span class="keyword">typename</span> Container::size_type;</div><div class="line">    <span class="keyword">using</span> mutex_type               = <span class="built_in">std</span>::mutex;</div><div class="line">    <span class="keyword">using</span> condition_variable_type  = <span class="built_in">std</span>::condition_variable;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    Container                queue_;</div><div class="line">    mutex_type               mutex_;</div><div class="line">    condition_variable_type  cond_;</div><div class="line">    </div><div class="line"><span class="keyword">public</span>:</div><div class="line">    ThreadQueue() = <span class="keyword">default</span>;</div><div class="line"></div><div class="line">    ThreadQueue( <span class="keyword">const</span> ThreadQueue &amp; ) = <span class="keyword">delete</span>;</div><div class="line">    ThreadQueue &amp;<span class="keyword">operator</span>=( <span class="keyword">const</span> ThreadQueue &amp; ) = <span class="keyword">delete</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">( reference elem )</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">std</span>::unique_lock&lt;mutex_type&gt; lock( mutex_ );</div><div class="line">        cond_.wait( lock, [<span class="keyword">this</span>]() &#123;  <span class="keyword">return</span> !queue_.empty();  &#125; );</div><div class="line">        elem = <span class="built_in">std</span>::move( queue_.front() );</div><div class="line">        queue_.pop();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">try_pop</span><span class="params">( reference elem )</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">std</span>::unique_lock&lt;mutex_type&gt; lock( mutex_ );</div><div class="line">        <span class="keyword">if</span>( queue_.empty() ) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">        elem = <span class="built_in">std</span>::move( queue_.front() );</div><div class="line">        queue_.pop();</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">std</span>::lock_guard&lt;mutex_type&gt; lock( mutex_ );</div><div class="line">        <span class="keyword">return</span> queue_.empty();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">std</span>::unique_lock&lt;mutex_type&gt; lock( mutex_ );</div><div class="line">        <span class="keyword">return</span> queue_.size();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">( <span class="keyword">const</span> value_type &amp;elem )</span></span></div><div class="line">    &#123;</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">std</span>::lock_guard&lt;mutex_type&gt; lock( mutex_ );</div><div class="line">            queue_.push( elem );</div><div class="line">        &#125;</div><div class="line">        cond_.notify_one();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">( value_type &amp;&amp;elem )</span></span></div><div class="line">    &#123;</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">std</span>::lock_guard&lt;mutex_type&gt; lock( mutex_ );</div><div class="line">            queue_.push( <span class="built_in">std</span>::move( elem ) );</div><div class="line">        &#125;</div><div class="line">        cond_.notify_one();</div><div class="line">    &#125;  </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>　　注意到，要是队列是空的，那么<code>pop()</code>操作将会阻塞，因此，我们提供了一个<code>try_pop()</code>操作，要是队列是空的，调用<code>try_pop()</code>将会立即返回而不会阻塞。</p>
<h2 id="生产者与消费者"><a href="#生产者与消费者" class="headerlink" title="生产者与消费者"></a>生产者与消费者</h2><p>　　我们知道，ThreadQueue 可以用在多个生产者，多个消费者的场景下，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ThreadQueue.hpp"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line">ThreadQueue&lt;<span class="built_in">string</span>&gt; messageQueue;</div><div class="line">mutex print_mtx;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">provider</span><span class="params">( <span class="keyword">int</span> product_num, <span class="keyword">int</span> wait_seconds )</span> </span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; product_num; ++i ) </div><div class="line">    &#123;</div><div class="line">        <span class="function"><span class="built_in">string</span> <span class="title">message</span><span class="params">( <span class="string">"Message-"</span> )</span></span>;</div><div class="line">        message.append( to_string( i ) );</div><div class="line">        messageQueue.push( message );</div><div class="line">        this_thread::sleep_for( chrono::seconds( wait_seconds ) );</div><div class="line">    &#125;</div><div class="line">    lock_guard&lt;mutex&gt; guard( print_mtx );</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"All works done!"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">( <span class="keyword">int</span> consumer_id )</span> </span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">while</span>( <span class="literal">true</span> ) </div><div class="line">    &#123;</div><div class="line">        <span class="built_in">string</span> message;</div><div class="line">        messageQueue.pop( message );</div><div class="line">        &#123;</div><div class="line">            lock_guard&lt;mutex&gt; guard( print_mtx );</div><div class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"consumer-"</span> &lt;&lt; consumer_id &lt;&lt; <span class="string">" receive: "</span> &lt;&lt; message &lt;&lt; <span class="built_in">endl</span>; </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    thread pvi&#123; provider, <span class="number">10</span>, <span class="number">1</span> &#125;;</div><div class="line">    thread csm1&#123; consumer, <span class="number">1</span> &#125;;</div><div class="line">    thread csm2&#123; consumer, <span class="number">2</span> &#125;;</div><div class="line">    pvi.join();</div><div class="line">    csm1.join();</div><div class="line">    csm2.join();</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">$ clang++ -std=c++11 -o main ThreadQueueTest.cpp -pthread</div><div class="line">$ ./main </div><div class="line">consumer-1 receive: Message-0</div><div class="line">consumer-2 receive: Message-1</div><div class="line">consumer-1 receive: Message-2</div><div class="line">consumer-2 receive: Message-3</div><div class="line">consumer-1 receive: Message-4</div><div class="line">consumer-2 receive: Message-5</div><div class="line">consumer-1 receive: Message-6</div><div class="line">consumer-2 receive: Message-7</div><div class="line">consumer-1 receive: Message-8</div><div class="line">consumer-2 receive: Message-9</div><div class="line">All works done!</div><div class="line">**/</div></pre></td></tr></table></figure></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://book.douban.com/subject/4130141/" target="_blank" rel="external">C++ Concurrency in Action</a></li>
<li><a href="https://juanchopanzacpp.wordpress.com/2013/02/26/concurrent-queue-c11/" target="_blank" rel="external">Concurrent queue – C++11</a></li>
<li><a href="http://gnodebian.blogspot.com/2013/07/a-thread-safe-asynchronous-queue-in-c11.html" target="_blank" rel="external">A thread-safe asynchronous queue in C++11</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/08/14/Linux并发编程三/" itemprop="url">
                  Linux 并发编程（三）-- 理解多线程编程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-08-14T20:37:27+08:00" content="2015-08-14">
              2015-08-14
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/并发编程/" itemprop="url" rel="index">
                    <span itemprop="name">并发编程</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="线程的理解"><a href="#线程的理解" class="headerlink" title="线程的理解"></a>线程的理解</h2><p>　　在多处理器的情况下，多线程能充分发挥处理器的性能。我们知道，进程可以拥有多个线程，这样多个线程就可以共享进程全局区域的内存，例如 .bss segment, .data segment 和 heap segment。<br><img src="/images/linux/thread1.png" alt=""></p>
<hr>
<p>　　与多进程相比，多线程带来的好处：</p>
<ul>
<li>由于父进程与子进程并不能共享变量，这样，进程间只能借助于 IPC 的方式进行信息的交换。与此相反，线程间能够共享进程的地址空间，这样的效率提高了，但是当多个线程需要同时访问共享变量时，则需要显式进行同步。</li>
<li>调用<code>fork()</code>之后，内核使用写时拷贝( Copy on Write )的技术生成子进程，尽管如此，内核仍需复制 page table 和 file descriptor table 之类的进程属性，这样将为<code>fork()</code>带来额外的开销。与此不同的是，创建线程时，无须拷贝 page table 或 file descriptor table。</li>
</ul>
<hr>
<p>　　你可能发现了，多个线程同时访问全局的 errno 是否会发生 race condition 呢？实际上，每个线程都拥有它自己的 errno，这样就不会发生 race condition 了。通常 Pthreads 的函数在调用成功时会返回 0，而调用失败则会返回一个正值，我们可以将这个返回值存储在线程的 errno 之中，也可以根据这个返回值作出相应的处理。</p>
<hr>
<h2 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h2><p>　　一种典型的死锁的例子：<br><img src="/images/linux/deadlock.png" alt=""><br>　　线程 A 持有互斥锁 mutex1，线程 B 持有互斥锁 mutex2，这时，线程 A 试图持有 mutex2，而线程 B 试图持有 mutex1。这种情况下就会发生死锁。</p>
<p>　　要是线程需要同步地访问多个共享资源（同时持有多个互斥锁），又不想发生死锁，需要怎样解决？例如，上面的例子中，我们规定线程 A 和线程 B 需要先持有 mutex1 之后才可以继续持有 mutex2，这样就可以避免死锁。</p>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>　　线程安全的函数需要保证能同时被多个线程所调用，要是函数直接修改全局变量，则不是线程安全的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> global_var = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">( <span class="keyword">int</span> value )</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value; ++i ) &#123;</div><div class="line">        global_var = global_var + <span class="number">1</span>;</div><div class="line">    &#125;	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　保证线程能同时调用<code>add()</code>，有两种方式：</p>
<ul>
<li>将<code>add()</code>与互斥锁联系起来，线程在调用<code>add()</code>之前，需要保证先持有这个互斥锁。</li>
<li>将<code>global_val</code>与互斥锁联系起来，线程在访问<code>global_val</code>之前，需要保证先持有这个互斥锁。
　　</li>
</ul>
<hr>
<p>　　我们实现一个不是线程安全的函数<code>my_strerror()</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>              <span class="comment">/* Get '_sys_nerr' and '_sys_errlist' declarations */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span>             <span class="comment">/* Get declaration of strerror() */</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ERROR_LEN 256       <span class="comment">/* Maximum length of string returned by strerror() */</span></span></div><div class="line"><span class="keyword">static</span> <span class="keyword">char</span> buf[MAX_ERROR_LEN]; <span class="comment">/* Statically allocated return buffer */</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">my_strerror</span><span class="params">( <span class="keyword">int</span> err )</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>( err &lt; <span class="number">0</span> || err &gt;= <span class="number">_</span>sys_nerr || <span class="number">_</span>sys_errlist[err] == <span class="literal">NULL</span> ) &#123;</div><div class="line">        <span class="built_in">snprintf</span>(buf, MAX_ERROR_LEN, <span class="string">"Unknown error %d"</span>, err );</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">	<span class="built_in">strncpy</span>( buf, <span class="number">_</span>sys_errlist[err], MAX_ERROR_LEN - <span class="number">1</span> );</div><div class="line">	buf[MAX_ERROR_LEN - <span class="number">1</span>] = <span class="string">'\0'</span>;    <span class="comment">/* Ensure null termination */</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> buf;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　注意，要是存在多个线程同时调用<code>my_strerror()</code>，那么数组<code>buf</code>的内容将被破坏。</p>
<hr>
<p>　　我们知道，要是函数需要修改全局数据同时没有提供同步访问的措施，那么这个函数就不是线程安全的。设想以一下，要是每个线程都拥有一份属于它自己的全局数据的副本，那么，即使函数没有提供同步访问的措施，这个函数仍是线程安全的。<br>　　在定义全局变量时加上<code>__thread</code>关键词，则可以为每个调用这个函数的线程提供局部存储，也就是说，会自动为每个线程创建全局变量的副本：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="number">__</span>thread <span class="keyword">char</span> buf[MAX_ERROR_LEN];</div></pre></td></tr></table></figure></p>
<p>　　这样，<code>my_strerror()</code>就是线程安全的了。我们编写一个测试例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>              </span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">my_strerror</span><span class="params">( <span class="keyword">int</span> )</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">threadFunc</span><span class="params">( <span class="keyword">void</span> *arg )</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">printf</span>( <span class="string">"Other thread about to call strerror()\n"</span> );</div><div class="line">    <span class="keyword">char</span> *str = my_strerror( EPERM );</div><div class="line">    <span class="built_in">printf</span>( <span class="string">"Other thread: str (%p) = %s\n"</span>, str, str );</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">linux_error</span><span class="params">( <span class="keyword">int</span> error, <span class="keyword">char</span> *msg )</span> </span>&#123;</div><div class="line">    <span class="built_in">fprintf</span>( <span class="built_in">stderr</span>, <span class="string">"%s: %s\n"</span>, msg,  strerror( error ) );</div><div class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">char</span> *str = my_strerror( EINVAL );</div><div class="line">    <span class="built_in">printf</span>( <span class="string">"Main thread has called strerror()\n"</span> );</div><div class="line"></div><div class="line">    <span class="keyword">pthread_t</span> pid;</div><div class="line">    <span class="keyword">int</span> error = pthread_create( &amp;pid, <span class="literal">NULL</span>, threadFunc, <span class="literal">NULL</span> );</div><div class="line">    <span class="keyword">if</span>( error != <span class="number">0</span> ) &#123;</div><div class="line">	linux_error( error, <span class="string">"pthread_create"</span> );</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    error = pthread_join( pid, <span class="literal">NULL</span> );</div><div class="line">    <span class="keyword">if</span>( error != <span class="number">0</span> ) &#123;</div><div class="line">	linux_error( error, <span class="string">"pthread_join"</span> );</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">printf</span>( <span class="string">"Main thread:  str (%p) = %s\n"</span>, str, str );</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line">Main thread has called strerror()</div><div class="line">Other thread about to call strerror()</div><div class="line">Other thread: str (0xb7532a40) = Operation not permitted</div><div class="line">Main thread:  str (0xb7533700) = Invalid argument</div><div class="line">*/</div></pre></td></tr></table></figure></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.amazon.com/Linux-Programming-Interface-System-Handbook/dp/1593272200/ref=sr_1_1?ie=UTF8&amp;qid=1432537210&amp;sr=8-1&amp;keywords=linux+programming" target="_blank" rel="external">The Linux Programming Interface: A Linux and UNIX System Programming Handbook</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/08/10/Linux进程编程-进程间通信/" itemprop="url">
                  Linux 进程编程（四）-- 进程间通信
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-08-10T06:30:20+08:00" content="2015-08-10">
              2015-08-10
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/系统编程/" itemprop="url" rel="index">
                    <span itemprop="name">系统编程</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>　　管道是进程间通信的一种机制，有这些特点：</p>
<ul>
<li>管道是半双工的，数据只能在一个方向上流动。</li>
<li>通常来说，进程创建管道，接着<code>fork()</code>子进程，这时父进程和子进程就能通过管道进行通信。</li>
</ul>
<p>　　<code>pipe()</code>用来创建管道：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">( <span class="keyword">int</span> fd[<span class="number">2</span>] )</span></span>;</div><div class="line"><span class="comment">// return 0 if OK, -1 on error</span></div></pre></td></tr></table></figure></p>
<p>　　我们通过<code>fd[0]</code>读数据，通过<code>fd[1]</code>写数据，也就是说我们通过<code>fd[1]</code>写入的数据能被<code>fd[0]</code>读出来。</p>
<p>　　通过管道，我们可以在父进程和子进程之间通信：</p>
<ul>
<li>数据流从父进程到子进程：父进程关闭<code>fd[0]</code>，子进程关闭<code>fd[1]</code>。</li>
<li>数据流从子进程到父进程：父进程关闭<code>fd[1]</code>，子进程关闭<code>fd[0]</code>。</li>
</ul>
<p>　　当管道的一端被关闭时：</p>
<ul>
<li>若管道的写入端被关闭，另一端读完管道中剩余数据之后，调用<code>read()</code>会返回 0，表示 EOF。</li>
<li>若管道的读取端被关闭，另一端写入数据，则会产生 SIGPIPE 信号，默认情况下，SIGPIPE 会杀死进程。然而，进程可以选择忽略这个信号，或者捕获这个信号并调用相应的信号处理器，这时，<code>write()</code>会返回 -1，并将<code>errno</code>设置成 EPIPE。</li>
</ul>
<p>　　父进程传送数据给子进程：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 1024</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> fd[<span class="number">2</span>];</div><div class="line">    <span class="keyword">if</span>( pipe( fd ) &lt; <span class="number">0</span> ) &#123;</div><div class="line">	perror( <span class="string">"pipe"</span> );</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">pid_t</span> pid;</div><div class="line">    <span class="keyword">char</span>  line[MAXLINE];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span>( ( pid = fork() ) &lt; <span class="number">0</span> ) &#123;</div><div class="line">	perror( <span class="string">"fork"</span> );</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>( pid == <span class="number">0</span> ) &#123;</div><div class="line">	close( fd[<span class="number">1</span>] );                            <span class="comment">// 子进程关闭管道的写入端</span></div><div class="line">	<span class="keyword">int</span> n = read( fd[<span class="number">0</span>], line, MAXLINE );</div><div class="line">	write( STDOUT_FILENO, line, n );</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">	close( fd[<span class="number">0</span>] );                            <span class="comment">// 父进程关闭管道的读取端</span></div><div class="line">	write( fd[<span class="number">1</span>], <span class="string">"hello world\n"</span>, <span class="number">12</span> );</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h2><p>　　</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="John Doe" />
          <p class="site-author-name" itemprop="name">John Doe</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">97</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">14</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">17</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  

  

  

  

</body>
</html>
