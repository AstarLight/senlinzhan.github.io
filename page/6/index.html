<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/6/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/page/6/"/>

  <title> Hexo </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Hexo</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/04/24/智能指針2/" itemprop="url">
                  高效 C++11 -- 智能指针（二）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-04-24T14:38:00+08:00" content="2015-04-24">
              2015-04-24
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/编程语言/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="共享所有权"><a href="#共享所有权" class="headerlink" title="共享所有权"></a>共享所有权</h2><p>　　有时，我们需要将同一对象添加到不同的容器里面，但当对象所占内存较大时，将带来较大的内存开销。因此，我们可以考虑将指向这个对象的指针存储到不同的容器里面，对于动态分配的内存来说，我们需要确保：</p>
<ul>
<li>当这些指针销毁的时候不会多次<code>delete</code>同一个对象。</li>
<li>当最后一个指针销毁的时候，动态分配的内存会被释放。</li>
</ul>
<p>　　可以使用<code>shared_ptr</code>来解决这个问题。多个<code>shared_ptr</code>可以指向同一动态内存，当最后一个<code>shared_ptr</code>被销毁时，动态内存也会被释放。<br>　　与<code>unique_ptr</code>一样，<code>shared_ptr</code>拥有<code>explicit</code>的构造函数，允许通过原生指针来构造<code>shared_ptr</code>，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; ptr1&#123; <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"hello"</span>) &#125;;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; ptr2 = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"hello"</span>);       <span class="comment">// ERROR: the constructor is explicit</span></div></pre></td></tr></table></figure></p>
<p>　　与<code>unique_ptr</code>不同，为了实现共享所有权，<code>shared_ptr</code>支持 copy constructor 和 copy assigment operator，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> SharedPtr&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_use_count</span><span class="params">( <span class="keyword">const</span> SharedPtr &amp;p1, <span class="keyword">const</span> SharedPtr &amp;p2 )</span> </span>&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ref count: ptr1 = "</span> &lt;&lt; p1.use_count() </div><div class="line">              &lt;&lt; <span class="string">", ptr2 = "</span> &lt;&lt; p2.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; ptr1&#123; <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"hello"</span>) &#125;;</div><div class="line"><span class="keyword">auto</span> ptr2 = ptr1;                   <span class="comment">// copy constructor</span></div><div class="line">print_use_count( ptr1, ptr2 );      </div><div class="line">ptr1 = <span class="literal">nullptr</span>;                     <span class="comment">// set ptr1 to nullptr</span></div><div class="line">print_use_count( ptr1, ptr2 );</div><div class="line">ptr2.reset();                       <span class="comment">// set ptr2 to nullptr</span></div><div class="line">print_use_count( ptr1, ptr2 );</div><div class="line"><span class="comment">/**</span></div><div class="line">ref count: ptr1 = 2, ptr2 = 2</div><div class="line">ref count: ptr1 = 0, ptr2 = 1</div><div class="line">ref count: ptr1 = 0, ptr2 = 0</div><div class="line">**/</div></pre></td></tr></table></figure></p>
<p>　　注意，当我们将<code>shared_ptr</code>设置成<code>nullptr</code>之后，就无法通过它来访问 control block 了，这时引用计数就是 0，但这并不表示实际对象的引用计数是 0，因为可能还存在其它的<code>shared_ptr</code>指向这个对象。<br>　　尽管可以将<code>nullptr</code>赋值给<code>shared_ptr</code>，但原生指针则无法直接赋值给<code>shared_ptr</code>，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; ptr1&#123; <span class="keyword">new</span> <span class="keyword">int</span>&#123;<span class="number">10</span>&#125; &#125;;     <span class="comment">// OK </span></div><div class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; ptr2 = <span class="literal">nullptr</span>;          <span class="comment">// OK</span></div><div class="line">ptr2 = <span class="keyword">new</span> <span class="keyword">int</span>&#123; <span class="number">10</span> &#125;;                         <span class="comment">// ERROR</span></div><div class="line">ptr2.reset( <span class="keyword">new</span> <span class="keyword">int</span>&#123;<span class="number">10</span>&#125; );                    <span class="comment">// OK</span></div></pre></td></tr></table></figure></p>
<h2 id="销毁操作"><a href="#销毁操作" class="headerlink" title="销毁操作"></a>销毁操作</h2><p>　　与<code>unique_ptr</code>不同，为<code>shared_ptr</code>指定 deleter 的时候不需要在模板类型中指定 deleter 的类型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; ptr( <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"hello"</span>), </div><div class="line">                        []( <span class="built_in">string</span> *p ) &#123;</div><div class="line">                            <span class="built_in">cout</span> &lt;&lt; <span class="string">"delete hello"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">                        &#125;);</div><div class="line">ptr = <span class="literal">nullptr</span>;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Before the end of main()"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"><span class="comment">/**</span></div><div class="line">delete hello</div><div class="line">Before the end of main()</div><div class="line">**/</div></pre></td></tr></table></figure></p>
<p>　　同样，与<code>unique_ptr</code>不同，标准库并不提供<code>shared_ptr&lt;T[]&gt;</code>，因此，使用<code>shared_ptr</code>处理数组时需要显示指定 deleter，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; ptr1( <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">10</span>], </div><div class="line">                         []( <span class="built_in">string</span> *p ) &#123;</div><div class="line">                             <span class="keyword">delete</span>[] p;</div><div class="line">                         &#125;);</div><div class="line"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; ptr2( <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">10</span>],</div><div class="line">                         <span class="built_in">std</span>::default_delete&lt;<span class="built_in">string</span>[]&gt;() );</div></pre></td></tr></table></figure></p>
<p>　　但是，需要注意，由于不存在<code>shared_ptr&lt;T[]&gt;</code>，我们无法使用<code>[]</code>来访问数组中的元素，另一方面，由于<code>shared_ptr</code>不支持指针运算，因此，实际上无法访问到数组中的元素。所以说，使用<code>shared_ptr</code>来指向数组是毫无意义的，要是想要让数组被多个<code>shared_ptr</code>之间共享，可以考虑使用<code>shared_ptr&lt;vector&gt;</code>或<code>shared_ptr&lt;array&gt;</code>，而不是使用<code>shared_ptr</code>来指向原生数组。<br>　　deleter 并不只是与释放内存相关，也可以是释放资源，当 deleter 拥有内部状态时，可以使用函数对象作为 deleter：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">class</span> FileDeteter</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    FileDeteter( <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;f ) </div><div class="line">        : filename( f ) &#123; &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">( <span class="built_in">std</span>::ofstream *fp )</span> </span>&#123;</div><div class="line">        fp-&gt;close();</div><div class="line">        <span class="built_in">std</span>::remove( filename.c_str() );</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> filename;</div><div class="line">&#125;; </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::ofstream&gt; fp( <span class="keyword">new</span> <span class="built_in">std</span>::ofstream( <span class="string">"tmpfile.txt"</span> ),</div><div class="line">                                       FileDeteter( <span class="string">"tmpfile.txt"</span> ) );</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>　　<code>shared_ptr</code>内部包含两个指针，一个指向对象，另一个指向一个 control block，这个 control block 里面包含一个引用计数和一个 deleter，默认使用<code>delete</code>来销毁对象。<br><img src="/images/data-structure/sh2.png" alt=""><br>　　另外，通过<code>shared_ptr</code>来构造<code>weak_ptr</code>时，<code>weak_ptr</code>会和<code>shared_ptr</code>指向同一 control block，注意到， control block 中包含一个 weak count，用来记录有多少<code>weak_ptr</code>指向当前对象。<br>　　很明显，当多个<code>shared_ptr</code>指向同一对象时，它们都需要访问到这个 control block，引用计数表示当前对象被多少个<code>shared_ptr</code>所持有。<br>　　创建 control block 的几种情况：</p>
<ul>
<li><code>std::make_shared</code>函数总是会创建 control block。</li>
<li>通过<code>unique_ptr</code>来构造<code>shared_ptr</code>也会创建 control block。</li>
<li>通过原生指针来构造<code>shared_ptr</code>也会创建 control block。</li>
</ul>
<p>　　导致引用计数的增加或减少的操作有：</p>
<ul>
<li><code>shared_ptr</code>的 constructor 和 copy constructor 会使引用计数增加。</li>
<li><code>shared_ptr</code>的 destructor 会使引用计数减少。</li>
<li><code>shared_ptr</code>的 move constructor 并不会修改对象的引用计数。</li>
<li><code>shared_ptr</code>的 copy assignment operator 则既会增加，也会减少引用计数。例如，假定<code>sp1</code>和<code>sp2</code>指向不同的对象，<code>sp1 = sp2</code>则使得<code>sp1</code>原本指向的对象其引用计数减少，而<code>sp2</code>指向的对象其引用计数则会增加。</li>
<li><code>shared_ptr</code>的 move assignment operator 则会减少引用计数。例如，假定<code>sp1</code>和<code>sp2</code>指向不同的对象，<code>sp1 = std::move(sp2)</code>则使得<code>sp1</code>原本指向的对象其引用计数减少，而<code>sp2</code>指向的对象其引用计数则会不变。</li>
</ul>
<p>　　这样，当引用计数变成 0 的时候，也就是说没有<code>shared_ptr</code>持有这个对象，那么对象就会被销毁。</p>
<p>　　由于这个 control block 需要在多个<code>shared_ptr</code>之间共享，那么，<code>shared_ptr</code>需要在 heap 上为这个 control block 分配内存。另一方面，为了保证可以在多线程环境中使用<code>shared_ptr</code>（ 在多线程之间共享 ），<code>shared_ptr</code>的引用计数的 increment 和 decrement 操作都是原子的。相较于非原子操作，原子操作较慢。</p>
<p>　　正如我们所看到的，control block 使得<code>shared_ptr</code>的所占的内存较大，要是对象不需要在多个<code>shared_ptr</code>之间共享，可以考虑使用<code>unique_ptr</code>而不是<code>shared_ptr</code>。另一方面，由于<code>unique_ptr</code>并不拥有 control block，因此可以通过<code>unique_ptr</code>来构造<code>shared_ptr</code>，但相反，由于<code>shared_ptr</code>拥有 control block，因此，我们无法通过<code>shared_ptr</code>来构造<code>unique_ptr</code>。</p>
<h2 id="高效使用"><a href="#高效使用" class="headerlink" title="高效使用"></a>高效使用</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; ptr&#123; <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"hello"</span>) &#125;;</div></pre></td></tr></table></figure>
<p>　　使用这种方式创建<code>shared_ptr</code>时，需要执行两次<code>new</code>操作，一次在 heap 上为<code>string(&quot;hello&quot;)</code>分配内存，另一次在 heap 上为 control block 分配内存。<br>　　考虑另一种创建<code>shared_ptr</code>的方式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> ptr = <span class="built_in">std</span>::make_shared&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(<span class="string">"hello"</span>);</div></pre></td></tr></table></figure></p>
<p>　　使用<code>make_shared</code>来创建<code>shared_ptr</code>更加高效，这时由于<code>make_shared</code>在创建<code>shared_ptr</code>时，仅使用一次<code>new</code>操作，即在 heap 上分配一块连续的内存用来容纳<code>string(&quot;hello&quot;)</code>和 control block。同样，当<code>shared_ptr</code>的析构函数调用时，也只需要执行一次<code>delete</code>操作。<br>　　当然，使用<code>make_shared</code>的劣势就是我们无法为<code>shared_ptr</code>指定 deleter，也就是说，只能使用<code>delete</code>来销毁<code>shared_ptr</code>指向的对象。<br>　　当然，使用<code>make_shared</code>来分配一块较大内存，包含 control block 和动态分配的对象的内存，在某些情况下，这样做也有一些弊端。我们知道，control block 里面除了包含<code>shared_ptr</code>的引用计数之外，还有<code>weak_ptr</code>的引用计数。很明显，<code>weak_ptr</code>也会访问到 control block，因此，<code>make_shared</code>所分配的整块内存的生命周期，将取决于<code>shared_ptr</code>和<code>weak_ptr</code>二者生命周期最长的那个。也就是说，即使对象的引用计数是 0（ 不存在<code>shared_ptr</code> ），这时要是还存在<code>weak_ptr</code>，那么，这整一块内存也不会被释放。也就是说，只有当所有的<code>shared_ptr</code>和<code>weak_ptr</code>都被析构的时候，这整一块内存（ 包含 control block 和对象的内存 ）才会被回收。设想一下，要是对象所占的内存非常大，并且<code>shared_ptr</code>或<code>weak_ptr</code>持续的存在的时间比较长，那么，在这段时间内，即使没有<code>shared_ptr</code>指向这个对象，这个对象的内存也不会被释放。在这种情况下，应该通过<code>shared_ptr</code>的构造函数来构造<code>shared_ptr</code>，而不是通过<code>make_shared</code>来构造<code>shared_ptr</code>。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.amazon.com/Effective-Modern-Specific-Ways-Improve/dp/1491903996/ref=sr_1_1?ie=UTF8&amp;qid=1428220334&amp;sr=8-1&amp;keywords=effective+modern+c%2B%2B" target="_blank" rel="external">Effective Modern C++: 42 Specific Ways to Improve Your Use of C++11 and C++14 </a></li>
<li><a href="http://stackoverflow.com/questions/9302296/is-make-shared-really-more-efficient-than-new" target="_blank" rel="external">StackOverflow: Is make_shared really more efficient than new?</a></li>
<li><a href="www.amazon.com/gp/product/0321563840/ref=s9_simh_gw_p14_d0_i4?pf_rd_m=ATVPDKIKX0DER&amp;pf_rd_s=desktop-1&amp;pf_rd_r=1K1091VGJG234NP5NA8T&amp;pf_rd_t=36701&amp;pf_rd_p=1970559082&amp;pf_rd_i=desktop">The C++ Programming Language 4th Edition</a></li>
<li><a href="http://book.douban.com/subject/10440485/" target="_blank" rel="external">The C++ Standard Library Second Edition</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/04/20/智能指针1/" itemprop="url">
                  高效 C++11 -- 智能指针（一）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-04-20T19:22:08+08:00" content="2015-04-20">
              2015-04-20
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/编程语言/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="为何智能指针"><a href="#为何智能指针" class="headerlink" title="为何智能指针"></a>为何智能指针</h2><p>　　使用原生指针来指向动态分配的内存，可能会导致内存或资源泄露的问题：</p>
<ul>
<li>忘记手动释放内存或资源。</li>
<li>出现异常时，内存或资源未被释放。</li>
</ul>
<p>　　例如，当程序抛出异常时或者函数过早退出都可能导致内存未被释放：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">( <span class="keyword">bool</span> flag )</span> </span>&#123;</div><div class="line">    <span class="keyword">auto</span> ptr = <span class="keyword">new</span> Widget;</div><div class="line"></div><div class="line">    <span class="comment">// do something might throw exception</span></div><div class="line">    <span class="comment">// and can't delete ptr</span></div><div class="line"></div><div class="line">    <span class="comment">// might return early and forget delete ptr</span></div><div class="line">    <span class="keyword">if</span>( flag ) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// do something else</span></div><div class="line">    <span class="keyword">delete</span> ptr;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　为了防止出现内存泄露，在不使用智能指针的情况下，我们可以这样做：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">( <span class="keyword">bool</span> flag )</span> </span>&#123;</div><div class="line">    <span class="keyword">auto</span> ptr = <span class="keyword">new</span> Widget;</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// do something might throw exception</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span>(...) &#123;</div><div class="line">        <span class="keyword">delete</span> ptr;</div><div class="line">        <span class="keyword">throw</span>;         <span class="comment">// rethrow the exception</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>( flag ) &#123;</div><div class="line">        <span class="keyword">delete</span> ptr;    <span class="comment">// remember to free memory</span></div><div class="line">        <span class="keyword">return</span>;    </div><div class="line">    &#125;</div><div class="line">    <span class="comment">// do something else</span></div><div class="line">    <span class="keyword">delete</span> ptr;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　可以看到，这样做使得程序的代码变得冗长，使用智能指针就能轻易解决这个问题：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">( <span class="keyword">bool</span> flag )</span> </span>&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Widget&gt; ptr&#123; <span class="keyword">new</span> Widget &#125;;</div><div class="line"></div><div class="line">    <span class="comment">// do something might throw exception</span></div><div class="line">    <span class="comment">// OK: the resource will be free automatically</span></div><div class="line"></div><div class="line">    <span class="comment">// might return early</span></div><div class="line">    <span class="comment">// OK: the resource will be free automatically </span></div><div class="line">    <span class="comment">// because ptr will be destroy automatically cause memory also be free</span></div><div class="line">    <span class="keyword">if</span>( flag ) &#123;</div><div class="line">        <span class="keyword">return</span>;    </div><div class="line">    &#125;</div><div class="line">    <span class="comment">// do something else</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="独享所有权"><a href="#独享所有权" class="headerlink" title="独享所有权"></a>独享所有权</h2><p>　　C++11 引入<code>unique_ptr</code>用来替代原有的<code>auto_ptr</code>。<code>unique_ptr</code>拥有其指向的对象，因此，当<code>unique_ptr</code>销毁时，其指向的对象也会被销毁。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">namespace</span> <span class="built_in">std</span> &#123;</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> D = default_delete&lt;T&gt;&gt;</div><div class="line">    <span class="keyword">class</span> <span class="built_in">unique_ptr</span></div><div class="line">    &#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="comment">// ...</span></div><div class="line">        <span class="keyword">explicit</span> <span class="built_in">unique_ptr</span>( pointer p ) <span class="keyword">noexcept</span>;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　<code>unique_ptr</code>包含一个<code>explicit</code>的构造函数，允许直接通过原生指针来构造<code>unique_ptr</code>，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> Widget&#123;  &#125;;</div><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="built_in">unique_ptr</span>&lt;Widget&gt; up1&#123; <span class="keyword">new</span> Widget &#125;;</div><div class="line"><span class="built_in">unique_ptr</span>&lt;Widget&gt; up2 = <span class="keyword">new</span> Widget;   <span class="comment">// ERROR</span></div></pre></td></tr></table></figure></p>
<p>　　<code>unique_ptr</code>提供了<code>operator*()</code>和<code>operator-&gt;()</code>成员函数，我们可以像使用原生指针一样，使用<code>*</code>对<code>unique_ptr</code>进行解引用，使用<code>-&gt;</code>来访问<code>unique_ptr</code>所指向对象的成员：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">namespace</span> <span class="built_in">std</span> &#123;</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> D = default_delete&lt;T&gt;&gt;</div><div class="line">    <span class="keyword">class</span> <span class="built_in">unique_ptr</span></div><div class="line">    &#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="comment">// ...</span></div><div class="line">        T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span>;</div><div class="line">        T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> <span class="keyword">noexcept</span>;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　<code>unique_ptr</code>独享对象的所有权，也就是说，在同一时刻，只有一个<code>unique_ptr</code>指向这个对象，因此，为了防止多个<code>unique_ptr</code>指向同一对象，标准库没有为<code>unique_ptr</code>提供 copy constructor 和 assigment operator。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">namespace</span> <span class="built_in">std</span> &#123;</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> D = default_delete&lt;T&gt;&gt;</div><div class="line">    <span class="keyword">class</span> <span class="built_in">unique_ptr</span></div><div class="line">    &#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="comment">// ...</span></div><div class="line">        <span class="built_in">unique_ptr</span>( <span class="keyword">const</span> <span class="built_in">unique_ptr</span>&amp; ) = <span class="keyword">delete</span>;</div><div class="line">        <span class="built_in">unique_ptr</span>&amp; <span class="keyword">operator</span>=( <span class="keyword">const</span> <span class="built_in">unique_ptr</span>&amp; ) = <span class="keyword">delete</span>;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p>　　另一方面，我们需要指针来支持多态行为，这时，<code>unique_ptr</code>就是一个很好的选择：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Shape &#123; <span class="comment">/* ... */</span> &#125;;</div><div class="line"><span class="keyword">class</span> Rectangle : <span class="keyword">public</span> Shape &#123; <span class="comment">/* ... */</span> &#125;;</div><div class="line"><span class="keyword">class</span> Circle : <span class="keyword">public</span> Shape &#123; <span class="comment">/* ... */</span> &#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Ts&gt;</div><div class="line"><span class="built_in">unique_ptr</span>&lt;Shape&gt; createShape( Ts&amp;&amp;... params ) &#123;</div><div class="line">    <span class="built_in">unique_ptr</span>&lt;Shape&gt; p;</div><div class="line">    <span class="keyword">if</span>( <span class="comment">/* create Rectangle */</span> ) &#123;</div><div class="line">        p.reset( <span class="keyword">new</span> Rectangle( <span class="built_in">std</span>::forward&lt;Ts&gt;(params)... ) );</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( <span class="comment">/* create Circle */</span> ) &#123;</div><div class="line">        p.reset( <span class="keyword">new</span> Circle( <span class="built_in">std</span>::forward&lt;Ts&gt;(params)... ) );</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> p;</div><div class="line">&#125;</div><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="built_in">unique_ptr</span>&lt;Shape&gt; shapePtr = createShape( <span class="comment">/* args */</span> );</div></pre></td></tr></table></figure></p>
<p>　　<code>createShape()</code>是一个工厂函数，返回一个<code>unique_ptr&lt;Shape&gt;</code>，这个<code>unique_ptr&lt;Shape&gt;</code>除了可以指向<code>Shape</code>对象之外，也可以指向<code>Rectangle</code>对象或者是<code>Circle</code>对象。<br>　　另外，可以高效地将<code>unique_ptr</code>转换成为<code>shared_ptr</code>，这样做更加灵活：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">share_ptr&lt;Shape&gt; p = createShape( <span class="comment">/* args */</span> );</div></pre></td></tr></table></figure></p>
<h2 id="移交所有权"><a href="#移交所有权" class="headerlink" title="移交所有权"></a>移交所有权</h2><p>　　我们知道，<code>unique_ptr</code>没有 copy constructor 和 assigment operator 函数，因此，我们可以使用 C++11 的<code>std::move()</code>将<code>unique_ptr</code>拥有的对象移交给另一个<code>unique_ptr</code>。</p>
<p>　　有时我们需要将<code>unique_ptr</code>传递给函数，那么有两种方式：</p>
<ul>
<li>使用<code>std::move()</code>，按值传递参数。</li>
<li>按<code>const</code>引用来传递参数。 </li>
</ul>
<p>　　注意，要是按值传递<code>unique_ptr</code>，那么需要将<code>unique_ptr</code>作为函数的返回值返回，否则，当这个函数退出时，函数作用域内的<code>unique_ptr</code>将被销毁，其拥有的对象也将一并被销毁。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Value</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;  ++value_;  &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">int</span> value_ = <span class="number">0</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">unique_ptr</span>&lt;Value&gt; passByValue( <span class="built_in">unique_ptr</span>&lt;Value&gt; p ) &#123;</div><div class="line">    p-&gt;increment();</div><div class="line">    <span class="keyword">return</span> p;                <span class="comment">// <span class="doctag">NOTE:</span> remember to return unique_ptr</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">passByConRef</span><span class="params">( <span class="keyword">const</span> <span class="built_in">unique_ptr</span>&lt;Value&gt; &amp;p )</span> </span>&#123;</div><div class="line">    p-&gt;increment();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">unique_ptr</span>&lt;Value&gt; p&#123; <span class="keyword">new</span> Value &#125;;</div><div class="line">    p = passByValue( <span class="built_in">std</span>::move( p ) );</div><div class="line">    passByConRef( p );</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="防止误用"><a href="#防止误用" class="headerlink" title="防止误用"></a>防止误用</h2><p>　　可以通过原生指针来初始化<code>unique_ptr</code>，但我们知道，<code>unique_ptr</code>独占地拥有其指向的对象，因此，我们不能通过同一原生指针来初始化多个<code>unique_ptr</code>，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> Widget&#123;  &#125;;</div><div class="line"><span class="comment">// ...</span></div><div class="line">Widget *ptr = <span class="keyword">new</span> Widget;</div><div class="line"><span class="built_in">unique_ptr</span>&lt;Widget&gt; p1&#123; ptr &#125;;</div><div class="line"><span class="built_in">unique_ptr</span>&lt;Widget&gt; p2&#123; ptr &#125;;     <span class="comment">// ERROR: multiple ownership</span></div></pre></td></tr></table></figure></p>
<p>　　可以知道，当<code>p1</code>和<code>p2</code>各自被销毁的时候，它们指向的<code>Widget</code>将被<code>delete</code>两次。要是同一对象需要在多个指针间共享，应当使用<code>shared_ptr</code>来共享所有权。</p>
<h2 id="指向数组"><a href="#指向数组" class="headerlink" title="指向数组"></a>指向数组</h2><p>　　<code>unique_ptr</code>也可以指向数组，实际上<code>unique_ptr</code>为数组提供了模板偏特化：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">namespace</span> <span class="built_in">std</span> &#123;</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> D&gt;</div><div class="line">    <span class="keyword">class</span> <span class="built_in">unique_ptr</span>&lt;T[], D&gt;</div><div class="line">    &#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="comment">// ...</span></div><div class="line">        T&amp; <span class="keyword">operator</span>[]( <span class="keyword">size_t</span> i ) <span class="keyword">const</span>;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　可以看到，当<code>unique_ptr</code>指向数组时，可以使用<code>[]</code>接受一个下标，来引用数组的元素。另外，<code>unique_ptr</code>也为数组指定了析构行为，<code>default_delete</code>的偏特化版本：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">namespace</span> <span class="built_in">std</span> &#123;</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line">    <span class="keyword">class</span> default_delete&lt;T[]&gt;</div><div class="line">    &#123;</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="comment">// ...</span></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">( T *p )</span> <span class="keyword">const</span></span>;    <span class="comment">// call delete[] p</span></div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　这样，可以像使用一般数组，当<code>unique_ptr</code>被销毁时，数组的内存也将被释放：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>[]&gt; ptr&#123; <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">100</span>] &#125;;</div><div class="line">ptr[<span class="number">0</span>] = <span class="string">"hello"</span>;</div><div class="line">ptr[<span class="number">1</span>] = <span class="string">"world"</span>;</div></pre></td></tr></table></figure></p>
<h2 id="销毁操作"><a href="#销毁操作" class="headerlink" title="销毁操作"></a>销毁操作</h2><p>　　默认情况下，<code>unique_ptr</code>使用<code>delete</code>来销毁其拥有的对象，但也接受自定义的 deleter 来指定销毁操作，这个 deleter 可以是普通函数、lambda 表达式或函数对象，这时，<code>unique_ptr</code>需要接受另一个模板参数，用来指定 deleter 的类型，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> Widget&#123;  &#125;;</div><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="keyword">auto</span> deleter = []( Widget *p ) &#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"delete Widget!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">delete</span> p;</div><div class="line">&#125;;</div><div class="line"><span class="built_in">unique_ptr</span>&lt;Widget, <span class="keyword">decltype</span>(deleter)&gt; ptr&#123; <span class="keyword">new</span> Widget, deleter &#125;;</div></pre></td></tr></table></figure></p>
<p>　　当然，我们可以使用 C++11 的 alias template 特性，这样就可以避免指定 deleter 的类型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> Widget&#123;  &#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">using</span> uniquePtr = <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;T, <span class="keyword">void</span>(*)(T*)&gt;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    uniquePtr&lt;Widget&gt; ptr( <span class="keyword">new</span> Widget, </div><div class="line">                           []( Widget *p ) &#123;</div><div class="line">                               <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"delete Widget!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">                               <span class="keyword">delete</span> p;</div><div class="line">                           &#125;);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="高效使用"><a href="#高效使用" class="headerlink" title="高效使用"></a>高效使用</h2><p>　　在继承层次的数据结构中，例如二叉树，父节点掌管子节点的生命周期，当父节点销毁时，子节点也会相应地被销毁，那么，这时<code>unique_ptr</code>就是很好的选择。另一方面，由于子节点的生命周期短于父节点，因此，可以用原生指针指向父节点，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">struct</span> TreeNode &#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;TreeNode&gt; left;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;TreeNode&gt; right;</div><div class="line">    TreeNode *parent;</div><div class="line">    T value;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<hr>
<p>　　默认情况下，<code>unique_ptr</code>的 size 和原生指针的一样，但有几种情况需要考虑：</p>
<ul>
<li>若 deleter 是函数，则<code>unique_ptr</code>需要存储额外的函数指针，使得<code>unique_ptr</code>的 size 变为原来的两倍。</li>
<li>若 deleter 是无状态的函数对象或是无捕获的 lambda 表达式，则<code>unique_ptr</code>的 size 保持不变。</li>
<li>若 deleter 是有状态的函数对象或是有捕获的 lambda 表达式，则<code>unique_ptr</code>的 size 将增加。</li>
</ul>
<p>　　C++14 提供了<code>std::make_unique&lt;T&gt;()</code>函数用来直接创建<code>unique_ptr</code>，在 C++11 中，我们可以自己实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts&gt;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;T&gt; make_unique( Ts&amp;&amp;... params ) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;T&gt;( <span class="keyword">new</span> T( <span class="built_in">std</span>::forward&lt;Ts&gt;(params)... ) );</div><div class="line">&#125;</div><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="keyword">auto</span> ptr = make_unique&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(<span class="string">"senlin"</span>);</div></pre></td></tr></table></figure></p>
<p>　　注意，在<code>make_unique</code>中初始化对象时候使用的是括号，考虑以下例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> up = make_unique&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;( <span class="number">10</span>, <span class="number">100</span> );</div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"size: "</span> &lt;&lt; up-&gt;size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line"><span class="comment">// size: 10</span></div></pre></td></tr></table></figure></p>
<p>　　另一方面，如果需要使用<code>std::initializer_list</code>来初始化对象时，可以这样做：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> initList = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</div><div class="line"><span class="keyword">auto</span> up = make_unique&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;( initList );</div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"size: "</span> &lt;&lt; up-&gt;size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line"><span class="comment">// size: 5</span></div></pre></td></tr></table></figure></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="www.amazon.com/gp/product/0321563840/ref=s9_simh_gw_p14_d0_i4?pf_rd_m=ATVPDKIKX0DER&amp;pf_rd_s=desktop-1&amp;pf_rd_r=1K1091VGJG234NP5NA8T&amp;pf_rd_t=36701&amp;pf_rd_p=1970559082&amp;pf_rd_i=desktop">The C++ Programming Language 4th Edition</a></li>
<li><a href="http://book.douban.com/subject/10440485/" target="_blank" rel="external">The C++ Standard Library Second Edition</a></li>
<li><a href="http://www.amazon.com/Effective-Modern-Specific-Ways-Improve/dp/1491903996/ref=sr_1_1?ie=UTF8&amp;qid=1428220334&amp;sr=8-1&amp;keywords=effective+modern+c%2B%2B" target="_blank" rel="external">Effective Modern C++: 42 Specific Ways to Improve Your Use of C++11 and C++14 </a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/04/19/迭代器traits/" itemprop="url">
                  高效 C++11 -- 迭代器 traits
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-04-19T19:23:26+08:00" content="2015-04-19">
              2015-04-19
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/编程语言/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="迭代器-categories"><a href="#迭代器-categories" class="headerlink" title="迭代器 categories"></a>迭代器 categories</h2><p>　　STL 中有 5 种迭代器 categories，标准库中存在结构体用于标志它们：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">namespace</span> <span class="built_in">std</span> &#123;</div><div class="line">    <span class="keyword">struct</span> output_iterator_tag &#123; </div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">struct</span> input_iterator_tag &#123; </div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">struct</span> forward_iterator_tag : <span class="keyword">public</span> input_iterator_tag &#123;    </div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">struct</span> bidirectional_iterator_tag : <span class="keyword">public</span> forward_iterator_tag &#123;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">struct</span> random_access_iterator_tag : <span class="keyword">public</span> bidirectional_iterator_tag &#123;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　可以看到，这些结构体都是空的，那么，我们可以将其看成是迭代器 categories 的标签。</p>
<h2 id="迭代器-traits"><a href="#迭代器-traits" class="headerlink" title="迭代器 traits"></a>迭代器 traits</h2><p>　　好了，更多时候，在编写泛型算法时，我们需要判断算法接受的迭代器属于哪个 categories，为此，标准库定义了<code>iterator_traits</code>结构：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">namespace</span> <span class="built_in">std</span> &#123;</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line">    <span class="keyword">struct</span> iterator_traits &#123;</div><div class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> T::iterator_category   iterator_category;</div><div class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> T::value_type          value_type;</div><div class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> T::difference_type     difference_type;</div><div class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> T::pointer             pointer;</div><div class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> T::reference           reference;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　泛型参数<code>T</code>表示迭代器的类型，可以看到，我们可以使用<code>iterator_traits</code>获得迭代器的相关信息，同样，当我们编写自定义的迭代器时，迭代器中也应当包含这些信息。</p>
<p>　　有时泛型算法接受的参数不是迭代器，而是指针，为此，标准库的<code>iterator_traits</code>提供了指针的偏特化版本，可以看到，指针的迭代器 categories 是<code>random_access_iterator_tag</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">namespace</span> <span class="built_in">std</span> &#123;</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line">    <span class="keyword">struct</span> iterator_traits&lt;T*&gt; &#123;</div><div class="line">        <span class="keyword">typedef</span> random_access_iterator_tag   iterator_category;</div><div class="line">        <span class="keyword">typedef</span> T                            value_type;</div><div class="line">        <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span>                    difference_type;</div><div class="line">        <span class="keyword">typedef</span> T*                           pointer;</div><div class="line">        <span class="keyword">typedef</span> T&amp;                           reference;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　对于泛型算法来说，确定迭代器所属的 categories 是很有用的，算法将根据不同的迭代器 categories 而执行不同的操作，从而提高算法的执行性能。</p>
<p>　　例如，标准库的函数<code>std::distance()</code>用来计算两个迭代器的距离，要是迭代器属于随机迭代器，那么，直接对迭代器执行相减操作就行，这时，<code>std::distance()</code>是常量时间操作。对于其它 categories 的迭代器，<code>std::distance()</code>则是线性时间操作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> InputIterator&gt;</div><div class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;InputIterator&gt;::<span class="function">difference_type</span></div><div class="line"><span class="title">distance</span><span class="params">( InputIterator first, InputIterator last )</span> </div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> distance( first, last, </div><div class="line">                     <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;InputIterator&gt;::iterator_category() );</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> RandomAccessIterator&gt;</div><div class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;RandomAccessIterator&gt;::<span class="function">difference_type</span></div><div class="line"><span class="title">distance</span><span class="params">( RandomAccessIterator first, RandomAccessIterator last,</span></div><div class="line">          <span class="built_in">std</span>::random_access_iterator_tag )</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> last - first;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> InputIterator&gt;</div><div class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;InputIterator&gt;::<span class="function">difference_type</span></div><div class="line"><span class="title">distance</span><span class="params">( InputIterator first,  InputIterator last, <span class="built_in">std</span>::input_iterator_tag )</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::difference_type n = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>( first != last )</div><div class="line">    &#123;</div><div class="line">        ++first;</div><div class="line">        ++n;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> n;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　同样，标准库的<code>std::advance()</code>也是使用<code>iterator_traits</code>的一个例子，这个函数用来将迭代器移动指定的距离，对于随机迭代器和双向迭代器来说，移动的距离可以是正的，也可以是负的，但对于输入迭代器来说，要是移动的距离为负的，那么这种行为是未定义的，这里我们抛出异常来替代这种未定义的行为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> Distance&gt;</div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span></span></div><div class="line"><span class="title">advance</span><span class="params">( InputIterator&amp; i, Distance n )</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::difference_type d = n;</div><div class="line">    advance( i, d, </div><div class="line">             <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;InputIterator&gt;::iterator_category() );</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> Distance&gt;</div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span></span></div><div class="line"><span class="title">advance</span><span class="params">( InputIterator &amp;i, Distance n, <span class="built_in">std</span>::input_iterator_tag )</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>( n &lt; <span class="number">0</span> ) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::out_of_range( <span class="string">"Negative distance"</span> );</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span>( n-- ) &#123;</div><div class="line">        ++i;        </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> BidirectionalIterator, <span class="keyword">typename</span> Distance&gt;</div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span></span></div><div class="line"><span class="title">advance</span><span class="params">( BidirectionalIterator &amp;i, Distance n, <span class="built_in">std</span>::bidirectional_iterator_tag )</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>( n &gt; <span class="number">0</span> ) &#123;</div><div class="line">        <span class="keyword">while</span>( n-- ) &#123;</div><div class="line">            ++i;</div><div class="line">        &#125;</div><div class="line">    &#125; </div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">while</span>( n++ ) &#123;</div><div class="line">            --i;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> RandomAccessIterator, <span class="keyword">typename</span> Distance&gt;</div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span></span></div><div class="line"><span class="title">advance</span><span class="params">( RandomAccessIterator&amp; i, Distance n, <span class="built_in">std</span>::random_access_iterator_tag )</span></div><div class="line">&#123;</div><div class="line">    i += n;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://book.douban.com/subject/10440485/" target="_blank" rel="external">The C++ Standard Library Second Edition</a></li>
<li><a href="http://www.amazon.com/Effective-Specific-Improve-Programs-Designs/dp/0321334876/ref=sr_1_2?ie=UTF8&amp;qid=1429491019&amp;sr=8-2&amp;keywords=effective+c%2B%2B" target="_blank" rel="external">Effective C++: Item 47 – Use Traits classes for information about types</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/03/31/高效C-11-vector/" itemprop="url">
                  高效 C++11 -- vector 实用技巧
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-03-31T14:38:06+08:00" content="2015-03-31">
              2015-03-31
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/编程语言/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="预留足够空间"><a href="#预留足够空间" class="headerlink" title="预留足够空间"></a>预留足够空间</h2><p>　　<code>vector</code>实际上是能够动态增长的数组，因此，当<code>vector</code>的容量 ( capacity ) 不足以容纳新元素的时候，<code>vecvtor</code>就会重新分配较大的内存，将原来的元素移动到新的内存，并回收旧的内存。这个过程会导致几个问题：</p>
<ul>
<li>每一次重新分配内存的操作都会带来不小的开销。</li>
<li>由于旧的内存被系统回收，因此，原来所有指向<code>vector</code>元素的指针、迭代器和引用都会失效。</li>
</ul>
<p>　　每一次使用<code>push_back()</code>往<code>vector</code>中增加元素，可能会导致<code>vector</code>重新分配内存：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</div><div class="line"><span class="keyword">auto</span> cap = vec.capacity();</div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"origin capacity: "</span> &lt;&lt; cap &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line"></div><div class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i ) &#123;</div><div class="line">    vec.push_back( i );</div><div class="line">    <span class="keyword">if</span>( cap != vec.capacity() ) &#123;</div><div class="line">        cap = vec.capacity();</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"new capacity: "</span> &lt;&lt; cap &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　从例子可以看到，往<code>vector</code>中增加 1000 个元素，会导致<code>vector</code>多次重新分配内存：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">origin capacity: 0</div><div class="line">new capacity: 1</div><div class="line">new capacity: 2</div><div class="line">new capacity: 4</div><div class="line">new capacity: 8</div><div class="line">new capacity: 16</div><div class="line">new capacity: 32</div><div class="line">new capacity: 64</div><div class="line">new capacity: 128</div><div class="line">new capacity: 256</div><div class="line">new capacity: 512</div><div class="line">new capacity: 1024</div></pre></td></tr></table></figure></p>
<p>　　为了减少重新分配内存带来的开销，实际上我们可以使用<code>v.reserve(n)</code>来预留足够的内存( <code>v</code>是<code>vector</code>的对象 )：</p>
<ul>
<li>要是<code>n</code>小于或等于<code>v.capacity()</code>，那么，<code>v</code>将忽略这个操作。</li>
<li>要是<code>n</code>大于<code>v.capacity()</code>，那么，<code>v</code>将会重新分配内存，并保证新的容量至少为<code>n</code>。</li>
</ul>
<p>　　很明显，要是一开始<code>vector</code>就预留足够的空间，那么，即使不断地使用<code>push_back()</code>增加元素，<code>vector</code>也不会重新分配内存，并且所有指向元素的指针、迭代器和引用仍然有效。需要明白一点，<code>reserve()</code>使用空间置配器 ( allocator ) 来分配内存，也就是，没有存储元素的那部分内存是原生 ( raw ) 内存。</p>
<p>　　根据这个方法，可以减少重新分配内存的次数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> NUM = <span class="number">1000</span>;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</div><div class="line">vec.reserve( NUM );</div><div class="line"></div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"origin capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM; ++i ) &#123;</div><div class="line">    vec.push_back( i );</div><div class="line">&#125;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"new capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div></pre></td></tr></table></figure></p>
<h2 id="修正过剩容量"><a href="#修正过剩容量" class="headerlink" title="修正过剩容量"></a>修正过剩容量</h2><p>　　我们知道，<code>vector</code>在增加元素时，当元素的个数超过容器的容量时，容器的容量会以倍数的形式增加。但是，当<code>vector</code>在删除元素的时候，容量并不会随着减小：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> NUM = <span class="number">1000</span>;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec( NUM, <span class="number">0</span> );</div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"origin capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line"></div><div class="line">vec.erase( vec.begin() + <span class="number">2</span>, vec.end() );   <span class="comment">// remove elements from vec[2] to the end </span></div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity after erase: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div></pre></td></tr></table></figure></p>
<p>　　可以看到，即使<code>vector</code>只剩下 2 个元素，但它的容量仍然是 1000：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">origin capacity: 1000</div><div class="line">capacity after erase: 1000</div></pre></td></tr></table></figure></p>
<p>　　要是这时候我们不需要再往<code>vector</code>中增加元素，那么，可以使<code>vector</code>的容量较少到合适的程度，这样可以避免占用过多的内存。</p>
<p>　　我们可以使用交换技巧 ( swap trick ) 来解决这个问题：</p>
<pre><code>std::vector&lt;int&gt;( vec ).swap( vec );
</code></pre><p>　　假定<code>vec</code>原来的容量是 1000，而实际只有 2 个元素，那么：</p>
<ul>
<li>我们可以使用<code>vec</code>来初始化一个临时的对象，很明显，这个临时的对象的容量应该是 2 ( 或者某个接近 2 的数值 )。</li>
<li>接着，我们将这个临时的对象与<code>vec</code>进行交换，那么，交换过后<code>vec</code>的容量也是 2 ，在这条语句执行结束之后，临时的对象被销毁，这样<code>vec</code>的容量就与元素个数相等了。</li>
</ul>
<p>　　我们知道，迭代器、指针或引用都是指向元素的，而不是直接指向容器，同时，对于<code>vector</code>来说，<code>swap()</code>操作是非常高效的，这也就是说执行<code>swap()</code>操作时，元素并不会被交换，所有元素在内存中的位置仍保持不变，只是元素所属的容器不同了。所以，我们可以说，在执行<code>swap()</code>操作之后，迭代器、指针和引用仍然指向原来指向的元素。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> NUM = <span class="number">1000</span>;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec( NUM, <span class="number">0</span> );</div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"origin capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">vec.erase( vec.begin() + <span class="number">2</span>, vec.end() );</div><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;( vec ).swap( vec );</div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity after erase: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line"><span class="comment">/***</span></div><div class="line">origin capacity: 1000</div><div class="line">capacity after erase: 2</div><div class="line">***/</div></pre></td></tr></table></figure></p>
<p>　　实际上，使用交换技巧，<code>vector</code>的容量将会收缩到尽量接近元素的个数，但这并不表示二者确切相等，这还得取决于平台的实现。<br>　　在 C++11 中，<code>vector</code>增加了新的成员<code>shrink_to_fit()</code>来使容器的容量收缩到尽量等于元素的个数，同样，这并不保证容器的容量与元素个数确切相等。我们可以使用<code>shrink_to_fit()</code>来实现与交换技巧相同的功能：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> NUM = <span class="number">1000</span>;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec( NUM, <span class="number">0</span> );</div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"origin capacity: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">vec.erase( vec.begin() + <span class="number">2</span>, vec.end() );</div><div class="line">vec.shrink_to_fit();</div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"capacity after erase: "</span> &lt;&lt; vec.capacity() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line"><span class="comment">/***</span></div><div class="line">origin capacity: 1000</div><div class="line">capacity after erase: 2</div><div class="line">***/</div></pre></td></tr></table></figure></p>
<h2 id="修改元素个数"><a href="#修改元素个数" class="headerlink" title="修改元素个数"></a>修改元素个数</h2><p>　　我们知道，<code>reserve()</code>和<code>shrink_to_fit()</code>成员函数会改变容器的容量，但不会改变容器的元素个数，也不会修改元素。但与此不同，使用<code>resize()</code>则会修改容器的元素个数：</p>
<pre><code>void resize (size_type n);
void resize (size_type n, const value_type&amp; val);
</code></pre><p>　　<code>resize()</code>的行为将取决于参数<code>n</code>，例如：</p>
<ul>
<li>当<code>n</code>小于元素的个数，那么，容器的前<code>n</code>个元素将得到保留，其它的元素将被移除并销毁。</li>
<li>当<code>n</code>大于元素的个数，那么，新的元素将被默认初始化，并添加到容器末尾。要是指定了<code>val</code>，那么，将使用<code>val</code>来初始化新的元素。</li>
<li>要是<code>n</code>大于容器的容量，那么，在添加新元素之前，容器的内存将进行重新分配。</li>
</ul>
<p>　　也就是说，使用<code>resize(n)</code>会强制将容器的元素个数改成<code>n</code>，在必要时会初始化元素或重新分配内存。</p>
<h2 id="直接构造元素"><a href="#直接构造元素" class="headerlink" title="直接构造元素"></a>直接构造元素</h2><p>　　我们定义一个<code>Person</code>类：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Person</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Person( <span class="built_in">string</span> name ) : name_( name ) &#123; &#125;</div><div class="line"></div><div class="line">    Person( <span class="keyword">const</span> Person &amp;other ) </div><div class="line">        : name_( other.name_ ) &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"in copy constructor with name is "</span> &lt;&lt; name_ &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="built_in">string</span> name_;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>　　在 C++98 里面，使用<code>push_back()</code>往容器中添加元素，实际上容器中包含的都是元素的拷贝，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Person&gt; vec;</div><div class="line">vec.reserve( <span class="number">10</span> );</div><div class="line">vec.push_back( Person( <span class="string">"senlin"</span> ) );</div><div class="line"><span class="function">Person <span class="title">p</span><span class="params">( <span class="string">"zongming"</span> )</span></span>;</div><div class="line">vec.push_back( p );</div><div class="line"><span class="comment">/**</span></div><div class="line">in copy constructor with name is senlin</div><div class="line">in copy constructor with name is zongming</div><div class="line">**/</div></pre></td></tr></table></figure></p>
<p>　　但在 C++11 里面，由于 move 语义的作用，将临时对象添加到容器里面，发生的是移动操作而不是拷贝操作。我们知道，相对于拷贝操作来说，移动操作实际上是比较高效的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Person</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Person( Person &amp;&amp;other )</div><div class="line">        : name_( <span class="built_in">std</span>::move( other.name_ ) ) &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"in move constructor with name is "</span> &lt;&lt; name_ &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line"><span class="comment">// ... </span></div><div class="line">&#125;;</div><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Person&gt; vec;</div><div class="line">vec.reserve( <span class="number">10</span> );</div><div class="line">vec.push_back( Person( <span class="string">"senlin"</span> ) );</div><div class="line"><span class="function">Person <span class="title">p</span><span class="params">( <span class="string">"zongming"</span> )</span></span>;</div><div class="line">vec.push_back( p );</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">in move constructor with name is senlin</div><div class="line">in copy constructor with name is zongming</div><div class="line">**/</div></pre></td></tr></table></figure></p>
<p>　　实际上，C++11 提供了可变模板 ( variadic template )，例如，<code>vector</code>提供了<code>emplace_back()</code>成员函数：</p>
<pre><code>template &lt;class... Args&gt;
void emplace_back (Args&amp;&amp;... args);
</code></pre><p>　　我们可以借助<code>vector</code>的成员函数<code>emplace_back()</code>来直接构造元素，这样就可以避免移动操作或是拷贝操作带来的开销，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vec.emplace_back( <span class="string">"senlin"</span> );</div></pre></td></tr></table></figure></p>
<p>　　可以看到，我们可以将<code>Person</code>构造函数的参数直接传递给<code>emplace_back()</code>，这样，元素就能够直接在容器中构造，避免了不必要的移动操作或是拷贝操作。</p>
<h2 id="初始化的语法"><a href="#初始化的语法" class="headerlink" title="初始化的语法"></a>初始化的语法</h2><p>　　在 C++98中，创建<code>vector</code>时，可以指定元素的数目和这些元素的初始值：</p>
<pre><code>vector( size_type n, const value_type&amp; val, const allocator_type &amp;alloc = allocator_type() );
</code></pre><p>　　例如，我们可以创建一个包含 100 个元素的<code>vector</code>，指定 0 为初始值：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec( <span class="number">100</span>, <span class="number">0</span> );</div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line"><span class="comment">// 100</span></div></pre></td></tr></table></figure></p>
<p>　　在 C++11中，<code>vector</code>增加了新的构造函数，允许使用初始化列表来初始化<code>vector</code>：</p>
<pre><code>vector( initializer_list&lt;value_type&gt; il, const allocator_type &amp;alloc = allocator_type() );
</code></pre><p>　　在创建<code>vector</code>时，可以使用多个元素来初始化<code>vector</code>，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec&#123; <span class="number">100</span>, <span class="number">0</span> &#125;;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; vec.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line"><span class="comment">// 2</span></div></pre></td></tr></table></figure></p>
<p>　　注意，在使用数值类型进行初始化时，这两种初始化方式极易混淆，在使用初始化列表时，需要使用<code>{}</code>来初始化。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.amazon.com/Effective-STL-Specific-Standard-Template/dp/0201749629" target="_blank" rel="external">Effective STL: 50 Specific Ways to Improve Your Use of the Standard Template Library</a></li>
<li><a href="http://stackoverflow.com/questions/6525650/benefits-of-using-reserve-in-a-vector-c" target="_blank" rel="external">StackOverflow: Benefits of using reserve() in a vector - C++</a></li>
<li><a href="http://www.cplusplus.com/reference/vector/vector/resize/" target="_blank" rel="external">public member function std::vector::resize</a></li>
<li><a href="http://stackoverflow.com/questions/4303513/push-back-vs-emplace-back" target="_blank" rel="external">StackOverflow: push_back vs emplace_back</a></li>
<li><a href="http://www.amazon.com/Effective-Modern-Specific-Ways-Improve/dp/1491903996/ref=sr_1_1?ie=UTF8&amp;qid=1428220334&amp;sr=8-1&amp;keywords=effective+modern+c%2B%2B" target="_blank" rel="external">Effective Modern C++: 42 Specific Ways to Improve Your Use of C++11 and C++14 </a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/03/25/Emacs使用技巧/" itemprop="url">
                  Emacs 实用技巧
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-03-25T20:31:51+08:00" content="2015-03-25">
              2015-03-25
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/软件技巧/" itemprop="url" rel="index">
                    <span itemprop="name">软件技巧</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="快捷方式"><a href="#快捷方式" class="headerlink" title="快捷方式"></a>快捷方式</h2><ul>
<li><code>C-x b</code>：切换 buffer</li>
<li><code>C-x right</code>：向右历遍 buffer</li>
<li><code>C-x left</code>：向左历遍 buffer</li>
<li><code>C-x k</code>：关闭 buffer</li>
<li><code>C-x 0</code>：关闭当前活动窗口</li>
<li><code>C-x o</code>：将下一个窗口设为活动窗口</li>
<li><code>C-x C-w</code>：将文件另存为</li>
<li><code>C-_</code>：撤消</li>
<li><code>M-%</code>：询问替代，<code>space</code>为替代，<code>n</code>为跳过，<code>!</code>为全部替代</li>
<li>选中文本：默认情况下，Emacs 使用<code>C-space</code>来标记选中的文本，可以在<code>.emacs</code>中加上一行，将其改成<code>C-Enter</code>：<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define-key</span> global-map [C-return] 'set-mark-command)</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.jesshamrick.com/2012/09/10/absolute-beginners-guide-to-emacs/" target="_blank" rel="external">Absolute Beginner’s Guide to Emacs</a>
　　</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/03/24/高效Python3-类的属性/" itemprop="url">
                  Effective Python3（四） -- 访问类的属性
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-03-24T20:23:45+08:00" content="2015-03-24">
              2015-03-24
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/编程语言/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="public-与-private-属性"><a href="#public-与-private-属性" class="headerlink" title="public 与 private 属性"></a>public 与 private 属性</h2><p>　　要是类的属性名以<code>__</code>开头，那么，这个属性就作为类<code>private</code>属性：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.public_value = <span class="number">10</span></div><div class="line">        self.__private_value = <span class="number">100</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_private_value</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.__private_value       </div><div class="line">   </div><div class="line"><span class="meta">   @classmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_private_value_of_instance</span><span class="params">(cls, instance)</span>:</span></div><div class="line">        <span class="keyword">return</span> instance.__private_value</div></pre></td></tr></table></figure></p>
<p>　　显然，我们无法直接从类的外部访问<code>private</code>属性，但我们可以通过实例的方法或者类方法来访问<code>private</code>属性：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>foo = MyClass()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>foo.public_value</div><div class="line"><span class="number">10</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>foo.get_private_value()</div><div class="line"><span class="number">100</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>MyClass.get_private_value_of_instance(foo)</div><div class="line"><span class="number">100</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>foo.__private_value</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">AttributeError: <span class="string">'MyClass'</span> object has no attribute <span class="string">'__private_value'</span></div><div class="line">```　</div><div class="line">　　看看一个有趣的例子，我们使用`Child`作为`MyClass`的子类：</div><div class="line">```python</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span><span class="params">(MyClass)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        super().__init__()</div></pre></td></tr></table></figure></p>
<p>　　实际上，需要知道，在 Python 中，<code>private</code>属性仅仅是一种命名的规范，因此，这并不妨碍我们从类的外部访问类的属性，并且，也可以从子类中访问父类的<code>private</code>属性：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>foo = MyClass()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>foo._MyClass__private_value</div><div class="line"><span class="number">100</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>bar = Child()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>bar._MyClass__private_value</div><div class="line"><span class="number">100</span></div></pre></td></tr></table></figure></p>
<p>　　当我们在<code>MyClass</code>类中定义<code>__private_value</code>时，解析器会将<code>__private_value</code>转换成<code>_MyClass__private_value</code>。因此，只要知道这个规则，就可以从类的外部访问类的<code>private</code>属性了。</p>
<p>　　如果查看实例的属性字典，可以看到，<code>__private_value</code>的真正名字是<code>_MyClass__private_value</code>，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(bar.__dict__)</div><div class="line">&#123;<span class="string">'_MyClass__private_value'</span>: <span class="number">100</span>, <span class="string">'public_value'</span>: <span class="number">10</span>&#125;</div></pre></td></tr></table></figure></p>
<p>　　由于我们可以在类的外部访问类的<code>private</code>属性，那么，显然，<code>private</code>属性就失去它的功效了，因此，应当尽量避免使用<code>private</code>属性。</p>
<p>　　注意，除了<code>public</code>和<code>private</code>属性之外，还可以使用<code>protected</code>属性，<code>protected</code>属性以<code>_</code>作为命名的开头。如果我们不想在类的外部直接访问这个属性，并且要求这个属性能够被子类访问，那么，应当使用<code>protected</code>属性。同样，<code>protected</code>属性也仅是命名规范，实际上并无法限制从类的外部访问<code>protected</code>属性，使用<code>protected</code>属性时，需要加文档注明这个属性不打算被外部访问，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></div><div class="line">        <span class="comment"># This store the user-supplied value for the object, </span></div><div class="line">        <span class="comment"># and can't be directly access from outside</span></div><div class="line">        self._value = value</div></pre></td></tr></table></figure></p>
<hr>
<p>　　通常，<code>private</code>属性表面这个属性不打算被外部访问，也不打算被子类访问，而是作为类的内部成员。一种使用<code>private</code>属性的情况是，在继承层次中，避免命名冲突。例如，<code>_value</code>是常见的命名方式，要是子类中也存在<code>_value</code>属性，那么，就会覆盖父类的<code>_value</code>属性：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self._value = <span class="number">100</span></div><div class="line">        </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span><span class="params">(Parent)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self._value = <span class="string">'value'</span></div></pre></td></tr></table></figure></p>
<p>　　由于父类无法预判子类的行为，因此，可以使用<code>private</code>属性表示这个属性并不打算被子类访问：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.__value = <span class="number">100</span></div><div class="line">        </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span><span class="params">(Parent)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self._value = <span class="string">'value'</span></div></pre></td></tr></table></figure></p>
<p>　　这样，就可以避免父类与子类产生命名冲突了。</p>
<h2 id="不使用-getter-和-setter"><a href="#不使用-getter-和-setter" class="headerlink" title="不使用 getter 和 setter"></a>不使用 getter 和 setter</h2><p>　　在 Java 和 C++ 语言中，为维持类的封装性，经常需要使用<code>set()</code>和<code>get()</code>成员函数。这时因为在 Java 或 C++ 里面，数据成员通常是<code>private</code>的，为了在修改<code>private</code>成员的同时不改变类的接口，就需要使用<code>set()</code>和<code>get()</code>来访问<code>private</code>的数据成员。</p>
<p>　　当然，在 Python 中也可以这样做，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></div><div class="line">        self._name = name</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_name</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self._name</div><div class="line">        </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_name</span><span class="params">(self, name)</span>:</span></div><div class="line">        self._name = name</div></pre></td></tr></table></figure></p>
<p>　　但在 Python 中，类的属性 ( 也即数据成员 ) 都是<strong>公有的</strong>，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, )</span>:</span></div><div class="line">        self.value = <span class="number">0</span></div><div class="line">        self._value = <span class="number">1</span></div><div class="line">        self.__value = <span class="number">2</span></div></pre></td></tr></table></figure></p>
<p>　　尽管<code>_value</code>和<code>__value</code>分别表示<code>protected</code>和<code>private</code>属性，但这并不妨碍从类的外部访问这些属性，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>foo = MyClass()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>foo.value</div><div class="line"><span class="number">0</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>foo._value</div><div class="line"><span class="number">1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>foo._MyClass__value</div><div class="line"><span class="number">2</span></div></pre></td></tr></table></figure></p>
<p>　　那么，这时我们知道，在 Python 中并不需要使用<code>set()</code>和<code>get()</code>来维护类的封装性。但其实，<code>set()</code>和<code>get()</code>的另一个作用是，当我们需要修改类的实现的时候，可以在<code>set()</code>和<code>get()</code>增加其它的操作：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, side)</span>:</span></div><div class="line">        self.set_side(side)</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_side</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self._side</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_side</span><span class="params">(self, side)</span>:</span></div><div class="line">        <span class="keyword">if</span> side &lt; <span class="number">0</span>:</div><div class="line">            self._side = <span class="number">0</span></div><div class="line">        <span class="keyword">elif</span> side &gt; <span class="number">100</span>:</div><div class="line">            self._side = <span class="number">100</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            self._side = side</div></pre></td></tr></table></figure></p>
<p>　　这里我们通过<code>set_side()</code>方法将<code>side</code>属性的值限定在 0 到 100 之间。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>foo = Square(<span class="number">200</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>foo.get_side()</div><div class="line"><span class="number">100</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>foo.set_side(<span class="number">-100</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>foo.get_side()</div><div class="line"><span class="number">0</span></div></pre></td></tr></table></figure></p>
<p>　　需要注意的是，由于<code>side</code>属性是共有的，因此，客户端完全可以直接访问<code>side</code>，这样做就<strong>破坏了类的封装性</strong>，但是我们没有办法防止这种情况发生：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>foo = Square(<span class="number">200</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>foo._side = <span class="number">-100</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>foo.get_side()</div><div class="line"><span class="number">-100</span></div></pre></td></tr></table></figure></p>
<h2 id="使用-property-装饰器"><a href="#使用-property-装饰器" class="headerlink" title="使用 @property 装饰器"></a>使用 @property 装饰器</h2><p>　　应当避免使用<code>set()</code>和<code>get()</code>方法，而直接访问类的属性，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></div><div class="line">            self.value = value</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>foo = MyClass(<span class="number">10</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>foo.value = <span class="number">100</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(foo.value)</div><div class="line"><span class="number">100</span></div></pre></td></tr></table></figure></p>
<p>　　但是，有时在类的属性被设置时，我们需要指定执行其它的操作，那么，这时就需要使用 @property 装饰器了：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, side)</span>:</span></div><div class="line">        self.side = side</div><div class="line">    </div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">side</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self._side</div><div class="line">        </div><div class="line"><span class="meta">    @side.setter</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">side</span><span class="params">(self, side)</span>:</span></div><div class="line">        <span class="keyword">if</span> side &lt; <span class="number">0</span>:</div><div class="line">            self._side = <span class="number">0</span></div><div class="line">        <span class="keyword">elif</span> side &gt; <span class="number">100</span>:</div><div class="line">            self._side = <span class="number">100</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            self._side = side</div><div class="line"></div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">area</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self._side ** <span class="number">2</span></div></pre></td></tr></table></figure></p>
<p>　　那么，我们可以在类的外部访问<code>side</code>属性，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>foo = Square(<span class="number">-99</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>foo.side</div><div class="line"><span class="number">0</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>foo.side = <span class="number">500</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>foo.side</div><div class="line"><span class="number">100</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>foo.area</div><div class="line"><span class="number">10000</span></div></pre></td></tr></table></figure></p>
<p>　　但注意，我们可以看到，在<code>Square</code>类中实际上并不存在<code>side</code>属性，当我们在类的外部访问<code>side</code>属性时，例如，当我们对执行<code>foo.side = 500</code>时，实际上将调用<code>@side.setter</code>方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@side.setter</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">side</span><span class="params">(self, side)</span>:</span></div><div class="line">    <span class="comment"># ...</span></div></pre></td></tr></table></figure></p>
<p>　　<code>Square</code>中实际存在的属性是<code>_side</code>而不是<code>side</code>，当然，我们可以将<code>_side</code>改成其它任意的名字。同样道理，使用<code>@property</code>装饰器，只是让属性从表面上看起来是存在的，但实际上并不存在，因此，我们得以从<code>Square</code>的外部访问<code>area</code>属性：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>foo = Square(<span class="number">30</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>foo.area</div><div class="line"><span class="number">900</span></div></pre></td></tr></table></figure></p>
<p>　　但需要注意，<code>Square</code>中实际上不能存在<code>side</code>属性，否则将引起递归调用：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, side)</span>:</span></div><div class="line">        self.side = side</div><div class="line">    </div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">side</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.side</div><div class="line">        </div><div class="line"><span class="meta">    @side.setter</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">side</span><span class="params">(self, side)</span>:</span></div><div class="line">        <span class="keyword">if</span> side &lt; <span class="number">0</span>:</div><div class="line">            self.side = <span class="number">0</span></div><div class="line">        <span class="keyword">elif</span> side &gt; <span class="number">100</span>:</div><div class="line">            self.side = <span class="number">100</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            self.side = side</div><div class="line"></div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">area</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.side ** <span class="number">2</span></div></pre></td></tr></table></figure></p>
<p>　　在这种情况下，创建<code>Square</code>实例时将出现错误：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>foo = Square(<span class="number">-100</span>)</div><div class="line"><span class="comment"># ...</span></div><div class="line">RuntimeError: maximum recursion depth exceeded</div></pre></td></tr></table></figure></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.amazon.com/Effective-Python-Specific-Software-Development/dp/0134034287/ref=sr_1_1?ie=UTF8&amp;qid=1426775022&amp;sr=8-1&amp;keywords=effective+python" target="_blank" rel="external">Effective Python: Item 27 – Prefer Public Attributes Over Private Ones</a></li>
<li><a href="http://www.amazon.com/Effective-Python-Specific-Software-Development/dp/0134034287/ref=sr_1_1?ie=UTF8&amp;qid=1426775022&amp;sr=8-1&amp;keywords=effective+python" target="_blank" rel="external">Effective Python: Item 29 – Use Plain Attributes Instead of Get and Set Methods</a></li>
<li><a href="http://www.python-course.eu/python3_properties.php" target="_blank" rel="external">Properties vs. Getters and Setters</a>　</li>
<li><a href="http://stackoverflow.com/questions/6618002/python-property-versus-getters-and-setters" target="_blank" rel="external">StackOverflow: Python @property versus getters and setters</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/03/23/高效Python3-多重继承与初始化/" itemprop="url">
                  Effective Python3（三） -- 多重继承与初始化
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-03-23T14:29:57+08:00" content="2015-03-23">
              2015-03-23
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/编程语言/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="显示初始化"><a href="#显示初始化" class="headerlink" title="显示初始化"></a>显示初始化</h2><p>　　一种初始化父类的方式是，在子类的构造方法中显示调用父类的构造方法，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></div><div class="line">        self.value = value</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span><span class="params">(Base)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        Base.__init__(self, <span class="number">10</span>)</div></pre></td></tr></table></figure></p>
<p>　　在单一继承的关系中，例如，这里<code>Child</code>只有一个父类<code>Base</code>，那么，这种初始化方式是可行的，但需要保证在子类的构造方法中，先初始化父类，再初始化子类本身。<br>　　但在多重继承的情况下，例如，子类拥有多个父类，这时，这种手动指定初始化的方式就不可行了，因为我们无法确定父类初始化的次序：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="comment"># ...</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="comment"># ...</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span><span class="params">(Base1, Base2)</span>:</span></div><div class="line">    <span class="comment"># can't not determinate which parent class to initialize first</span></div></pre></td></tr></table></figure></p>
<p>　　另一中情况是，在菱形继承关系里面，超类的构造方法可能被执行多次，那么，将导致不可预测的行为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></div><div class="line">        self.value = value</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Double</span><span class="params">(Base)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></div><div class="line">        Base.__init__(self, value)</div><div class="line">        self.value *= <span class="number">2</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span><span class="params">(Base)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></div><div class="line">        Base.__init__(self, value)</div><div class="line">        self.value = self.value ** <span class="number">2</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span><span class="params">(Double, Square)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></div><div class="line">        Double.__init__(self, value)</div><div class="line">        Square.__init__(self, value)</div></pre></td></tr></table></figure></p>
<p>　　在菱形继承关系中，<code>Double</code>和<code>Square</code>都继承了<code>Base</code>，而<code>SubClass</code>同时继承了<code>Double</code>和<code>Square</code>，例如：<br><img src="/images/data-structure/sub1.png" alt=""><br>　　可以看到，在<code>Double</code>和<code>Square</code>的构造方法里面，将会分别会调用<code>Base</code>的构造方法，也就是说，<code>Base</code>的构造方法将会被执行两次，那么，显然这样是不正确的：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>foo = SubClass(<span class="number">5</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'Should be (5 * 2) ^ 2 = 100 but is'</span>, foo.value)</div><div class="line">Should be (<span class="number">5</span> * <span class="number">2</span>) ^ <span class="number">2</span> = <span class="number">100</span> but <span class="keyword">is</span> <span class="number">25</span></div></pre></td></tr></table></figure></p>
<p>　　注意，在<code>Square</code>的构造方法中，<code>value</code>的值将被重新设置为 5，因此，所得到的结果是 25。</p>
<h2 id="初始化次序"><a href="#初始化次序" class="headerlink" title="初始化次序"></a>初始化次序</h2><p>　　Python 2.2 中定义了<code>super</code>函数，并定义了方法解析次序 ( Method    Resolution Order )，也称 MRO，MRO 保证了，在菱形继承关系中，共有的基类的构造方法仅执行一次。</p>
<p>　　看看在 Python2 里是怎样处理初始化的：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></div><div class="line">        self.value = value</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Double</span><span class="params">(Base)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></div><div class="line">        super(Double, self).__init__(value)</div><div class="line">        self.value *= <span class="number">2</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span><span class="params">(Base)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></div><div class="line">        super(Square, self).__init__(value)</div><div class="line">        self.value = self.value ** <span class="number">2</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span><span class="params">(Double, Square)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></div><div class="line">        super(SubClass, self).__init__(value)</div></pre></td></tr></table></figure></p>
<p>　　当我们创建<code>SubClass</code>的实例时，<code>Base</code>的构造方法只执行一次。另外，我们还想知道，在多重继承里面，MRO 是怎样指定父类的初始化次序的：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>foo = SubClass(<span class="number">5</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">'Should be (5 ^ 2) * 2 = 50 and is'</span>, foo.value</div><div class="line">Should be (<span class="number">5</span> ^ <span class="number">2</span>) * <span class="number">2</span> = <span class="number">50</span> <span class="keyword">and</span> <span class="keyword">is</span> <span class="number">50</span></div></pre></td></tr></table></figure></p>
<p>　　调用<code>SubClass</code>的类方法<code>mro()</code>可以得到<code>SubClass</code>初始化的次序：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from pprint import pprint</div><div class="line">&gt;&gt;&gt; pprint(SubClass.mro())</div><div class="line">[&lt;class 'test.SubClass'&gt;,</div><div class="line"> &lt;class 'test.Double'&gt;,</div><div class="line"> &lt;class 'test.Square'&gt;,</div><div class="line"> &lt;class 'test.Base'&gt;,</div><div class="line"> &lt;type 'object'&gt;]</div></pre></td></tr></table></figure></p>
<p>　　可以看到，继承关系的顶部为<code>Base</code>，因此，<code>Base</code>最先被初始化，其次是<code>Square</code>被初始化，接着是<code>Double</code>被初始化，最后是<code>SubClass</code>被初始化。<br>　　例如，在执行<code>SubClass(5)</code>时，首先将<code>Base</code>的属性<code>value</code>赋值为 5，接着执行<code>Square</code>的构造方法将<code>value</code>设置为其平方值，接着，<code>Double</code>的构造方法将<code>value</code>赋值为原来的两倍，那么这时<code>value</code>的值就是 50 了。</p>
<p>　　实际上，在 Python3 中提供了语法糖，也就是说，在调用<code>super</code>函数的时候，不用显示传递参数，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></div><div class="line">        self.value = value</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Double</span><span class="params">(Base)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></div><div class="line">        super().__init__(value)</div><div class="line">        self.value *= <span class="number">2</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span><span class="params">(Base)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></div><div class="line">        super().__init__(value)</div><div class="line">        self.value = self.value ** <span class="number">2</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span><span class="params">(Double, Square)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></div><div class="line">        super().__init__(value)</div></pre></td></tr></table></figure></p>
<p>　　在使用多重继承的情况下，有时会遇到 MRO 无法解决的情况，这时，将抛出异常，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">First</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">'first'</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Second</span><span class="params">(First)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        super().__init__()</div><div class="line">        print(<span class="string">'second'</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Third</span><span class="params">(First, Second)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        super().__init__()</div><div class="line">        print(<span class="string">'third'</span>)</div></pre></td></tr></table></figure></p>
<p>　　这时将产生错误：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">TypeError: Cannot create a consistent method resolution</div><div class="line">order (MRO) <span class="keyword">for</span> bases Second, First</div></pre></td></tr></table></figure></p>
<p>　　当我们创建<code>Third</code>的实例时，首先需要初始化<code>Second</code>，其次再初始化<code>First</code>，但由于<code>Second</code>是<code>First</code>的子类，那么，初始化<code>Second</code>又意味着需要先初始化<code>First</code>。在这种模棱两可的情况下，将产生错误。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.amazon.com/Effective-Python-Specific-Software-Development/dp/0134034287/ref=sr_1_1?ie=UTF8&amp;qid=1426775022&amp;sr=8-1&amp;keywords=effective+python" target="_blank" rel="external">Effective Python: Item 25 – Initialize Parent Classes with super</a></li>
<li><a href="http://stackoverflow.com/questions/3277367/how-does-pythons-super-work-with-multiple-inheritance" target="_blank" rel="external">StackOverflow: How does Python’s super() work with multiple inheritance?</a>　　</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/03/22/Emacs24与Python3/" itemprop="url">
                  将 Emacs24 配置成 Python3 IDE
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-03-22T10:21:52+08:00" content="2015-03-22">
              2015-03-22
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/软件技巧/" itemprop="url" rel="index">
                    <span itemprop="name">软件技巧</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="解析器配置"><a href="#解析器配置" class="headerlink" title="解析器配置"></a>解析器配置</h2><p>　　默认情况下，Emacs24 使用 Python2.x 的解析器，我们可以将解析器配置成 Python3.x 版本：</p>
<ul>
<li>使用 Alt + x, 输入<code>customize-variable</code>，按回车。</li>
<li>输入<code>python-shell-interpreter</code>，按回车。</li>
</ul>
<p>　　那么，在 Emacs 中就会出现下面的情况：</p>
<ul>
<li>将<code>python</code>改成<code>python3</code>。</li>
<li>将<code>State</code>属性设置成<code>Save for Futer Sessions</code>。</li>
</ul>
<p>　　这样，就将解析器配置成 Python3.x 版本了。在 Emacs 中，使用 Alt + x，输入<code>run-python</code>，将出现：<br><img src="/images/data-structure/p3.png" alt="">  </p>
<h2 id="检错与补全"><a href="#检错与补全" class="headerlink" title="检错与补全"></a>检错与补全</h2><p>　　在<code>.emacs</code>文件中加上以下内容：</p>
<pre><code class="lisp">(<span class="name">require</span> 'package)  
(<span class="name">setq</span> package-archives  
      '((<span class="string">"gnu"</span> . <span class="string">"http://elpa.gnu.org/packages/"</span>)  
        (<span class="string">"marmalade"</span> . <span class="string">"http://marmalade-repo.org/packages/"</span>)  
        (<span class="string">"melpa"</span> . <span class="string">"http://melpa.milkbox.net/packages/"</span>)))  
(<span class="name">package-initialize</span>)
</code></pre>
<p>　　使用 Alt + x，输入<code>list-packages</code>，按回车。我们安装<code>pymacs</code>、<code>pycomplete</code>、<code>pyflakes</code>和<code>python-mode</code>，以及其它的与 Python 相关的包。<br>　　当我们安装了<code>pyflakes</code>之后，就可以对 Python 源文件进行语法检错了，例如，当我们在编辑 Python 源文件时，使用快捷键<code>C c C z</code>就可以检查源文件的语法。<br>　　使用快捷键<code>C c C p</code>可以在 Emacs 中启动 Python3 解析器，在解析器中编写程序，使用 TAB 键将会进行语法补全。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://stackoverflow.com/questions/23852308/how-to-configure-python-el-for-emacs-to-use-python3-shell" target="_blank" rel="external">how to configure python.el for emacs to use python3 shell?</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/03/21/高效Python3-函数/" itemprop="url">
                  Effective Python3（二） -- 函数技巧
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-03-21T19:19:23+08:00" content="2015-03-21">
              2015-03-21
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/编程语言/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="异常的处理"><a href="#异常的处理" class="headerlink" title="异常的处理"></a>异常的处理</h2><p>　　当函数在处理输入的过程中遇到错误，这时应当抛出异常，而不是返回<code>None</code>值，因为<code>None</code>值和其它一些值能够隐式地转换成为<code>False</code>，例如，我们定义<code>divide()</code>函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">divide</span><span class="params">(a, b)</span>:</span></div><div class="line">	<span class="keyword">try</span>:</div><div class="line">	    <span class="keyword">return</span> a / b</div><div class="line">	<span class="keyword">except</span> ZeroDivisionError:</div><div class="line">	    <span class="keyword">return</span> <span class="keyword">None</span></div></pre></td></tr></table></figure></p>
<p>　　那么，我们可以通过判断返回值是否为<code>None</code>，来判断<code>divide()</code>是否运行良好：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>x, y = <span class="number">3</span>, <span class="number">9</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>result = divide(x, y)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> result <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">	print(<span class="string">'Invalid inputs'</span>)</div></pre></td></tr></table></figure></p>
<p>　　但有时，我们可能误认为，要是<code>divide()</code>返回<code>False</code>，表示<code>divide()</code>接受了非法的输入，从而写出这样的代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>x, y = <span class="number">0</span>, <span class="number">3</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>result = divide(x, y)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> <span class="keyword">not</span> result:</div><div class="line">	print(<span class="string">'Invalid inputs'</span>)</div><div class="line"></div><div class="line">Invalid inputs</div></pre></td></tr></table></figure></p>
<p>　　可以看到，由于<code>divide(0, 3)</code>返回<code>0</code>，并且由于<code>0</code>和<code>None</code>二者都能隐式地转换成为<code>False</code>，因此，我们无法判断<code>divide()</code>返回值是<code>0</code>或者是产生了错误。<br>　　一种次优的解决方法是，我们使<code>divide()</code>返回一个包含两个元素的<code>tuple</code>实例，第一个元素用来表示<code>divide()</code>执行是否成功，另一元素来表示<code>divide()</code>返回的结果，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">divide</span><span class="params">(a, b)</span>:</span></div><div class="line">	<span class="keyword">try</span>:</div><div class="line">	    <span class="keyword">return</span> <span class="keyword">True</span>, a / b</div><div class="line">	<span class="keyword">except</span> ZeroDivisionError:</div><div class="line">	    <span class="keyword">return</span> <span class="keyword">False</span>, <span class="keyword">None</span></div></pre></td></tr></table></figure></p>
<p>　　因此，要是返回值的第一个元素为<code>False</code>，则表示出现错误，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>x, y = <span class="number">0</span>, <span class="number">5</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>success, result = divide(x, y)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> <span class="keyword">not</span> success:</div><div class="line">	print(<span class="string">'Invalid inputs'</span>)</div></pre></td></tr></table></figure></p>
<p>　　当然，更好的方法是，不要通过返回<code>None</code>来表示遇到了错误，而应该通过抛出异常，使调用者来处理异常，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">divide</span><span class="params">(a, b)</span>:</span></div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            <span class="keyword">return</span> a / b</div><div class="line">        <span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</div><div class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'Invalid inputs'</span>) <span class="keyword">from</span> e</div><div class="line">    </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>x, y = <span class="number">5</span>, <span class="number">0</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</div><div class="line">        result = divide(x, y)</div><div class="line">    <span class="keyword">except</span> ValueError:</div><div class="line">        print(<span class="string">'Invalid inputs'</span>)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        print(<span class="string">'Result is %.1f'</span> % result)</div><div class="line"> </div><div class="line">Invalid inputs</div></pre></td></tr></table></figure></p>
<p>　　可以看到，要是<code>divide()</code>没有抛出异常，那么，我们就能得到想要的结果。</p>
<h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>　　有时在排序数据时需要显示指定排序准则，例如，我们可以要求优先对指定范围内的数据进行排序，其次再排序其它的数据，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">sort_priority</span><span class="params">(values, group)</span>:</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(x)</span>:</span></div><div class="line">	    <span class="keyword">if</span> x <span class="keyword">in</span> group:</div><div class="line">	        <span class="keyword">return</span> (<span class="number">0</span>, x)</div><div class="line">	    <span class="keyword">return</span> (<span class="number">1</span>, x)</div><div class="line">	values.sort(key=helper)</div></pre></td></tr></table></figure></p>
<p>　　由于 Python 支持闭包，也就是说，函数可以访问其定义位置所在作用域中的变量，因此，<code>helper()</code>函数可以访问<code>sort_priority()</code>函数中的<code>group</code>变量。这样，我们可以使用<code>sort_priority()</code>对数据进行排序：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>numbers = [<span class="number">9</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>group = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>sort_priority(numbers, group)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(numbers)</div><div class="line">[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">9</span>]</div></pre></td></tr></table></figure></p>
<p>　　当然，我们可以使用变量<code>found</code>来判断，在输入中是否存在需要优先排序的元素：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">sort_priority2</span><span class="params">(values, group)</span>:</span></div><div class="line">        found = <span class="keyword">False</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(x)</span>:</span></div><div class="line">            <span class="keyword">if</span> x <span class="keyword">in</span> group:</div><div class="line">                found = <span class="keyword">True</span></div><div class="line">                <span class="keyword">return</span> (<span class="number">0</span>, x)</div><div class="line">            <span class="keyword">return</span> (<span class="number">1</span>, x)</div><div class="line">        values.sort(key=helper)</div><div class="line">        <span class="keyword">return</span> found</div></pre></td></tr></table></figure></p>
<p>　　使用之前的数据对这个函数进行测试，我们预料<code>sort_priority2()</code>将会返回<code>True</code>:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>numbers = [<span class="number">9</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>group = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>found = sort_priority2(numbers, group)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'Found: '</span>, found)</div><div class="line">Found:  <span class="keyword">False</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(numbers)</div><div class="line">[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">9</span>]</div></pre></td></tr></table></figure></p>
<p>　　但是，我们看到，返回值是<code>False</code>而不是<code>True</code>。实际上，在<code>helper()</code>函数中，<code>found</code>表示存在于<code>helper()</code>中的局部变量，因此，<code>helper()</code>中的<code>found</code>变量与<code>sort_priority2()</code>中的<code>found</code>变量并不是同一变量。<br>　　我们可以显式为<code>helper()</code>中的<code>found</code>变量加上<code>nonlocal</code>修饰符，表示这个变量引用的是外围作用域中的<code>found</code>变量，也就是<code>sort_priority2()</code>中的<code>found</code>变量：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">sort_priority3</span><span class="params">(values, group)</span>:</span></div><div class="line">        found = <span class="keyword">False</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(x)</span>:</span></div><div class="line">            <span class="keyword">nonlocal</span> found</div><div class="line">            <span class="keyword">if</span> x <span class="keyword">in</span> group:</div><div class="line">                found = <span class="keyword">True</span></div><div class="line">                <span class="keyword">return</span> (<span class="number">0</span>, x)</div><div class="line">            <span class="keyword">return</span> (<span class="number">1</span>, x)</div><div class="line">        values.sort(key=helper)</div><div class="line">        <span class="keyword">return</span> found</div><div class="line"> </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>found = sort_priority3(numbers, group)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(found)</div><div class="line"><span class="keyword">True</span></div></pre></td></tr></table></figure></p>
<p>　　可以看到，这时<code>helper()</code>中的<code>found</code>变量将引用<code>sort_priority3()</code>中的<code>found</code>变量。实际上，我们可以定义一个类，以避免使用<code>nonlocal</code>修饰符：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Sorter</span><span class="params">(object)</span>:</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, group)</span>:</span></div><div class="line">	    self.group = group</div><div class="line">	    self.found = <span class="keyword">False</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, x)</span>:</span></div><div class="line">	    <span class="keyword">if</span> x <span class="keyword">in</span> self.group:</div><div class="line">		self.found = <span class="keyword">True</span></div><div class="line">		<span class="keyword">return</span> (<span class="number">0</span>, x)</div><div class="line">	    <span class="keyword">return</span> (<span class="number">1</span>, x)</div><div class="line">	</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>sorter = Sorter(group)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>numbers.sort(key=sorter)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(sorter.found)</div><div class="line"><span class="keyword">True</span></div></pre></td></tr></table></figure></p>
<h2 id="返回生成器"><a href="#返回生成器" class="headerlink" title="返回生成器"></a>返回生成器</h2><p>　　有时函数需要返回较多的结果，通常，我们考虑将这些结果存储在<code>list</code>中，并返回这个<code>list</code>。当数据较少时，这样做当然没问题。但是，当函数需要返回大量数据，将这些数据存储在<code>list</code>中，将会耗费大量内存，特别是当函数从包含大量数据的文件中读取数据的时候，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">lines_count</span><span class="params">(file_handle)</span>:</span></div><div class="line">        result = []</div><div class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> file_handle:</div><div class="line">            <span class="keyword">if</span> line:</div><div class="line">                result.append(len(line))</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                result.append(<span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> result</div><div class="line">    </div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> open(<span class="string">'file'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</div><div class="line">        result = lines_count(f)</div><div class="line">    	print(result)</div></pre></td></tr></table></figure></p>
<p>　　更好的做法是返回生成器，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">lines_count</span><span class="params">(file_handle)</span>:</span></div><div class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> file_handle:</div><div class="line">            <span class="keyword">if</span> line:</div><div class="line">                <span class="keyword">yield</span> len(line)  </div><div class="line">	    <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">yield</span> <span class="number">0</span></div></pre></td></tr></table></figure></p>
<p>　　我们可以返回的生成器，通过生成器可以一次只处理一个数据。要是每次将数据利用完就丢弃，那就可以节省内存：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> open(<span class="string">'file'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</div><div class="line">    	 result = lines_count(f)</div><div class="line">    	 total = sum(result)</div></pre></td></tr></table></figure></p>
<p>　　生成器的另一作用则是，我们可以使用<code>list()</code>函数，通过生成器得到<code>list</code>实例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> open(<span class="string">'file'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</div><div class="line">    	 result = lines_count(f)</div><div class="line">	 print(list(result))</div></pre></td></tr></table></figure></p>
<h2 id="关键词参数"><a href="#关键词参数" class="headerlink" title="关键词参数"></a>关键词参数</h2><p>　　调用函数时，可以按位置传递参数，也可以按关键词传递参数，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">remainder</span><span class="params">(number, divisor)</span>:</span></div><div class="line">    	<span class="keyword">return</span> number % divisor</div></pre></td></tr></table></figure></p>
<p>　　那么，我们可以按照位置传递参数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>remainder(<span class="number">20</span>, <span class="number">7</span>)</div><div class="line"><span class="number">6</span></div></pre></td></tr></table></figure></p>
<p>　　也可以按照关键词来传递参数，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>remainder(number=<span class="number">20</span>, divisor=<span class="number">7</span>)</div><div class="line"><span class="number">6</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>remainder(divisor=<span class="number">7</span>, number=<span class="number">20</span>)</div><div class="line"><span class="number">6</span></div></pre></td></tr></table></figure></p>
<p>　　我们也可以混合按位置传参和按关键词传参，但需要注意，按位置传递的参数需要出现在按关键词传递的参数之前：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>remainder(<span class="number">20</span>, divisor=<span class="number">7</span>)</div><div class="line"><span class="number">6</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>remainder(number=<span class="number">20</span>, <span class="number">7</span>)</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span></div><div class="line">SyntaxError: non-keyword arg after keyword arg</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>remainder(<span class="number">20</span>, number=<span class="number">7</span>)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">TypeError: remainder() got multiple values <span class="keyword">for</span> argument <span class="string">'number'</span></div></pre></td></tr></table></figure></p>
<p>　　按关键词来传递参数的好处就是，使程序更具可读性。另外，我们还可以为形参指定默认值：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">average_cost</span><span class="params">(total, days=<span class="number">365</span>)</span>:</span></div><div class="line">        <span class="keyword">return</span> total / days</div></pre></td></tr></table></figure></p>
<p>　　要是函数的参数具有默认值，我们可以按位置来传参，也可以按关键词来传参，但为了代码更清晰，我们通常按关键词来传参：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>average = average_cost(<span class="number">1000</span>, days=<span class="number">500</span>)</div></pre></td></tr></table></figure></p>
<p>　　有时，我们要求函数拓展函数的参数，但又不能打破函数的向后兼容性，那么，可以使用默认参数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">average_salary</span><span class="params">(total, month)</span>:</span></div><div class="line">       <span class="keyword">return</span> total / month</div></pre></td></tr></table></figure></p>
<p>　　我们可以对函数拓展参数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">average_salary</span><span class="params">(total, month, bonus=<span class="number">1000</span>)</span>:</span></div><div class="line">        <span class="keyword">return</span> total / month + bonus</div></pre></td></tr></table></figure></p>
<p>　　那么，可以看到，新定义的函数能够兼容旧的代码，同时通过拓展参数，可以提供给新的用户使用。</p>
<h2 id="强制关键词"><a href="#强制关键词" class="headerlink" title="强制关键词"></a>强制关键词</h2><p>　　有时除法运算会抛出异常，我们可以定义函数来应对这些异常：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">safe_division</span><span class="params">(number, divisor, </span></span></div><div class="line">                  ignore_overflow=False, </div><div class="line">                  ignore_zero_division=False):</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        <span class="keyword">return</span> number / divisor</div><div class="line">    <span class="keyword">except</span> OverflowError:</div><div class="line">        <span class="keyword">if</span> ignore_overflow:</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">raise</span></div><div class="line">    <span class="keyword">except</span> ZeroDivisionError:</div><div class="line">        <span class="keyword">if</span> ignore_zero_division:</div><div class="line">            <span class="keyword">return</span> float(<span class="string">'inf'</span>)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">raise</span></div></pre></td></tr></table></figure></p>
<p>　　我们使用<code>ignore_overflow</code>和<code>ignore_zero_division</code>来指定是否忽略算法运算中可能抛出的异常。例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>result = safe_division(<span class="number">1</span>, <span class="number">0</span>, ignore_zero_division=<span class="keyword">True</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(result)</div><div class="line">inf</div></pre></td></tr></table></figure></p>
<p>　　当然，在调用<code>safe_division()</code>函数时，传递后两个参数可以不按关键词传参，但这样将带来混淆，因此，在调用这个函数时，可以强制使用关键词传参：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">safe_division</span><span class="params">(number, divisor, *,</span></span></div><div class="line">                  ignore_overflow=False, </div><div class="line">                  ignore_zero_division=False):</div><div class="line"><span class="comment"># as before</span></div></pre></td></tr></table></figure></p>
<p>　　这时，后两个参数则必须要按关键词传参，例如：<br>```python</p>
<blockquote>
<blockquote>
<blockquote>
<p>result = safe_division(1, 0, False, True)<br>Traceback (most recent call last):<br>  File “t.py”, line 28, in <module><br>    result = safe_division(1, 0, False, True)<br>TypeError: safe_division() takes 2 positional arguments but 4 were given<br>result = safe_division(1, 0, ignore_zero_division=True)<br>print(result)<br>inf<br>```　</module></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.amazon.com/Effective-Python-Specific-Software-Development/dp/0134034287/ref=sr_1_1?ie=UTF8&amp;qid=1426775022&amp;sr=8-1&amp;keywords=effective+python" target="_blank" rel="external">Effective Python: 59 Specific Ways to Write Better Python</a></li>
</ul>
</blockquote>
</blockquote>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/03/19/高效Python3-Pythonic风格/" itemprop="url">
                  Effective Python3（一） -- Pythonic 风格
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-03-19T21:21:50+08:00" content="2015-03-19">
              2015-03-19
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/编程语言/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="查看版本"><a href="#查看版本" class="headerlink" title="查看版本"></a>查看版本</h2><p>　　有时系统中存在不同 Python 版本，可以在终端输入命令来查看 Python 的版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ python --version</div><div class="line">Python 2.7.6</div><div class="line">$ python3 --version</div><div class="line">Python 3.4.0</div></pre></td></tr></table></figure></p>
<p>　　在 Python 程序运行的时候，可以利用 Python 内置的模块来获得 Python 的版本信息：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(sys.version_info)</div><div class="line">sys.version_info(major=<span class="number">3</span>, minor=<span class="number">4</span>, micro=<span class="number">0</span>, releaselevel=<span class="string">'final'</span>, serial=<span class="number">0</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(sys.version)</div><div class="line"><span class="number">3.4</span><span class="number">.0</span> (default, Apr <span class="number">11</span> <span class="number">2014</span>, <span class="number">13</span>:<span class="number">05</span>:<span class="number">18</span>) </div><div class="line">[GCC <span class="number">4.8</span><span class="number">.2</span>]</div></pre></td></tr></table></figure></p>
<h2 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h2><p>　　合理使用空格符：</p>
<ul>
<li>使用 4 个空格来表示缩进。</li>
<li>每一行不能超过 79 个字符。</li>
<li>在文件中，函数之间或类之间应该由两行空白行分隔开。</li>
<li>在类中，方法之间应留有一行空白行。</li>
<li>在为变量赋值时，赋值操作符前后都应该留有一个空格符。</li>
<li>在使用下标索引、函数调用和关键字参数赋值时，不要出现空格符。</li>
<li>将较长的表达式分成多行时，除了第一行之外，在其它行的开头，需要额外增加 4 个空白符来表示缩进。</li>
</ul>
<p>　　慎重考虑命名方式：</p>
<ul>
<li>函数、变量和属性的命名使用小写字母和下横线。</li>
<li>类的实例的<code>protected</code>属性使用下横线开头。</li>
<li>类的实例的<code>private</code>属性使用两个下横线开头。</li>
<li>类与异常则使用大驼峰式命名法。</li>
<li>模块中的常量使用<code>ALL_CAPS</code>记法。</li>
<li>类的实例的方法，则使用<code>self</code>作为第一个形参。</li>
<li>类方法则使用<code>cls</code>作为第一个形参。</li>
</ul>
<p>　　语句和表达式的风格：</p>
<ul>
<li>使用<code>if a is not b</code>的方式而不是<code>if not a is b</code>的方式。</li>
<li>不要通过检查一个值的长度，例如<code>if len(somelist) == 0</code>，来判断这个值是否为空值。相反，由于空值会隐式地求值成为<code>Flase</code>，因此使用<code>if not somelist</code>来判断<code>somelist</code>为空值。</li>
<li>对于非空值，例如，可以使用<code>if somelist</code>来判断<code>somelist</code>不为空值。</li>
<li>避免使用单行的<code>if</code>语句、<code>for</code>循环、<code>while</code>循环和<code>except</code>复合语句，将其拆成多行以增加可读性。</li>
<li>总是将<code>import</code>语句放在文件的开头。</li>
<li>假定<code>foo</code>模块存在于<code>bar</code>包中，应使用<code>from bar import foo</code>来导入<code>foo</code>模块。</li>
<li>使用<code>import</code>语句导入模块的次序：标准库的模块，第三方的模块，自己的模块。此外，导入的模块要按照字母表的次序排列。</li>
</ul>
<h2 id="字符转换"><a href="#字符转换" class="headerlink" title="字符转换"></a>字符转换</h2><p>　　在 Python3 中，可以使用<code>bytes</code>或<code>str</code>实例来表示字符串，<code>bytes</code>中包含的是 8 位的字节，而<code>str</code>中包含的是 Unicode 字符。为了将<code>str</code>转换成为二进制数值(即 8 位的字节)，通常使用 UFT-8 编码方式。因此，我们可以使用<code>encode()</code>方法将 Unicode 字符转换成二进制数据，而使用<code>decode()</code>将二进制数据转换成 Unicode 字符。<br>　　我们可以编写一个函数，用来接受<code>str</code>或<code>bytes</code>的实例作为参数，并返回<code>str</code>实例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">to_str</span><span class="params">(bytes_or_str)</span>:</span></div><div class="line">	<span class="keyword">if</span> isinstance(bytes_or_str, bytes):</div><div class="line">	    value = bytes_or_str.decode(<span class="string">'utf-8'</span>)</div><div class="line">	<span class="keyword">else</span>:</div><div class="line">	    value = bytes_or_str</div><div class="line">	<span class="keyword">return</span> value</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>to_str(<span class="string">'hello'</span>)</div><div class="line"><span class="string">'hello'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>by = <span class="string">b'abcd\x65'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>to_str(by)</div><div class="line"><span class="string">'abcde'</span></div></pre></td></tr></table></figure></p>
<p>　　同样，可以编写函数，接受<code>str</code>或<code>bytes</code>的实例作为参数，并返回<code>bytes</code>实例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">to_bytes</span><span class="params">(bytes_or_str)</span>:</span></div><div class="line">	<span class="keyword">if</span> isinstance(bytes_or_str, str):</div><div class="line">	    value = bytes_or_str.encode(<span class="string">'utf-8'</span>)</div><div class="line">	<span class="keyword">else</span>:</div><div class="line">	    value = bytes_or_str</div><div class="line">	<span class="keyword">return</span> value</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>to_bytes(<span class="string">'中文'</span>)</div><div class="line"><span class="string">b'\xe4\xb8\xad\xe6\x96\x87'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>by = <span class="string">b'abcd\x65'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>to_bytes(by)</div><div class="line"><span class="string">b'abcde'</span></div></pre></td></tr></table></figure></p>
<p>　　另外，在 Python3 中，读取或写入文件，默认采用 UTF-8 编码，因此，向文件中写入或读取的内容，默认情况下是 Unicode 字符：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> open(<span class="string">'file.bin'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</div><div class="line">	f.write(os.urandom(<span class="number">10</span>))</div><div class="line"></div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;pyshell#27&gt;"</span>, line <span class="number">2</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">    f.write(os.urandom(<span class="number">10</span>))</div><div class="line">TypeError: must be str, <span class="keyword">not</span> bytes</div></pre></td></tr></table></figure></p>
<p>　　从错误提示可以看到，文件写入的内容需要是 Unicode 字符，而不能是二进制数据。当然，要是我们需要向文件中写入或读取二进制数据，可以分别指定文件的打开方式为<code>wb</code>和<code>rb</code>，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> open(<span class="string">'file.bin'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</div><div class="line">	f.write(os.urandom(<span class="number">10</span>))</div></pre></td></tr></table></figure></p>
<h2 id="序列取片"><a href="#序列取片" class="headerlink" title="序列取片"></a>序列取片</h2><p>　　内置的<code>list</code>、<code>str</code>和<code>bytes</code>类型支持取片操作，例如，取片操作<code>somelist[start:end]</code>，我们可以不给出<code>start</code>或<code>end</code>的值，因为<code>start</code>的默认值是<code>0</code>而<code>end</code>的默认值是<code>len(somelist)</code>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>, <span class="string">'g'</span>, <span class="string">'h'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'First four'</span>, a[:<span class="number">4</span>])</div><div class="line">First four [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'Last four'</span>, a[<span class="number">-4</span>:])</div><div class="line">Last four [<span class="string">'e'</span>, <span class="string">'f'</span>, <span class="string">'g'</span>, <span class="string">'h'</span>]</div></pre></td></tr></table></figure></p>
<p>　　其实我们可以使用负数来作为下标：<br><img src="/images/data-structure/coa.png" alt=""><br>　　实际上，取片操作的下标可以超过边界:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>b = a[:<span class="number">20</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>c = a[<span class="number">-20</span>:]</div></pre></td></tr></table></figure></p>
<p>　　那么这时，<code>b</code>和<code>c</code>都是<code>a</code>的浅拷贝。实际上，对<code>list</code>执行取片操作将创建新的<code>list</code>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>d = a[:<span class="number">4</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'Before: '</span>, d)</div><div class="line">Before:  [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="number">0</span>] = <span class="number">10</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'After: '</span>, d)</div><div class="line">After:  [<span class="number">10</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'Origin: '</span>, a)</div><div class="line">Origin:  [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>, <span class="string">'g'</span>, <span class="string">'h'</span>]</div></pre></td></tr></table></figure></p>
<p>　　同样，可以使用<code>somelist[:]</code>来创建<code>somelist</code>的浅拷贝。还可以将取片作为赋值操作符的左操作数，用来修改原来的<code>list</code>，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>, <span class="string">'g'</span>, <span class="string">'h'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a[:<span class="number">5</span>] = [<span class="number">10</span>, <span class="number">20</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'After: '</span>, a)</div><div class="line">After:  [<span class="number">10</span>, <span class="number">20</span>, <span class="string">'f'</span>, <span class="string">'g'</span>, <span class="string">'h'</span>]</div></pre></td></tr></table></figure></p>
<h2 id="取片步长"><a href="#取片步长" class="headerlink" title="取片步长"></a>取片步长</h2><p>　　可以使用<code>somelist[start:end:step]</code>为取片操作指定步长<code>step</code>，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>colors = [<span class="string">'red'</span>, <span class="string">'black'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>, <span class="string">'yellow'</span>, <span class="string">'gray'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>odds = colors[::<span class="number">2</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(odds)</div><div class="line">[<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'yellow'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>evens = colors[<span class="number">1</span>::<span class="number">2</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(evens)</div><div class="line">[<span class="string">'black'</span>, <span class="string">'blue'</span>, <span class="string">'gray'</span>]</div></pre></td></tr></table></figure></p>
<p>　　尽量避免同时指定<code>start</code>、<code>end</code>和<code>step</code>这三个参数，因为这样会影响程序的可读性。步长的值可以是负数，例如，可以指定步长的值为<code>-1</code>，用来倒转列表：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>reverse_colors = colors[::<span class="number">-1</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(reverse_colors)</div><div class="line">[<span class="string">'gray'</span>, <span class="string">'yellow'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>, <span class="string">'black'</span>, <span class="string">'red'</span>]</div></pre></td></tr></table></figure></p>
<p>　　但负数的步长会影响程序的可读性，通常应该避免使用负数的步长。</p>
<h2 id="列表推导"><a href="#列表推导" class="headerlink" title="列表推导"></a>列表推导</h2><p>　　假定我们需要计算列表中每一元素的平方值，这时可以使用<code>map()</code>函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>squares = list(map(<span class="keyword">lambda</span> x: x ** <span class="number">2</span>, a))</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(squares)</div><div class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>]</div></pre></td></tr></table></figure></p>
<p>　　但实际上我们可以使用更加简洁的语法，这称为列表推导( List Comprehensions )，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>squares = [x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> a]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(squares)</div><div class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>]</div></pre></td></tr></table></figure></p>
<p>　　另外，要是我们只需要计算偶数的平方值，可以使用<code>filter()</code>函数来过滤输入范围的元素：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>even_squares = list(map(<span class="keyword">lambda</span> x: x ** <span class="number">2</span>, filter(<span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">0</span>, a)))</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(even_squares)</div><div class="line">[<span class="number">4</span>, <span class="number">16</span>, <span class="number">36</span>]</div></pre></td></tr></table></figure></p>
<p>　　实际上，更加简洁的做法是在列表推导之后加上条件表达式用来过滤输入中的元素：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>even_squares = [x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> a <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(even_squares)</div><div class="line">[<span class="number">4</span>, <span class="number">16</span>, <span class="number">36</span>]</div></pre></td></tr></table></figure></p>
<p>　　除了<code>list</code>之外，<code>dict</code>和<code>set</code>都拥有等价的列表推导方式：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>city_rank = &#123;<span class="string">'beijing'</span>: <span class="number">1</span>, <span class="string">'shanghai'</span>: <span class="number">2</span>, <span class="string">'guangzhou'</span>: <span class="number">3</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>rank_city = &#123;rank: city <span class="keyword">for</span> city, rank <span class="keyword">in</span> city_rank.items()&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(rank_city)</div><div class="line">&#123;<span class="number">1</span>: <span class="string">'beijing'</span>, <span class="number">2</span>: <span class="string">'shanghai'</span>, <span class="number">3</span>: <span class="string">'guangzhou'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>len_set = &#123;len(city) <span class="keyword">for</span> city <span class="keyword">in</span> rank_city.values()&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(len_set)</div><div class="line">&#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">7</span>&#125;</div></pre></td></tr></table></figure></p>
<p>　　实际上，列表推导支持多级的循环，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>matrix = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>flat = [x <span class="keyword">for</span> row <span class="keyword">in</span> matrix <span class="keyword">for</span> x <span class="keyword">in</span> row]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(flat)</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>squares = [[x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> row] <span class="keyword">for</span> row <span class="keyword">in</span> matrix]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(squares)</div><div class="line">[[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>], [<span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>], [<span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]]</div></pre></td></tr></table></figure></p>
<p>　　实际上，列表推导支持超过两级的循环，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>my_list = [</div><div class="line">	[[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]],</div><div class="line">	[[<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]]</div><div class="line">    ]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>flat = [x <span class="keyword">for</span> sublist1 <span class="keyword">in</span> my_list</div><div class="line">	    <span class="keyword">for</span> sublist2 <span class="keyword">in</span> sublist1</div><div class="line">	    <span class="keyword">for</span> x <span class="keyword">in</span> sublist2]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(flat)</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]</div></pre></td></tr></table></figure></p>
<p>　　从程序的可读性上看，应当避免两级以上的循环。例如，当列表推导的循环超过两级时，应当使用<code>for</code>循环来代替：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>flat = []</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> sublist1 <span class="keyword">in</span> my_list:</div><div class="line">	<span class="keyword">for</span> sublist2 <span class="keyword">in</span> sublist1:</div><div class="line">	    flat.extend(sublist2)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(flat)</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]</div></pre></td></tr></table></figure></p>
<p>　　列表推导也支持多级的<code>if</code>语句，在同一级的多个<code>if</code>语句相当于<code>and</code>，例如<code>b</code>和<code>c</code>的列表推导是等价的：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b = [x <span class="keyword">for</span> x <span class="keyword">in</span> a <span class="keyword">if</span> x &gt; <span class="number">4</span> <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(b)</div><div class="line">[<span class="number">6</span>, <span class="number">8</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>c = [x <span class="keyword">for</span> x <span class="keyword">in</span> a <span class="keyword">if</span> x &gt; <span class="number">4</span> <span class="keyword">and</span> x % <span class="number">2</span> == <span class="number">0</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(c)</div><div class="line">[<span class="number">6</span>, <span class="number">8</span>]</div></pre></td></tr></table></figure></p>
<h2 id="生成器法"><a href="#生成器法" class="headerlink" title="生成器法　"></a>生成器法　</h2><p>　　可以看到，当我们使用列表推导时，将会根据输入范围中的元素来返回新的列表。那么，要是输入中包含大量的元素，例如，从文件中读取数据，这时，列表推导就会创建新的列表，对输入范围中的每个元素作处理，并将处理的结果存储在新建的列表中。但是，要是输入范围的数据过多，那么，列表推导返回的列表将占用较大的内存。<br>　　所以说，列表推导会立即对输入范围的数据作处理，与此不同，我们可以使用生成器表达式，只有在需要的时候才会对输入的元素作处理，这样就可以减少对内存的使用。<br>　　与列表推导不同，生成器表达式使用<code>()</code>而不是<code>[]</code>，返回的是迭代器：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>it = (len(x) <span class="keyword">for</span> x <span class="keyword">in</span> open(<span class="string">'file'</span>))</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(it)</div><div class="line">&lt;generator object &lt;genexpr&gt; at <span class="number">0xb5100194</span>&gt;</div></pre></td></tr></table></figure></p>
<p>　　我们可以使用返回的迭代器，只有在使用迭代器进行迭代的过程中，元素的值才会被计算处理，这种方式也可以称为惰性求值。我们可以使用<code>next()</code>函数返回元素的值，并将迭代器向前推到一步：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(next(it))</div><div class="line"><span class="number">26</span></div></pre></td></tr></table></figure></p>
<p>　　我们也可以组合使用生成器表达式，例如，将之前的迭代器<code>it</code>作为另一生成器表达式的输入范围：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>square_it = ((x, x ** <span class="number">2</span>) <span class="keyword">for</span> x <span class="keyword">in</span> it)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(next(square_it))</div><div class="line">(<span class="number">15</span>, <span class="number">225</span>)</div></pre></td></tr></table></figure></p>
<p>　　在处理较大输入流的问题时，使用生成器表达式将非常高效。</p>
<h2 id="范围表示"><a href="#范围表示" class="headerlink" title="范围表示"></a>范围表示</h2><p>　　在迭代列表时，有时除了需要知道元素之外，还需要知道元素对应的下标，那么，我们可以使用<code>range()</code>函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>names = [<span class="string">'senlin'</span>, <span class="string">'mei'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(len(names)):</div><div class="line">	name = names[i]</div><div class="line">	print(<span class="string">'%d: %s'</span> % (i + <span class="number">1</span>, name))</div></pre></td></tr></table></figure></p>
<p>　　实际上，存在更加简洁的做法，使用<code>enumerate()</code>来取代<code>range()</code>函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i, name <span class="keyword">in</span> enumerate(names):</div><div class="line">	print(<span class="string">'%d: %s'</span> % (i + <span class="number">1</span>, name))</div><div class="line">	</div><div class="line"><span class="number">1</span>: senlin</div><div class="line"><span class="number">2</span>: mei</div></pre></td></tr></table></figure></p>
<p>　　此外，还可以为<code>enumerate()</code>指定起始的下标：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i, name <span class="keyword">in</span> enumerate(names, <span class="number">1</span>):</div><div class="line">	print(<span class="string">'%d: %s'</span> % (i, name))</div><div class="line">	</div><div class="line"><span class="number">1</span>: senlin</div><div class="line"><span class="number">2</span>: mei</div></pre></td></tr></table></figure></p>
<h2 id="同时迭代"><a href="#同时迭代" class="headerlink" title="同时迭代"></a>同时迭代</h2><p>　　我们知道，使用列表推导从原来的列表中得到另一列表：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>names = [<span class="string">'senlin'</span>, <span class="string">'mei'</span>, <span class="string">'zhan'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lens = [len(n) <span class="keyword">for</span> n <span class="keyword">in</span> names]</div></pre></td></tr></table></figure></p>
<p>　　有时，我们需要同时对两个列表进行迭代，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>longest_name = <span class="keyword">None</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>max_len = <span class="number">0</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i, name <span class="keyword">in</span> enumerate(names):</div><div class="line">	count = lens[i]</div><div class="line">	<span class="keyword">if</span> count &gt; max_len:</div><div class="line">	    max_len = count</div><div class="line">	    longest_name = name		</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(longest_name)</div><div class="line">senlin</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(max_len)</div><div class="line"><span class="number">6</span></div></pre></td></tr></table></figure></p>
<p>　　存在更加简洁的方式，我们使用<code>zip()</code>函数将两个或两个以上的可迭代对象包装成惰性生成器，这样，我们就可以使用这个惰性生成器同时对多个输入范围进行迭代：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> count, name <span class="keyword">in</span> zip(lens, names):</div><div class="line">	<span class="keyword">if</span> count &gt; max_len:</div><div class="line">	    max_len = count</div><div class="line">	    longest_name = name</div></pre></td></tr></table></figure></p>
<p>　　但需要注意，在 Python2 中，<code>zip()</code>返回的并不是生成器，相反，<code>zip()</code>会返回列表，包含<code>tuple</code>元素，因此，当输入范围元素较多时，这样就会占用较多的内存。在 Python2 中，如果需要同时迭代多个输入范围，使用<code>itertools</code>模块的<code>izip()</code>函数将会返回一个生成器：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> itertools</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>names = [<span class="string">'senlin'</span>, <span class="string">'mei'</span>, <span class="string">'zhan'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lens = [len(n) <span class="keyword">for</span> n <span class="keyword">in</span> names]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>longest_name = <span class="keyword">None</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>max_len = <span class="number">0</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> count, name <span class="keyword">in</span> itertools.izip(lens, names):</div><div class="line"> 	<span class="keyword">if</span> count &gt; max_len:</div><div class="line"> 	    max_len = count</div><div class="line"> 	    longest_name = name</div></pre></td></tr></table></figure></p>
<p>　　另外，在 Python3 中使用<code>zip()</code>时，需要保证多个输入范围中需要被处理的元素的个数相同。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.amazon.com/Effective-Python-Specific-Software-Development/dp/0134034287/ref=sr_1_1?ie=UTF8&amp;qid=1426775022&amp;sr=8-1&amp;keywords=effective+python" target="_blank" rel="external">Effective Python: 59 Specific Ways to Write Better Python</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="John Doe" />
          <p class="site-author-name" itemprop="name">John Doe</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">97</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">14</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">17</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  

  

  

  

</body>
</html>
