<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/5/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/page/5/"/>

  <title> Hexo </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Hexo</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/05/22/Linux系统编程-进程管理/" itemprop="url">
                  Linux 进程编程（一）-- 进程的介绍
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-05-22T20:14:15+08:00" content="2015-05-22">
              2015-05-22
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/系统编程/" itemprop="url" rel="index">
                    <span itemprop="name">系统编程</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h2><p>　　我们将可执行的文件称为程序 ( Program )，程序通常位于磁盘中。当操作系统需要执行应用程序的时候，它会从磁盘中将程序载入内存，并通过处理器 ( Processor ) 执行一系列的操作。那么，当应用程序在执行的时候，这个正在被执行的程序的实例就称为进程 ( Process )。</p>
<h2 id="私有地址空间"><a href="#私有地址空间" class="headerlink" title="私有地址空间"></a>私有地址空间</h2><p>　　每个进程都拥有其各自的私有地址空间( Private Address Space )，称之为私有的，因为一个进程无法访问其它进程的私有地址空间。<br>　　进程的内存由多个部分组成，以下是进程的内存布局：<br><img src="/images/linux/space.png" alt=""></p>
<p>　　Text 部分包含了程序的机器指令，为了防止进程内部不小心修改了程序的机器指令，Text 部分是 read-only 的，另一方面，由于同一程序可以对应多个进程，因此，Text 部分可以在这些进程之间共享。而 Initialized data 部分显示初始化的全局变量以及静态变量。</p>
<blockquote>
<p><img src="/images/linux/uni.png" alt=""></p>
</blockquote>
<p>　　用户进程无法访问到 Kernel 部分。通常，进程以 User 模式执行，在 User 模式下进程无法执行特权指令，例如无法执行 I/O 操作或者停止处理器。<br>　　进程要怎样才能执行 I/O 操作呢？答案是进程可以执行系统调用 ( System Call )，以切换到 Kernel 模式下，这时由操作系统来执行 I/O 操作，当操作执行结束之后，控制权将转还给进程，这时进程将从 Kernel 模式转换到 User 模式。</p>
<h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p>　　当操作系统同时执行多个进程时，每个进程看起来似乎都独占地使用处理器以及主存。假定计算机仅有一个处理器，那么操作系统为了能同时执行多个进程，则需要在这些进程之间不断的切换，这称为上下文切换( Context Switch )。那么，当操作系统同时执行多个进程时，即使仅有一个处理器，我们也可以说这些进程并发地( Concurrent ) 执行，但不能说它们并行地( Parallel ) 执行。</p>
<hr>
<p>　　系统要怎样判断什么时候执行上下文切换呢？</p>
<ul>
<li>系统可以依据其内部的 timer 定时产生的中断来执行上下文切换。</li>
<li>当内核执行系统调用时，也可能发生上下文切换。例如，系统调用阻塞，以等待特定的事件发生，那么，这时内核可以将控制权切换到另一进程。</li>
</ul>
<h2 id="进程的-ID"><a href="#进程的-ID" class="headerlink" title="进程的 ID"></a>进程的 ID</h2><p>　　操作系统会为每个进程赋予一个唯一的 ID，以此来区分每个进程。在 Linux 中，可以使用<code>getpid()</code>来获得当前进程的 ID, 进程的 ID 永远都是一个非负数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">printf</span>( <span class="string">"Process ID is: %ld\n"</span>, (<span class="keyword">long</span>) getpid() );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　<code>getpid()</code>的返回类型为<code>pid_t</code>，实际上<code>pid_t</code>可能是<code>int</code>或是<code>long</code>，因此我们将其转换成<code>long</code>类型。</p>
<h2 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h2><p>　　在进程中，可以调用<code>fork()</code>来创建子进程，这个新创建的子进程几乎与父进程完全一致。那么，在<code>fork()</code>返回之后，在操作系统中就存在两个几乎一样的进程。子进程拥有和父进程相同的地址空间，另一方面，子进程也拥有和父进程一样的文件描述符，这也就是说子进程也可以访问那些在<code>fork()</code>之前在父进程中打开的文件。最后，我们知道父进程和子进程的 ID 不可能相同。<br>　　我们知道，<code>fork()</code>可以用来创建子进程，那么，很明显，<code>fork()</code>只被调用一次，但能返回两次，一次在父进程，另一次在子进程。在<code>fork()</code>返回之后，父进程和子进程都将执行位于<code>fork()</code>之后的语句，那么，在<code>fork()</code>返回之后，我们想知道是否有方法，可以在程序中区分正在执行的是父进程还是子进程？<br>　　<code>fork()</code>的返回值类型为<code>pid_t</code>，在程序中，可以根据<code>fork()</code>的返回值，来区分正在执行的是父进程还是子进程：</p>
<ul>
<li>在父进程中，<code>fork()</code>将返回子进程的 ID。</li>
<li>在子进程中，<code>fork()</code>将返回 0。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">printf</span>( <span class="string">"Current process ID is: %ld\n"</span>, (<span class="keyword">long</span>) getpid() );</div><div class="line">    <span class="keyword">pid_t</span> pid = fork();</div><div class="line">    <span class="keyword">if</span>( pid &lt; <span class="number">0</span> ) &#123;</div><div class="line">	<span class="built_in">fprintf</span>( <span class="built_in">stderr</span>, <span class="string">"fork error"</span> );</div><div class="line">	<span class="built_in">exit</span>( EXIT_FAILURE );</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( pid == <span class="number">0</span> ) &#123;</div><div class="line">	<span class="built_in">printf</span>( <span class="string">"In child process, ID is %ld\n"</span>, (<span class="keyword">long</span>) getpid() );</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">	<span class="built_in">printf</span>( <span class="string">"In parent process, ID is %ld \n"</span>, (<span class="keyword">long</span>) getpid() );</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　另一方面，假定机器只有一个 CPU，那么在<code>fork()</code>返回之后，是父进程先执行还是子进程先执行？答案是不确定，因为这将取决于 CPU 的调度。</p>
<hr>
<p>　　通常来说，进程有三种状态：</p>
<blockquote>
<p><img src="/images/linux/state.png" alt=""></p>
</blockquote>
<h2 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h2><p>　　进程的正常退出：</p>
<ul>
<li>从<code>main()</code>返回。</li>
<li>调用<code>exit()</code>。</li>
<li>调用<code>_exit()</code>或<code>_Exit()</code>。</li>
<li>最后一个线程退出。</li>
<li>最后一个线程调用<code>pthread_exit()</code>。</li>
</ul>
<p>　　调用<code>_exit()</code>或<code>_Exit()</code>则会立即将控制权返回给内核，而调用<code>exit()</code>则会先执行必要的清除工作，之后再将控制权返回给内核。实际上，在<code>main()</code>调用<code>return</code>语句则相当于调用<code>exit()</code>。</p>
<p>　　进程可以通过<code>atexit()</code>来注册 exit handler，最多可以注册 32 个:<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdlib.h&gt;</div><div class="line"></div><div class="line">int atexit( void (*func) (void) )</div><div class="line">// success on 0</div></pre></td></tr></table></figure></p>
<p>　　程序调用<code>exit()</code>或在<code>main()</code>调用<code>return</code>语句，那么这些 exit handler 将根据它们注册时相反的次序被调用。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">myExit1</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    <span class="built_in">printf</span>( <span class="string">"myExit1()\n"</span> );</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">myExit2</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    <span class="built_in">printf</span>( <span class="string">"myExit2()\n"</span> );</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>( atexit( myExit1 ) != <span class="number">0</span> ) &#123;</div><div class="line">	perror( <span class="string">"atexit()"</span> );</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>( atexit( myExit2 ) != <span class="number">0</span> ) &#123;</div><div class="line">	perror( <span class="string">"atexit()"</span> );</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">myExit2()</div><div class="line">myExit1()</div><div class="line">**/</div></pre></td></tr></table></figure></p>
<p>　　<code>_exit()</code>和<code>_Exit()</code>实际上是一样的，而<code>exit()</code>执行的任务：</p>
<ul>
<li>以相反的次序调用经由<code>atexit()</code>注册的 exit handler。</li>
<li>刷新 stdio 流的缓冲区，并关闭所有标准 I/O 流。</li>
<li>调用<code>_exit()</code>。</li>
</ul>
<p>　　注意到<code>_exit()</code>并不会刷新标准 I/O 流。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">printf</span>( <span class="string">"Hello\n"</span> );</div><div class="line">    write( STDOUT_FILENO, <span class="string">"World\n"</span>, <span class="number">6</span> );</div><div class="line">    <span class="keyword">if</span>( fork() == <span class="number">-1</span> ) &#123;</div><div class="line">	perror( <span class="string">"fork"</span> );</div><div class="line">	<span class="built_in">exit</span>( <span class="number">1</span> );</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　执行程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ ./main</div><div class="line">Hello World</div><div class="line">$ ./main &gt; a</div><div class="line">$ cat a</div><div class="line">World</div><div class="line">Hello</div><div class="line">Hello</div></pre></td></tr></table></figure></p>
<p>　　使用重定向时，输出出现了混乱。标准 I/O 的缓冲区位于进程的 User Space，调用<code>fork()</code>时，则缓冲区也会被拷贝，从标准输出重定向到文件时，使用的是块缓冲，因此，<code>printf()</code>并不会立即将数据写入文件，这样，当两个进程终止时，<code>exit()</code>将刷新缓冲区，则有两个<code>Hello</code>会被写入文件。与此不同，<code>write()</code>是不带缓冲的，因此，<code>for()</code>并不会对<code>write()</code>写入的内容进行拷贝。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.amazon.com/Computer-Systems-Programmers-Perspective-2nd/dp/0136108040/ref=sr_1_2?ie=UTF8&amp;qid=1431613304&amp;sr=8-2&amp;keywords=computer+systems" target="_blank" rel="external">Computer Systems: A Programmer’s Perspective (2nd Edition)</a></li>
<li><a href="http://www.amazon.com/Linux-Programming-Interface-System-Handbook/dp/1593272200/ref=sr_1_1?ie=UTF8&amp;qid=1432537210&amp;sr=8-1&amp;keywords=linux+programming" target="_blank" rel="external">The Linux Programming Interface: A Linux and UNIX System Programming Handbook</a></li>
<li><a href="http://www.amazon.com/Advanced-Programming-UNIX-Environment-3rd/dp/0321637739/ref=sr_1_1?ie=UTF8&amp;qid=1433643440&amp;sr=8-1&amp;keywords=apue" target="_blank" rel="external">Advanced Programming in the UNIX Environment</a></li>
<li><a href="http://www.amazon.com/Operating-Systems-Three-Easy-Pieces-ebook/dp/B00TPZ17O4/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1432537259&amp;sr=1-1&amp;keywords=operating+system+three+easy+pieces" target="_blank" rel="external">Operating Systems: Three Easy Pieces</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/05/14/计算机系统－整数与浮点数/" itemprop="url">
                  计算机系统 -- 整数与浮点数的表示
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-05-14T20:20:44+08:00" content="2015-05-14">
              2015-05-14
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/体系结构/" itemprop="url" rel="index">
                    <span itemprop="name">体系结构</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="字节次序"><a href="#字节次序" class="headerlink" title="字节次序"></a>字节次序</h2><p>　　不同的处理器可能使用不同的字节次序来存储整数，通常存在 Little-Endian 以及 Big-Endian 这两种字节次序。Intel-compatible 处理器使用的是 Little-Endian 字节次序。<br>　　假定存在<code>int x = 0x01234567</code>，并且<code>x</code>的地址为<code>0x100</code>，那么，使用两种不同的字节次序来存放<code>x</code>：<br><img src="/images/data-structure/endian.png" alt=""><br>　　我们知道，<code>x</code>总共占据 4 个字节。可以看到，在 Little-Endian 字节次序里面，这 4 个字节按<strong>反序</strong>存放。</p>
<hr>
<p>　　在某些情况下，我们必须关心处理器使用的是哪一种字节次序。例如，在网络传输里面，在某些情况下需要使用 Big-Endian 作为整数的字节次序，因此，Big-Endian 也称为网络字节次序( Network Byte Order )。<br>　　在编写网络应用程序的时候，有时需要将整数按照网络字节次序存放，可以是两个字节的整数( 例如 <code>uint16_t</code> )，也可以是四个字节的整数（ 例如 <code>uint32_t</code> ）。</p>
<p>　　那么，那要怎样将 Little-Endian 字节次序的整数转换成为 Big-Endian 字节次序的整数呢？反过来呢？<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">uint32_t</span> htonl(<span class="keyword">uint32_t</span> hostlong);      <span class="comment">// host to network long</span></div><div class="line"></div><div class="line"><span class="keyword">uint16_t</span> htons(<span class="keyword">uint16_t</span> hostshort);     <span class="comment">// host to network short</span></div><div class="line"></div><div class="line"><span class="keyword">uint32_t</span> ntohl(<span class="keyword">uint32_t</span> netlong);       <span class="comment">// network to host long </span></div><div class="line"></div><div class="line"><span class="keyword">uint16_t</span> ntohs(<span class="keyword">uint16_t</span> netshort);      <span class="comment">// network to host short</span></div></pre></td></tr></table></figure></p>
<p>　　注意，我们使用主机字节次序( Host Byte Order )，用来表示本地主机的字节次序。那么，<code>htonl()</code>可以将主机字节次序转换成为网络字节次序，也就是说：</p>
<ul>
<li>如果主机使用的是 Little-Endian 字节次序，那么，就将其转换成为 Big-Endian 字节次序。</li>
<li>如果主机使用的是 Big-Endian 字节次序，那么，就保持不变。</li>
</ul>
<p>　　好了，看一下下面的例子，我们使用<code>htonl()</code>将主机字节次序转换成为网络字节次序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *byte_pointer;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_bytes</span><span class="params">( byte_pointer start, <span class="keyword">int</span> len )</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i ) &#123;</div><div class="line">	<span class="built_in">printf</span>( <span class="string">" %.2x"</span>, start[i] );</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">printf</span>( <span class="string">"\n"</span> );</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_int</span><span class="params">( <span class="keyword">uint32_t</span> x )</span> </span>&#123;</div><div class="line">    show_bytes( (byte_pointer) &amp;x, <span class="keyword">sizeof</span>( x ) );</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">uint32_t</span> x = <span class="number">0x01234567</span>;</div><div class="line">    <span class="built_in">printf</span>( <span class="string">"x = %#x\n"</span>, x );</div><div class="line">    <span class="built_in">printf</span>( <span class="string">"Host Byte Order: "</span> );</div><div class="line">    show_int( x );</div><div class="line">    <span class="keyword">uint32_t</span> y = htonl( x );</div><div class="line">    <span class="built_in">printf</span>( <span class="string">"Network Byte Order: "</span> );</div><div class="line">    show_int( y );</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">x = 0x1234567</div><div class="line">Host Byte Order:  67 45 23 01</div><div class="line">Network Byte Order:  01 23 45 67</div><div class="line">**/</div></pre></td></tr></table></figure></p>
<hr>
<p>　　那么，有什么方法可以判断主机使用的是 Little-Endian 还是 Big-Endian 字节次序呢？如下面所示，我们可以编写一个<code>is_big_endian()</code>来判断主机字节次序是否是 Big-Endian 字节次序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *byte_pointer;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_big_endian</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> magic = <span class="number">0x0D0C0B0A</span>;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> verify = *((byte_pointer) &amp;magic);</div><div class="line">    <span class="keyword">return</span> verify == <span class="number">0x0A</span> ? <span class="literal">false</span> : <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>( is_big_endian() ) &#123;</div><div class="line">	<span class="built_in">printf</span>( <span class="string">"Big Endian\n"</span> );</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">	<span class="built_in">printf</span>( <span class="string">"Little Endian\n"</span> );</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line">Little Endian</div><div class="line">*/</div></pre></td></tr></table></figure></p>
<h2 id="整数表示"><a href="#整数表示" class="headerlink" title="整数表示"></a>整数表示</h2><p>　　我们知道，在 C 语言中存在两种类型的<code>int</code>，<code>signed int</code>与<code>unsigned int</code>这两种，为了方便，<code>signed int</code>可以简写成<code>int</code>，而<code>unsigned int</code>可以简写成<code>unsigned</code>。<code>int</code>既可以表示正整数，也可以表示负整数，但是<code>unsigned</code>只能表示正整数。<br>　　除了可以使用<code>int</code>和<code>unsigned</code>来表示整数之外，还可以使用其它类型：</p>
<ul>
<li><code>char</code>和<code>unsigned char</code>，占据 1 个字节。</li>
<li><code>short</code>和<code>unsigned short</code>，占据 2 个字节。</li>
<li><code>int</code>和<code>unsigned int</code>，占据 4 个字节。</li>
<li><code>long</code>和<code>unsigned long</code>，在 32 位的机器上占据 4 个字节，但在 64 位的机器上占据 8 个字节。</li>
<li><code>long long</code>和<code>unsigned long long</code>，占据 8 个字节。</li>
</ul>
<p>　　另一方面，<code>&lt;stdint.h&gt;</code>里面定义了<code>int8_t</code>、<code>int16_t</code>、<code>int32_t</code>和<code>int64_t</code>，以及各自对应的<code>unsigned</code>类型，可以使用这些类型，编写出跨平台的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">printf</span>( <span class="string">"int8_t, %i bytes, range from %i to %i\n"</span>, <span class="keyword">sizeof</span>( <span class="keyword">int8_t</span> ), INT8_MIN, INT8_MAX );</div><div class="line">    <span class="built_in">printf</span>( <span class="string">"int16_t, %i bytes, range from %i to %i\n"</span>, <span class="keyword">sizeof</span>( <span class="keyword">int16_t</span> ), INT16_MIN, INT16_MAX );</div><div class="line">    <span class="built_in">printf</span>( <span class="string">"int32_t, %i bytes, range from %i to %i\n"</span>, <span class="keyword">sizeof</span>( <span class="keyword">int32_t</span> ), INT32_MIN, INT32_MAX );</div><div class="line">    <span class="built_in">printf</span>( <span class="string">"int64_t, %i bytes, range from %lld to %lld\n"</span>, <span class="keyword">sizeof</span>( <span class="keyword">int64_t</span> ), INT64_MIN, INT64_MAX );</div><div class="line">    <span class="built_in">printf</span>( <span class="string">"uint8_t, %i bytes, range from %u to %u\n"</span>, <span class="keyword">sizeof</span>( <span class="keyword">uint8_t</span> ), <span class="number">0</span>, UINT8_MAX );</div><div class="line">    <span class="built_in">printf</span>( <span class="string">"uint16_t, %i bytes, range from %u to %u\n"</span>, <span class="keyword">sizeof</span>( <span class="keyword">uint16_t</span> ), <span class="number">0</span>, UINT16_MAX );</div><div class="line">    <span class="built_in">printf</span>( <span class="string">"uint32_t, %i bytes, range from %u to %u\n"</span>, <span class="keyword">sizeof</span>( <span class="keyword">uint32_t</span> ), <span class="number">0</span>, UINT32_MAX );</div><div class="line">    <span class="built_in">printf</span>( <span class="string">"uint64_t, %i bytes, range from %llu to %llu\n"</span>, <span class="keyword">sizeof</span>( <span class="keyword">int64_t</span> ), <span class="number">0l</span>l, UINT64_MAX );</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line">int8_t, 1 bytes, range from -128 to 127</div><div class="line">int16_t, 2 bytes, range from -32768 to 32767</div><div class="line">int32_t, 4 bytes, range from -2147483648 to 2147483647</div><div class="line">int64_t, 8 bytes, range from -9223372036854775808 to 9223372036854775807</div><div class="line">uint8_t, 1 bytes, range from 0 to 255</div><div class="line">uint16_t, 2 bytes, range from 0 to 65535</div><div class="line">uint32_t, 4 bytes, range from 0 to 4294967295</div><div class="line">uint64_t, 8 bytes, range from 0 to 18446744073709551615</div><div class="line">*/</div></pre></td></tr></table></figure></p>
<h2 id="补码编码"><a href="#补码编码" class="headerlink" title="补码编码"></a>补码编码</h2><p>　　C 语言使用 Two’s-Complement 编码来表示<code>int</code>，在这种编码的指定下，二进制的最高位作为符号位，而由于<code>int</code>占 4 个字节，也就是 32 位，因此，符号位的权重值为 $-2^{31}$。<br>　　同样，<code>char</code>也是使用 Two’s-Complement 编码，例如，<code>char x = 0xFF</code>，用二进制表示就是<code>11111111</code>，那么，<code>x</code>的值就是：$x = -2^7+2^6+2^5+2^4+2^3+2^2+2^1+2^0 = -1$。</p>
<p>　　在 4 位的情况下， Two’s-Complement 编码如下所示：<br><img src="/images/data-structure/kpp.png" alt=""></p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>　　我们知道，<code>int</code>与<code>unsigned</code>使用不同的编码，那么很显然，对于同一个二进制数来说，<code>int</code>和<code>unsigned</code>能分别将这个二进制数解析成不同的整数值，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> x = <span class="number">0xFFFFFFFF</span>;</div><div class="line"><span class="keyword">unsigned</span> y = <span class="number">0xFFFFFFFF</span>;</div><div class="line"><span class="built_in">printf</span>( <span class="string">"x = %i\n"</span>, x );</div><div class="line"><span class="built_in">printf</span>( <span class="string">"y = %u\n"</span>, y );</div><div class="line"><span class="comment">/*</span></div><div class="line">x = -1</div><div class="line">y = 4294967295</div><div class="line">*/</div></pre></td></tr></table></figure></p>
<p>　　知道了这一点，理解<code>int</code>与<code>unsigned</code>之间的类型转换就变得容易得多了，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">short</span> x = <span class="number">-12345</span>;</div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> y = (<span class="keyword">unsigned</span> <span class="keyword">short</span>) x;</div><div class="line"><span class="built_in">printf</span>( <span class="string">"x = %i\n"</span>, x );</div><div class="line"><span class="built_in">printf</span>( <span class="string">"y = %u\n"</span>, y );</div><div class="line"><span class="comment">/*</span></div><div class="line">x = -12345</div><div class="line">y = 53191</div><div class="line">*/</div></pre></td></tr></table></figure></p>
<p>　　可以看到，我们将<code>short</code>变量<code>x</code>转换成为<code>unsigned short</code>变量<code>y</code>了，但注意，<code>x</code>和<code>y</code>其内部的二进制数都是<code>0xCFC7</code>，不同的只是<code>short</code>和<code>unsigned short</code>的编码方式，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">short</span> x = <span class="number">0xCFC7</span>;</div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> y = (<span class="keyword">unsigned</span> <span class="keyword">short</span>) x;</div><div class="line"><span class="built_in">printf</span>( <span class="string">"x = %i\n"</span>, x );</div><div class="line"><span class="built_in">printf</span>( <span class="string">"y = %u\n"</span>, y );</div><div class="line"><span class="comment">/*</span></div><div class="line">x = -12345</div><div class="line">y = 53191</div><div class="line">*/</div></pre></td></tr></table></figure></p>
<p><img src="/images/data-structure/kom.png" alt=""></p>
<hr>
<p>　　在执行整数算术操作时，要是一个操作数是<code>unsigned</code>类型，另一个是<code>int</code>类型，那么，<code>int</code>类型将隐式地转换成为<code>unsigned</code>类型。在执行比较操作的时候尤其需要引起注意，例如<code>-1 &lt; 0U</code>将返回<code>flase</code>，这时因为<code>-1</code>将隐式转换成为一个很大的<code>unsigned</code>类型值。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.amazon.com/Computer-Systems-Programmers-Perspective-2nd/dp/0136108040/ref=sr_1_2?ie=UTF8&amp;qid=1431613304&amp;sr=8-2&amp;keywords=computer+systems" target="_blank" rel="external">Computer Systems: A Programmer’s Perspective (2nd Edition)</a></li>
<li><a href="http://beej.us/guide/bgnet/" target="_blank" rel="external">Beej’s Guide to Network Programming Using Internet Sockets</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/05/10/C-11并发编程五/" itemprop="url">
                  C++11 并发编程（五）-- 条件变量
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-05-10T10:34:50+08:00" content="2015-05-10">
              2015-05-10
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/并发编程/" itemprop="url" rel="index">
                    <span itemprop="name">并发编程</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="条件变量的介绍"><a href="#条件变量的介绍" class="headerlink" title="条件变量的介绍"></a>条件变量的介绍</h2><p>　　我们知道，线程可以使用<code>std::future&lt;&gt;</code>来等待另一线程返回结果（ 或抛出异常 ），但这只能等待一次。有时，线程处于阻塞状态，需要等待其它线程提供某种条件之后，线程才能继续执行，但这个过程可能会反复多次地出现，那么这时，可以使用条件变量。</p>
<hr>
<p>　　在 C++11，条件变量使用<code>std::condition_variable</code>来表示。首先假定存在全局变量：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::mutex mtx;</div><div class="line"><span class="built_in">std</span>::condition_variable cond_var;</div></pre></td></tr></table></figure></p>
<p>　　另外还存在两个线程：</p>
<ul>
<li>一个线程用来等待某种条件：<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; uni_lock( mtx );</div><div class="line">cond_var.wait( uni_lock, predicate );              <span class="comment">// release and reacquire mtx</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>　　注意到，这里使用<code>std::unique_lock&lt;&gt;</code>而不是<code>std::lock_guard&lt;&gt;</code>，这时因为在调用<code>cond_var.wait( uni_lock, predicate );</code>的时候，<code>wait()</code>内部会不断地调用<code>uni_lock.unlock()</code>和<code>uni_lock.lock()</code>来分别释放和持有互斥锁。<br>　　也就是说，在调用条件变量的<code>wait()</code>时候，线程会调用<code>uni_lock.unlock()</code>来释放互斥锁，接着，线程进入阻塞状态（ 沉睡 ），那么，当线程被唤醒的时候，线程就会调用<code>uni_lock.lock()</code>来请求持有互斥锁了。也就是说，线程处于阻塞状态的时候会释放互斥锁，而被唤醒的时候则会持有互斥锁。<br>　　另一方面，调用<code>cond_var.wait( uni_lock, predicate );</code>的作用相当于：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>( !predicate() ) &#123;</div><div class="line">    cond_var.wait( uni_lock );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　你可能觉得奇怪，难道不是另一线程负责判断<code>predicate</code>，然后唤醒当前线程的吗？为什么当前线程需要显式地判断<code>predicate</code>？</p>
<blockquote>
<p><img src="/images/data-structure/cond.png" alt=""></p>
</blockquote>
<hr>
<ul>
<li>一个线程则负责提供某种条件，当条件满足的时候，就调用<code>notify_one()</code>通知（ 唤醒 ）另一线程。<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cond_var.notify_one();               <span class="comment">// notify one of the waiting threads</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>　　另外，调用<code>notify_all()</code>则可以通知其它所有处于等待的线程：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cond_var.notify_all();               <span class="comment">// notify all the waiting threads</span></div></pre></td></tr></table></figure></p>
<hr>
<p>　　好了，一个使用条件变量的简单例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">bool</span> ready;</div><div class="line"><span class="built_in">std</span>::mutex ready_mtx;</div><div class="line"><span class="built_in">std</span>::condition_variable ready_cond;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">provider</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">std</span>::this_thread::sleep_for( <span class="built_in">std</span>::chrono::seconds&#123; <span class="number">5</span> &#125; );</div><div class="line"></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; guard&#123; ready_mtx &#125;;</div><div class="line">        ready = <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    ready_cond.notify_one();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; uni_lock( ready_mtx );</div><div class="line">        ready_cond.wait( uni_lock, [] &#123;  <span class="keyword">return</span> ready;  &#125;);</div><div class="line">    &#125;   <span class="comment">// destruction of uni_lock will unlocks ready_mtx </span></div><div class="line"></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"done!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">std</span>::thread pvi&#123; provider &#125;;</div><div class="line">    <span class="built_in">std</span>::thread csm&#123; consumer &#125;;</div><div class="line">    pvi.join();</div><div class="line">    csm.join();</div><div class="line">        </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="生产者与消费者"><a href="#生产者与消费者" class="headerlink" title="生产者与消费者"></a>生产者与消费者</h2><p>　　条件变量的一个重要作用就是应用在生产者消费者模型里面，因为在这种模型里面，生产者线程需要不断地通知消费者线程。我们可以使用一个消息队列来传递消息：</p>
<ul>
<li>每次生产者线程将新的消息入列之后，就通知消费者线程。</li>
<li>当队列为空的时候，消费者线程就（ 处于阻塞状态 ）等待生产者线程提供新的消息。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; messageQueue;</div><div class="line">mutex queue_mtx;</div><div class="line">mutex print_mtx;</div><div class="line">condition_variable queue_cond;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">provider</span><span class="params">( <span class="keyword">int</span> product_num, <span class="keyword">int</span> wait_seconds )</span> </span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; product_num; ++i ) </div><div class="line">    &#123;</div><div class="line">        <span class="function"><span class="built_in">string</span> <span class="title">message</span><span class="params">( <span class="string">"Message-"</span> )</span></span>;</div><div class="line">        message.append( to_string( i ) );</div><div class="line">        &#123;</div><div class="line">            lock_guard&lt;mutex&gt; guard( queue_mtx );</div><div class="line">            messageQueue.push( <span class="built_in">std</span>::move( message ) );</div><div class="line">        &#125;</div><div class="line">        queue_cond.notify_one();</div><div class="line">        this_thread::sleep_for( chrono::seconds( wait_seconds ) );</div><div class="line">    &#125;</div><div class="line">    lock_guard&lt;mutex&gt; guard( print_mtx );</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"All works done!"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">( <span class="keyword">int</span> consumer_id )</span> </span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">while</span>( <span class="literal">true</span> ) </div><div class="line">    &#123;</div><div class="line">        <span class="built_in">string</span> message;</div><div class="line">        &#123;</div><div class="line">            unique_lock&lt;mutex&gt; uni_lock( queue_mtx );</div><div class="line">            queue_cond.wait( uni_lock, [] &#123;  <span class="keyword">return</span> !messageQueue.empty();  &#125; );</div><div class="line">            message = messageQueue.front();</div><div class="line">            messageQueue.pop();</div><div class="line">        &#125;</div><div class="line">        &#123;</div><div class="line">            lock_guard&lt;mutex&gt; guard( print_mtx );</div><div class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"consumer-"</span> &lt;&lt; consumer_id &lt;&lt; <span class="string">" receive: "</span> &lt;&lt; message &lt;&lt; <span class="built_in">endl</span>; </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    thread pvi&#123; provider, <span class="number">20</span>, <span class="number">1</span> &#125;;</div><div class="line">    thread csm1&#123; consumer, <span class="number">1</span> &#125;;</div><div class="line">    thread csm2&#123; consumer, <span class="number">2</span> &#125;;</div><div class="line">    pvi.join();</div><div class="line">    csm1.join();</div><div class="line">    csm2.join();</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　我们使用一个生产者线程，两个消费者线程。在<code>provider()</code>里面，使用<code>queue_cond.notify_one();</code>来唤醒消费者线程，需要注意的一点是，这条语句<strong>不需要</strong>加锁。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="www.amazon.com/gp/product/0321563840/ref=s9_simh_gw_p14_d0_i4?pf_rd_m=ATVPDKIKX0DER&amp;pf_rd_s=desktop-1&amp;pf_rd_r=1K1091VGJG234NP5NA8T&amp;pf_rd_t=36701&amp;pf_rd_p=1970559082&amp;pf_rd_i=desktop">The C++ Programming Language 4th Edition</a></li>
<li><a href="http://book.douban.com/subject/10440485/" target="_blank" rel="external">The C++ Standard Library Second Edition</a></li>
<li><a href="http://book.douban.com/subject/4130141/" target="_blank" rel="external">C++ Concurrency in Action</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/05/08/c-11并发编程四/" itemprop="url">
                  C++11 并发编程（四）-- 内存模型
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-05-08T19:54:46+08:00" content="2015-05-08">
              2015-05-08
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/并发编程/" itemprop="url" rel="index">
                    <span itemprop="name">并发编程</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="读写数据"><a href="#读写数据" class="headerlink" title="读写数据"></a>读写数据</h2><p>　　基本数据类型，例如 bool、char、int 或 long 等类型， C++11 并<strong>没有</strong>保证对这些类型的 read 或 write 操作是原子的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">global variable:     <span class="keyword">long</span> <span class="keyword">long</span> x = <span class="number">0</span>;</div><div class="line">  </div><div class="line">Thread <span class="number">1</span>:                       Thread <span class="number">2</span>:</div><div class="line">x = <span class="number">10</span>;                         <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x;</div></pre></td></tr></table></figure></p>
<p>　　全局变量<code>x</code>在两个线程之间共享，我们知道，语句<code>x = 10;</code>并不是原子的，因此，在 C++11 中，语句<code>std::cout &lt;&lt; x;</code>的行为是<strong>未定义</strong>的。</p>
<hr>
<p>　　C++11 提供了<code>std::atomic&lt;&gt;</code>，用来表示原子，因此，可以这样做：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">global variable:     <span class="built_in">std</span>::atomic&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; x&#123;<span class="number">0</span>&#125;;</div><div class="line">		  </div><div class="line">Thread <span class="number">1</span>:                       Thread <span class="number">2</span>:</div><div class="line">x.store(<span class="number">10</span>);                    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x.load();</div></pre></td></tr></table></figure></p>
<p>　　好了，现在这种行为是有定义的：</p>
<ul>
<li>要是 Thread 1 先于 Thread 2 执行，那么，程序将输出 10。</li>
<li>要是 Thread 2 先于 Thread 1 执行，那么，程序将输出 0。</li>
</ul>
<h2 id="内存位置"><a href="#内存位置" class="headerlink" title="内存位置"></a>内存位置</h2><p>　　我们知道，当<strong>同一数据</strong>在多个线程之间共享时，若存在某一线程需要更新数据的值，那么，这些线程在访问共享数据时都需要使用特定的机制来进行<strong>同步访问</strong>。<br>　　那么，考虑另一个问题，当多个线程访问<strong>不同的</strong>共享数据时，那么，情况是怎样的？</p>
<hr>
<blockquote>
<p><strong>The C++ memory model</strong> guarantees that two threads of execution can update and access separate<br>memory locations without interfering with each other.<br>　　　　　　　　　　　　　　　　　　　　————  <em>The C++ Programming Language 4th Edition</em></p>
<hr>
</blockquote>
<p>　　好了，考虑下面的例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">global variable:</div><div class="line">               <span class="keyword">char</span> a = <span class="number">0</span>;</div><div class="line">               <span class="keyword">char</span> b = <span class="number">0</span>;</div><div class="line">  </div><div class="line">Thread <span class="number">1</span>:                       Thread <span class="number">2</span>:</div><div class="line">a = <span class="number">1</span>;                          b = <span class="number">1</span>;</div><div class="line"><span class="keyword">int</span> x = a;                      <span class="keyword">int</span> y = b;</div></pre></td></tr></table></figure></p>
<p>　　我们知道，char 类型占据一个字节，在 32 位的机器，一个 word 的大小是 4 个字节，而在 64 位的机器，则是 8 个字节。那么，有没有可能<code>a</code>和<code>b</code>都位于同一个 word 上面，从而共享同一个内存位置（ memory location ）？<br>　　答案是不可能，两个 char 都拥有其各自的内存位置。C++ 内存模型指定，对于基本类型来说，例如 int 或 char 等，无论它们占据几个字节，它们都确切地拥有一个内存位置。<br>　　一种特殊的情况就是位字段（ bit field ） ，我们知道，多个位字段可能占据同一个 word，因此，它们可以共享同一个内存位置，例如以下的例子：<br><img src="/images/data-structure/ml.png" alt=""><br>　　很明显，<code>bf1</code>和<code>bf2</code>占据同一个 word，因此它们同享同一内存位置。要是存在线程需要修改<code>bf1</code>，同时另一线程需要修改<code>bf2</code>，由于<code>bf1</code>和<code>bf2</code>共享同一内存位置，那么，这种行为是<strong>未定义</strong>的，也就是说，需要显示使用某些机制（ 例如互斥锁 ），使得对<code>bf1</code>和<code>bf2</code>的修改不会同时发生（ 需要具有一定的先后次序 ）。</p>
<h2 id="语句乱序"><a href="#语句乱序" class="headerlink" title="语句乱序"></a>语句乱序</h2><p>　　假定有全局变量<code>data</code>以及<code>readyFlag</code>，Thread 1 负责提供<code>data</code>的值，同时将<code>readyFlag</code>设置成<code>ture</code>，那么，要是 Thread 2 发现<code>readyFlag</code>的值为<code>true</code>，说明 Thread 1 已经提供了<code>data</code>，这样，Thread 2 就会调用<code>processData()</code>来处理<code>data</code>了：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">global variable:</div><div class="line">               <span class="keyword">long</span> data = <span class="number">0</span>;</div><div class="line">               <span class="keyword">bool</span> readyFlag = <span class="literal">false</span>;</div><div class="line">  </div><div class="line">Thread <span class="number">1</span>:                       Thread <span class="number">2</span>:</div><div class="line">                                <span class="keyword">while</span>( !readyFlag ) &#123;</div><div class="line">data = <span class="number">100</span>;                         ;</div><div class="line">readyFlag = <span class="literal">true</span>;               &#125;</div><div class="line">                                processData( data );</div></pre></td></tr></table></figure></p>
<p>　　注意，编译器产生的汇编代码里面，语句的执行的次序<strong>并不保证</strong>与 C++ 源程序的语句次序一致。注意到，<code>data</code>和<code>readyFlag</code>二者之间并没有特定的联系，因此，Thread 1 中，语句实际的执行次序可能是：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">readyFlag = <span class="literal">true</span>;</div><div class="line">data = <span class="number">100</span>;</div></pre></td></tr></table></figure></p>
<p>　　设想，要是 Thread 1 执行了第一条语句，但还没有执行第二条语句，也就是说，<code>readyFlag</code>的值设置为<code>true</code>，但<code>data</code>的值还是保持为 0，在这种情况下，数据就是不正确的。因为这时 Thread 2 可能访问到<code>readyFlag</code>，并调用<code>processData()</code>来处理<code>data</code>，但 Thread 1 还没有提供<code>data</code>的值。<br>　　另一方面，即使 Thread 1 的语句的次序没有改变，但是，Thread 2 的语句的次序也可能改变：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">processData( data );</div><div class="line"><span class="keyword">while</span>( !readyFlag ) &#123;</div><div class="line">    ;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　很明显，这是错误的，因为在 Thread 2 处理了<code>data</code>之后，这时<code>readyFlag</code>的值可能还是<code>false</code>。</p>
<h2 id="内存次序"><a href="#内存次序" class="headerlink" title="内存次序"></a>内存次序</h2><blockquote>
<p><strong>Memory ordering</strong> is the term used to describe what a programmer can assume about what a thread sees<br>when it looks at a value from memory.　　　　　<em>The C++ Programming Language 4th Edition</em></p>
</blockquote>
<hr>
<p>　　最简单的内存次序称为 sequentially consistent，这种内存次序指明，在一个线程里面，原子操作将按照编程时指定的次序执行。<code>std::atomic&lt;&gt;</code>不仅代表原子，另一方面还保证了 sequentially consistent 的内存次序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">global variable:</div><div class="line">               <span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; a&#123;<span class="number">0</span>&#125;;</div><div class="line">               <span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; b&#123;<span class="number">0</span>&#125;;</div><div class="line">  </div><div class="line">Thread <span class="number">1</span>:                       Thread <span class="number">2</span>:</div><div class="line">a.store(<span class="number">1</span>);                     b.store(<span class="number">1</span>);</div><div class="line"><span class="keyword">int</span> x = b.load();               <span class="keyword">int</span> y = a.load();</div></pre></td></tr></table></figure></p>
<p>　　在 Thread 1 和 Thread 2 各自的线程中，语句将按照源程序的语句次序执行。那么，有以下 3 种执行次序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">a = <span class="number">1</span>            a = <span class="number">1</span>             b = <span class="number">1</span></div><div class="line">x = b            b = <span class="number">1</span>             y = a</div><div class="line">b = <span class="number">1</span>            x = b             a = <span class="number">1</span></div><div class="line">y = a            y = a             x = b</div></pre></td></tr></table></figure></p>
<p>　　那么，这三种情况下，<code>x</code>和<code>y</code>的值分别是 (0, 1)、(1, 1) 和 (1, 0)，很明显，按照 sequentially consistent 的内存次序，<code>x</code>和<code>y</code>的值<strong>不可能是</strong> (0, 0)。</p>
<hr>
<p>　　好了，让我们看一下<code>std::atomic&lt;&gt;</code>的<code>store()</code>以及<code>load()</code>成员函数的作用：</p>
<blockquote>
<p><img src="/images/data-structure/kkkk.png" alt=""></p>
</blockquote>
<p>　　一般来说，比起使用<code>std::mutex&lt;&gt;</code>来说，使用<code>std::atomic&lt;&gt;</code>带来的开销比较小：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">long</span> <span class="keyword">long</span> data;</div><div class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; readyFlag&#123; <span class="literal">false</span> &#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">provider</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">std</span>::this_thread::sleep_for( <span class="built_in">std</span>::chrono::seconds&#123; <span class="number">5</span> &#125; );</div><div class="line">    data = <span class="number">100l</span>l;</div><div class="line">    readyFlag.store( <span class="literal">true</span> );</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">processData</span><span class="params">( <span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> &amp;value )</span> </span>&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\nvalue: "</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">while</span>( !readyFlag.load() ) &#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>.put(<span class="string">'.'</span>).flush();</div><div class="line">        <span class="built_in">std</span>::this_thread::yield();        <span class="comment">// hint to reschedule to the next thread</span></div><div class="line">        <span class="built_in">std</span>::this_thread::sleep_for( <span class="built_in">std</span>::chrono::milliseconds( <span class="number">500</span> ) );</div><div class="line">    &#125;</div><div class="line">    processData( data );</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">std</span>::thread pvi&#123; provider &#125;;</div><div class="line">    <span class="built_in">std</span>::thread csm&#123; consumer &#125;;</div><div class="line">    pvi.join();</div><div class="line">    csm.join();</div><div class="line">        </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　注意到<code>readyFlag</code>的类型是<code>std::atomic&lt;bool&gt;</code>，可以保证当程序打算执行<code>readyFlag.store(true);</code>的时候，<code>data</code>已经完成了赋值。<br>　　另一方面，我们知道，在<code>consumer()</code>里面，<code>processData(data);</code>发生在<code>readyFlag.load()</code>之后，因此，只有当<code>readyFlag</code>的值为<code>true</code>的时候，<code>processData(data);</code>才会执行。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://stackoverflow.com/questions/6319146/c11-introduced-a-standardized-memory-model-what-does-it-mean-and-how-is-it-g" target="_blank" rel="external">StackOverflow: C++11 introduced a standardized memory model. What does it mean? </a></li>
<li><a href="www.amazon.com/gp/product/0321563840/ref=s9_simh_gw_p14_d0_i4?pf_rd_m=ATVPDKIKX0DER&amp;pf_rd_s=desktop-1&amp;pf_rd_r=1K1091VGJG234NP5NA8T&amp;pf_rd_t=36701&amp;pf_rd_p=1970559082&amp;pf_rd_i=desktop">The C++ Programming Language 4th Edition</a></li>
<li><a href="http://book.douban.com/subject/10440485/" target="_blank" rel="external">The C++ Standard Library Second Edition</a></li>
<li><a href="http://book.douban.com/subject/4130141/" target="_blank" rel="external">C++ Concurrency in Action</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/05/08/C-11并发编程三/" itemprop="url">
                  C++11 并发编程（三）-- 数据竞争与线程同步
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-05-08T09:51:32+08:00" content="2015-05-08">
              2015-05-08
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/并发编程/" itemprop="url" rel="index">
                    <span itemprop="name">并发编程</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="数据竞争"><a href="#数据竞争" class="headerlink" title="数据竞争"></a>数据竞争</h2><p>　　多个线程有时需要访问同一共享数据，通常将共享数据将作为全局变量。那么，有两种情况需要考虑：</p>
<ul>
<li>如果这些线程只是读取共享的数据，很显然，数据可以安全地在这些线程之间共享。</li>
<li>另一方面，当多个线程需要同时访问共享数据，要是至少存在一个线程会对共享数据执行写入操作，那么，这些线程就需要同步访问共享数据，否则，共享数据就会遭到破坏。</li>
</ul>
<p>　　一个常见的例子，例如，<code>std::cout</code>就是一个全局对象，在多个线程中同时访问<code>std::cout</code>，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">// sleep the current thread for specify seconds</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sleep_seconds</span><span class="params">( <span class="keyword">int</span> seconds )</span> </span>&#123;</div><div class="line">    <span class="built_in">std</span>::this_thread::sleep_for( <span class="built_in">std</span>::chrono::seconds&#123; seconds &#125; );</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">task</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i ) &#123;</div><div class="line">        sleep_seconds( <span class="number">1</span> );          <span class="comment">// sleep the current thread for 1 second</span></div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Thread-"</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">": "</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">std</span>::thread t1&#123; task &#125;;</div><div class="line">    <span class="built_in">std</span>::thread t2&#123; task &#125;;</div><div class="line">    t1.join();</div><div class="line">    t2.join();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　这里存在多个线程同时利用<code>std::cout</code>向控制台输出信息，那么，这些信息就会交错在一起，程序的输出：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Thread-Thread-3074345792: 03065953088: 0</div><div class="line"></div><div class="line">Thread-3074345792: 1</div><div class="line">Thread-3065953088: 1</div><div class="line">Thread-3074345792: 2</div><div class="line">Thread-3065953088: 2</div><div class="line">Thread-Thread-3074345792: 30659530883: </div><div class="line">3</div><div class="line">Thread-Thread-3074345792: 43065953088: </div><div class="line">4</div></pre></td></tr></table></figure></p>
<h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p>　　<code>std::mutex</code>表示互斥锁，顾名思义，在同一时间，只有一个线程可以持有互斥锁。显然，要是互斥锁正被一个线程所持有，那么，其它请求持有这个互斥锁的线程都将处于阻塞状态。只有互斥锁被释放的时候，其它线程才有可能持有这个互斥锁。<br>　　可以调用<code>std::mutex</code>的<code>lock()</code>来请求持有互斥锁，另一方面，调用<code>std::mutex</code>的<code>unlock()</code>则可以释放互斥锁。这样，我们可以使用<code>std::mutex</code>来改写之前的例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></div><div class="line"></div><div class="line"><span class="built_in">std</span>::mutex printMutex;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sleep_seconds</span><span class="params">( <span class="keyword">int</span> seconds )</span> </span>&#123;</div><div class="line">    <span class="built_in">std</span>::this_thread::sleep_for( <span class="built_in">std</span>::chrono::seconds&#123; seconds &#125; );</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">task</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i ) &#123;</div><div class="line">        sleep_seconds( <span class="number">1</span> );</div><div class="line">        printMutex.lock();</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Thread-"</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">": "</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">        printMutex.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">std</span>::thread t1&#123; task &#125;;</div><div class="line">    <span class="built_in">std</span>::thread t2&#123; task &#125;;</div><div class="line">    t1.join();</div><div class="line">    t2.join();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　考虑另一个问题，在调用<code>std::mutex</code>的<code>lock()</code>和<code>unlock()</code>之间，要是程序抛出了异常，那么，<code>std::mutex</code>可能永远无法被解锁( unlockd )，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::mutex mutex;</div><div class="line">Widget shared_resource;</div><div class="line"><span class="comment">// ...</span></div><div class="line">&#123;</div><div class="line">    mutex.lock();</div><div class="line">    might_throw( shared_resource );</div><div class="line">    <span class="comment">// might throw exception, cause std::mutex be locked forever</span></div><div class="line">    mutex.unlock();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　我们可以使用<code>std::lock_guard&lt;&gt;</code>来保证<code>std::mutex</code>始终会被解锁，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::mutex mutex;</div><div class="line">Widget shared_resource;</div><div class="line"><span class="comment">// ...</span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; guard;</div><div class="line">    might_throw( shared_resource );</div><div class="line">    <span class="comment">// OK: even throw exception, destructor of guard will always unlock the std::mutex</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　即使<code>might_throw()</code>抛出异常，这段代码也是安全的，这是因为，<code>std::lock_guard&lt;std::mutex&gt;&gt;</code>的构造函数会自动调用<code>std::mutex</code>的<code>lock()</code>，而析构函数会自动调用<code>std::mutex</code>的<code>unlock()</code>。<br>　　好了，让我们使用<code>std::lock_guard&lt;&gt;</code>来完善前面的例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></div><div class="line"></div><div class="line"><span class="built_in">std</span>::mutex printMutex;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sleep_seconds</span><span class="params">( <span class="keyword">int</span> seconds )</span> </span>&#123;</div><div class="line">    <span class="built_in">std</span>::this_thread::sleep_for( <span class="built_in">std</span>::chrono::seconds&#123;seconds&#125; );</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">task</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i ) &#123;</div><div class="line">        sleep_seconds( <span class="number">1</span> );          </div><div class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; mutex_guard( printMutex );</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Thread-"</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">": "</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">std</span>::thread t1&#123; task &#125;;</div><div class="line">    <span class="built_in">std</span>::thread t2&#123; task &#125;;</div><div class="line">    t1.join();</div><div class="line">    t2.join();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p>　　我们知道，<code>std::lock_guard&lt;&gt;</code>总是持有互斥锁，当<code>std::lock_guard&lt;&gt;</code>被析构的时候，其持有的互斥锁才会被释放。另一方面，当<code>std::lock_guard&lt;&gt;</code>的构造函数会请求持有互斥锁，要是无法持有互斥锁，那么，当前线程就会处于阻塞状态。<br>　　标准库还提供了<code>std::unique_lock&lt;&gt;</code>，与<code>std::lock_guard&lt;&gt;</code>不同的是：</p>
<ul>
<li><code>std::unique_lock&lt;&gt;</code>可以持有互斥锁，也可以不持有，可以调用其成员<code>owns_lock()</code>或<code>operator bool()</code>来判断。</li>
<li><p>将<code>std::try_to_lock</code>传递给<code>std::unique_lock&lt;&gt;</code>的构造函数，那么，当<code>std::unique_lock&lt;&gt;</code>请求持有互斥锁的时候，要是无法持有互斥锁，当前线程并不会处于阻塞状态。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::mutex mutex;</div><div class="line"><span class="comment">// ...</span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock( mutex, <span class="built_in">std</span>::try_to_lock );</div><div class="line">    <span class="keyword">if</span>( lock ) &#123;</div><div class="line">        <span class="comment">// if lock was successful</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// if lock was failed</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>将<code>std::defer_lock</code>传递给<code>std::unique_lock&lt;&gt;</code>的构造函数，表示在构造的时候，不想持有互斥锁：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::mutex mutex;</div><div class="line"><span class="comment">// ...</span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock( mutex, <span class="built_in">std</span>::defer_lock );    </div><div class="line">    lock.lock();      <span class="comment">// after some while, we want to lock the mutex</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>调用<code>std::unique_lock&lt;&gt;</code>的<code>release()</code>成员函数，返回一个指向互斥锁的指针，同时不再拥有这个互斥锁。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::mutex mutex;</div><div class="line"><span class="comment">// ...</span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock( mutex );    </div><div class="line">    <span class="built_in">std</span>::mutex *m = lock.release();   <span class="comment">// release the ownship of the mutex</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://theboostcpplibraries.com/boost.thread" target="_blank" rel="external">The Boost C++ Libraries: Chapter 44. Boost.Thread</a></li>
<li><a href="www.amazon.com/gp/product/0321563840/ref=s9_simh_gw_p14_d0_i4?pf_rd_m=ATVPDKIKX0DER&amp;pf_rd_s=desktop-1&amp;pf_rd_r=1K1091VGJG234NP5NA8T&amp;pf_rd_t=36701&amp;pf_rd_p=1970559082&amp;pf_rd_i=desktop">The C++ Programming Language 4th Edition</a></li>
<li><a href="http://book.douban.com/subject/10440485/" target="_blank" rel="external">The C++ Standard Library Second Edition</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/05/06/C-11并发编程二/" itemprop="url">
                  C++11 并发编程（二）-- 线程间通信
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-05-06T20:39:17+08:00" content="2015-05-06">
              2015-05-06
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/并发编程/" itemprop="url" rel="index">
                    <span itemprop="name">并发编程</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="简单的传参方式"><a href="#简单的传参方式" class="headerlink" title="简单的传参方式"></a>简单的传参方式</h2><p>　　更多时候，线程所执行的任务要求能够返回某些特定的值，例如，假定线程执行的是计算性的任务，那么，线程就要求能够返回计算的结果。<br>　　实现线程间通信的最简单方式，就是传递特定的参数给线程。例如，假定线程需要对输入数据进行计算，那么，可以将输入数据按 const reference 传递给线程，同时将指向 result 存放位置的指针，也传递给线程：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">accumulate_doubles</span><span class="params">( <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; &amp;vec, <span class="keyword">double</span> *result )</span> </span>&#123;</div><div class="line">    *result = accumulate( vec.cbegin(), vec.cend(), <span class="number">0.0</span> );</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; vec = &#123; <span class="number">1.1</span>, <span class="number">1.2</span>, <span class="number">1.3</span>, <span class="number">1.4</span>, <span class="number">1.5</span> &#125;;</div><div class="line">    <span class="keyword">double</span> result;</div><div class="line">    thread t&#123; accumulate_doubles, cref( vec ), &amp;result &#125;;</div><div class="line">    t.join();</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The result is "</span> &lt;&lt; result &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line">The result is 6.5</div><div class="line">*/</div></pre></td></tr></table></figure></p>
<p>　　但是，通过这种简单的传参方式来返回线程的计算结果，只有在没有数据竞争的条件下才是可行的。</p>
<h2 id="future-与-promise"><a href="#future-与-promise" class="headerlink" title="future 与 promise"></a>future 与 promise</h2><p>　　如果我们需要在不同的线程之间传递某些值，同时又不想引起数据竞争，那么，可以使用 future 和 promise。future 和 promise 的内部均包含一个指针，指向同一个 shared state，很明显，这个 shared state 必须位于 heap 上：<br><img src="/images/data-structure/promise.png" alt=""></p>
<p>　　首先，假定我们从线程<code>task1</code>中启动另一线程<code>task2</code>，并且需要从<code>task2</code>返回一个值（或者异常）给<code>task1</code>，那么，可以这样做：</p>
<ul>
<li>在<code>task1</code>中，创建一个<code>std::promise&lt;T&gt;</code>，其<code>get_future()</code>成员函数将返回一个<code>std::future&lt;T&gt;</code>，那么，利用<code>std::promise&lt;T&gt;</code>和<code>std::future&lt;T&gt;</code>，我们就可以将<code>task2</code>的返回值传递给<code>task1</code>了。</li>
<li>我们将<code>std::promise&lt;T&gt;</code>传递给线程<code>task2</code>，<code>T</code>表示线程<code>task2</code>返回值的类型。由于<code>std::promise&lt;T&gt;</code>是不可以 copy 的，因此，可以按 pass by reference 或<code>std::move()</code>的方式来传递<code>std::promise&lt;T&gt;</code>。</li>
<li>当<code>task2</code>执行的计算任务结束时，我们可以将<code>task2</code>的返回值传递给<code>std::promise&lt;T&gt;</code>的<code>set_value()</code>，或者将异常传递给<code>std::promise&lt;T&gt;</code>的<code>set_exception()</code>。这样，<code>task2</code>的返回值或者异常，将会自动保存到<code>std::promise&lt;T&gt;</code>所指向的 shared state 中。</li>
<li>在<code>task1</code>中，我们可以调用<code>std::future&lt;T&gt;</code>的<code>get()</code>，来访问存储在 shared state 中的值或者异常。</li>
</ul>
<p>　　先看看一个简单的程序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">safe_divide</span><span class="params">( <span class="keyword">double</span> left, <span class="keyword">double</span> right, <span class="built_in">std</span>::promise&lt;<span class="keyword">double</span>&gt; &amp;p )</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">if</span>( right == <span class="number">0.0</span> ) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error( <span class="string">"can't divided by zero!"</span> );</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">double</span> result = left / right;</div><div class="line">        p.set_value( <span class="built_in">std</span>::move( result ) );</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span>( ... ) &#123;</div><div class="line">        p.set_exception( <span class="built_in">std</span>::current_exception() );</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">std</span>::promise&lt;<span class="keyword">double</span>&gt; prms;</div><div class="line">    <span class="built_in">std</span>::future&lt;<span class="keyword">double</span>&gt; ftr = prms.get_future();</div><div class="line">    <span class="keyword">double</span> left = <span class="number">20.0</span>, right = <span class="number">0.0</span>;</div><div class="line">    <span class="built_in">std</span>::thread t&#123; safe_divide, left, right, <span class="built_in">std</span>::ref( prms ) &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;    </div><div class="line">        <span class="keyword">auto</span> result = ftr.get();</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; left &lt;&lt; <span class="string">" / "</span> &lt;&lt; right &lt;&lt; <span class="string">" = "</span> &lt;&lt; result &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#125; <span class="keyword">catch</span>( <span class="keyword">const</span> <span class="built_in">std</span>::exception &amp;e ) &#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"EXCEPTION: "</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">    t.join();</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line">EXCEPTION: can't divided by zero!</div><div class="line">*/</div></pre></td></tr></table></figure></p>
<p>　　这里有一个问题，在<code>std::promise&lt;T&gt;</code>调用<code>set_value()</code>或<code>set_exception()</code>之前，要是<code>std::future&lt;T&gt;</code>已经调用了<code>get()</code>，那么会出现什么情况？<br>　　答案是，<code>get()</code>会使当前线程处于阻塞状态，直到 shared state 的状态变成 ready 为止。很明显，当<code>std::promise&lt;T&gt;</code>调用了<code>set_value()</code>或者是<code>set_exception()</code>之后，shared state 就会变成 ready 状态。</p>
<h2 id="packaged-task"><a href="#packaged-task" class="headerlink" title="packaged_task"></a>packaged_task</h2><p>　　我们知道，每次我们将<code>std::promise&lt;T&gt;</code>传递给线程，以便将线程的返回值或者异常保存到<code>std::promise&lt;T&gt;</code>指向的 shared state 中，但这个过程既繁琐又无趣。<br>　　很好，标准库提供了<code>std::packaged_task&lt;&gt;</code>来简化这个过程。<code>std::packaged_task&lt;&gt;</code>用来对线程所要执行的任务进行封装，例如，对于以下的任务：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">safe_divide</span><span class="params">( <span class="keyword">double</span> left, <span class="keyword">double</span> right )</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>( right == <span class="number">0.0</span> ) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error( <span class="string">"can't divided by zero!"</span> );</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> left / right;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　我们可以创建一个<code>std::packaged_task&lt;&gt;</code>来封装这个任务：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::packaged_task&lt;<span class="keyword">decltype</span>(safe_divide)&gt; task&#123; safe_divide &#125;;</div></pre></td></tr></table></figure></p>
<p>　　我们知道，<code>safe_divide()</code>的返回值类型是<code>double</code>，那么，<code>std::packaged_task&lt;&gt;</code>内部就会包含了一个<code>std::promise&lt;double&gt;</code>。当<code>safe_divide()</code>返回的时侯，<code>std::packaged_task&lt;&gt;</code>会调用<code>std::promise&lt;double&gt;</code>的成员函数<code>set_value()</code>，自动将<code>safe_divide()</code>的返回值设置到 shared state 中。<br>　　另一方面，要是<code>safe_divide()</code>抛出异常，<code>std::packaged_task&lt;&gt;</code>会调用<code>std::promise&lt;double&gt;</code>的<code>set_exception()</code>，自动将异常设置到 shared state 中。<br><img src="/images/data-structure/promise2.png" alt=""><br>　　同样，<code>std::packaged_task&lt;&gt;</code>提供了<code>get_future()</code>，通过其内部的<code>std::promise&lt;double&gt;</code>来返回一个<code>std::future&lt;double&gt;</code>对象。<br>　　显然，通过<code>std::packaged_task&lt;&gt;</code>可以大大简化线程之间传值的工作。一个明显的优势就是，<code>safe_divide()</code>不再需要自己处理<code>std::promise&lt;double&gt;</code>了，因为一切繁琐的工作都交给了<code>std::packaged_task&lt;&gt;</code>了。</p>
<hr>
<p>　　使用<code>std::packaged_task&lt;&gt;</code>，可以将上面的程序进行简化，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">safe_divide</span><span class="params">( <span class="keyword">double</span> left, <span class="keyword">double</span> right )</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>( right == <span class="number">0.0</span> ) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error( <span class="string">"can't divided by zero!"</span> );</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> left / right;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">std</span>::packaged_task&lt;<span class="keyword">decltype</span>(safe_divide)&gt; task&#123; safe_divide &#125;;</div><div class="line">    <span class="built_in">std</span>::future&lt;<span class="keyword">double</span>&gt; ftr = task.get_future();</div><div class="line">    <span class="keyword">double</span> left = <span class="number">20.0</span>, right = <span class="number">0.0</span>;</div><div class="line"></div><div class="line">    <span class="built_in">std</span>::thread t&#123; <span class="built_in">std</span>::move( task ), left, right &#125;;     <span class="comment">// <span class="doctag">NOTE:</span> task can't be copy but can move</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">auto</span> result = ftr.get();</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; left &lt;&lt; <span class="string">" / "</span> &lt;&lt; right &lt;&lt; <span class="string">" = "</span> &lt;&lt; result &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#125; <span class="keyword">catch</span>( <span class="keyword">const</span> <span class="built_in">std</span>::exception &amp;e ) &#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"EXCEPTION: "</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">    t.join();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　注意到，<code>std::packaged_task&lt;&gt;</code>内部包含了<code>std::promise&lt;T&gt;</code>，也就是说，<code>std::packaged_task&lt;&gt;</code>不能被 copy，但可以被<code>std::move()</code>。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://theboostcpplibraries.com/boost.thread" target="_blank" rel="external">The Boost C++ Libraries: Chapter 44. Boost.Thread</a></li>
<li><a href="www.amazon.com/gp/product/0321563840/ref=s9_simh_gw_p14_d0_i4?pf_rd_m=ATVPDKIKX0DER&amp;pf_rd_s=desktop-1&amp;pf_rd_r=1K1091VGJG234NP5NA8T&amp;pf_rd_t=36701&amp;pf_rd_p=1970559082&amp;pf_rd_i=desktop">The C++ Programming Language 4th Edition</a></li>
<li><a href="http://book.douban.com/subject/10440485/" target="_blank" rel="external">The C++ Standard Library Second Edition</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/05/03/高效C-11-关联容器使用细节/" itemprop="url">
                  高效 C++11 -- 关联容器使用技巧
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-05-03T14:38:06+08:00" content="2015-05-03">
              2015-05-03
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/编程语言/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="元素相等性"><a href="#元素相等性" class="headerlink" title="元素相等性"></a>元素相等性</h2><p>　　set 和 map 中元素是按升序排列的，其底层实现是红黑树：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt; <span class="keyword">class</span> T, <span class="keyword">class</span> Compare = <span class="built_in">std</span>::less&lt;T&gt;, <span class="keyword">class</span> Alloc = <span class="built_in">std</span>::allocator&lt;T&gt;&gt;    </div><div class="line"><span class="keyword">class</span> <span class="built_in">set</span> </div><div class="line">&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt; <span class="keyword">class</span> Key, <span class="keyword">class</span> T, <span class="keyword">class</span> Compare = <span class="built_in">std</span>::less&lt;Key&gt;, </div><div class="line">           <span class="keyword">class</span> Alloc = <span class="built_in">std</span>::allocator&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">const</span> Key,T&gt;&gt; &gt;</div><div class="line"><span class="keyword">class</span> <span class="built_in">map</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>　　这两个容器默认都是使用<code>std::less&lt;T&gt;</code>来比较元素的大小，在 C++11 中，<code>std::less&lt;T&gt;</code>是函数对象：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; </div><div class="line"><span class="keyword">struct</span> less </div><div class="line">&#123;</div><div class="line">    <span class="keyword">using</span> first_argument_type    = T;</div><div class="line">    <span class="keyword">using</span> second_argument_type   = T;</div><div class="line">    <span class="keyword">using</span> result_type            = <span class="keyword">bool</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">( <span class="keyword">const</span> T &amp;x, <span class="keyword">const</span> T &amp;y )</span> <span class="keyword">const</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> x &lt; y;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>　　在 set 和 map 这种<strong>有序</strong>的容器中，比较两个元素（或两个键相等），<strong>不是</strong>使用 == 操作符，而是这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 比较元素是否相等</span></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compareTwo</span><span class="params">( <span class="keyword">const</span> T &amp;x, <span class="keyword">const</span> T &amp;y )</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> !Compare()( x, y ) &amp;&amp; !Compare()( y, x );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　好了，我们需要在容器中查找元素，有两种方式：</p>
<ul>
<li>调用 set 或 map 的<code>find()</code>成员函数。</li>
<li>调用全局的<code>std::find()</code>函数。</li>
</ul>
<p>　　但是，set 或 map 的<code>find()</code>成员函数，使用<code>compareTwo</code>来比较两个元素是否相等，而<code>std::find()</code>使用<code>std::equal_to&lt;T&gt;</code>来判断两个元素是否相等。</p>
<p>　　这样，在 set 或 map 中查找元素，应该使用<code>find()</code>成员函数，而<strong>不能</strong>使用<code>std::find()</code>。</p>
<hr>
<p>　　对于散列表来说，情况就不一样了：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt; <span class="keyword">class</span> Key, <span class="keyword">class</span> Hash = <span class="built_in">std</span>::hash&lt;Key&gt;, <span class="keyword">class</span> Pred = <span class="built_in">std</span>::equal_to&lt;Key&gt;, </div><div class="line">           <span class="keyword">class</span> Alloc = <span class="built_in">std</span>::allocator&lt;Key&gt;&gt; </div><div class="line"><span class="keyword">class</span> <span class="built_in">unordered_set</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt; <span class="keyword">class</span> Key, <span class="keyword">class</span> T, <span class="keyword">class</span> Hash = <span class="built_in">std</span>::hash&lt;Key&gt;, <span class="keyword">class</span> Pred = <span class="built_in">std</span>::equal_to&lt;Key&gt;,</div><div class="line">           <span class="keyword">class</span> Alloc = <span class="built_in">std</span>::allocator&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">const</span> Key,T&gt;&gt; &gt;</div><div class="line"><span class="keyword">class</span> <span class="built_in">unordered_map</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>　　散列表使用<code>std::equal_to&lt;T&gt;</code>来比较两个元素的是否相等，也就是使用<code>==</code>来判断元素的相等性。</p>
<p>　　理解这一点是容易的，因为散列表<strong>不是</strong>有序的。对于散列表来说，可以使用成员函数<code>find()</code>来查找元素，也可以使用<code>std::find()</code>来查找元素，二者的作用是相同的。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/05/01/基本排序方法/" itemprop="url">
                  算法正确性与循环不变式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-05-01T15:42:47+08:00" content="2015-05-01">
              2015-05-01
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/算法分析/" itemprop="url" rel="index">
                    <span itemprop="name">算法分析</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h2><p>　　使用二分搜索来得到元素在数组中的位置，若元素不存在，那就返回<code>-1</code>，我们用循环不变式<code>mustbe[low, high]</code>表示，若元素<code>target</code>在数组中，那么它必定在范围<code>[low, high]</code>中：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">( T arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> target )</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> low = <span class="number">0</span>, high = n - <span class="number">1</span>;</div><div class="line">    loop:</div><div class="line">        <span class="comment">// &#123; invariant : mustbe[low, high] &#125;</span></div><div class="line">        <span class="keyword">if</span>( low &gt; high ) &#123;</div><div class="line">            <span class="comment">// not found</span></div><div class="line">            <span class="keyword">return</span> ...</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> middle = ( low + high ) / <span class="number">2</span>;</div><div class="line">        <span class="comment">// &#123; invariant: mustbe[low, high] &amp;&amp; low &lt;= middle &lt;= high &#125;</span></div><div class="line">        <span class="keyword">if</span>( target &lt; arr[middle] ) &#123;</div><div class="line">            <span class="comment">// &#123; invariant: mustbe[low, middle - 1] &#125;</span></div><div class="line">            high = middle - <span class="number">1</span>;</div><div class="line">            <span class="comment">// &#123; invariant: mustbe[low, high] &#125;</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>( target &gt; arr[middle] ) &#123;</div><div class="line">            <span class="comment">// &#123; invariant: mustbe[middle + 1, high] &#125;</span></div><div class="line">            low = middle + <span class="number">1</span>;</div><div class="line">            <span class="comment">// &#123; invariant: mustbe[low, high] &#125;</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// found</span></div><div class="line">            <span class="keyword">return</span> middle;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　将伪代码转换成实际代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">( T arr[], <span class="keyword">int</span> n, <span class="keyword">int</span> target )</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> low = <span class="number">0</span>, high = n - <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>( low &lt;= high ) &#123;</div><div class="line">        <span class="keyword">int</span> middle = ( low + high ) / <span class="number">2</span>;</div><div class="line">        <span class="keyword">if</span>( target &lt; arr[middle] ) &#123;</div><div class="line">            high = middle - <span class="number">1</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>( target &gt; arr[middle] ) &#123;</div><div class="line">            low = middle + <span class="number">1</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> middle;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">( T arr[], <span class="keyword">int</span> n )</span> </span>&#123;</div><div class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::swap;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i ) &#123;</div><div class="line">        <span class="comment">// invariant: arr[0, ..., i - 1] is sorted</span></div><div class="line">        <span class="comment">// goal: move arr[i] to somewhere in arr[0, ..., i]</span></div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; arr[j] &lt; arr[j - <span class="number">1</span>]; --j ) &#123;</div><div class="line">            swap( arr[j], arr[j - <span class="number">1</span>] );</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　改进算法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">( T arr[], <span class="keyword">int</span> n )</span> </span>&#123;</div><div class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::swap;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i ) &#123;</div><div class="line">        <span class="comment">// invariant: arr[0, ..., i - 1] is sorted</span></div><div class="line">        <span class="comment">// goal: move arr[i] to somewhere in arr[0, ..., i]</span></div><div class="line">        T curr = arr[i];</div><div class="line">        <span class="keyword">int</span> j = i;</div><div class="line">        <span class="keyword">for</span>( ; j &gt; <span class="number">0</span> &amp;&amp; curr &lt; arr[j - <span class="number">1</span>]; --j ) &#123;</div><div class="line">            arr[j] = arr[j - <span class="number">1</span>];</div><div class="line">        &#125;</div><div class="line">        arr[j - <span class="number">1</span>] = curr;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">( T arr[], <span class="keyword">int</span> n )</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> step = <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>( step &lt; n / <span class="number">3</span> ) &#123;</div><div class="line">        step = step * <span class="number">3</span> + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>( step &gt;= <span class="number">1</span> ) &#123;</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = step; i &lt; n; ++i ) &#123;</div><div class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = i; j &gt;= step &amp;&amp; arr[j] &lt; arr[j - step]; j -= step ) &#123;</div><div class="line">                swap( arr[j], arr[j - step] );</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        step /= <span class="number">3</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">( T arr[], <span class="keyword">int</span> n )</span> </span>&#123;</div><div class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::swap;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i ) &#123;</div><div class="line">        <span class="comment">// invariant: arr[0, ..., i - 1] is sorted</span></div><div class="line">        <span class="comment">// goal: swap the smallest element in arr[i, n - 1] with arr[i]</span></div><div class="line">        <span class="keyword">int</span> min = i;</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j ) &#123;</div><div class="line">            <span class="keyword">if</span>( arr[j] &lt; arr[min] ) &#123;</div><div class="line">                min = j;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        swap( arr[i], arr[min] );</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>　　最简单的快速排序，循环过程：<br><img src="/images/linux/quick.png" alt=""><br>　　循环结束之后：<br><img src="/images/linux/quick1.png" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">( T arr[], <span class="keyword">int</span> low, <span class="keyword">int</span> high )</span> </span>&#123;</div><div class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::swap;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span>( low &gt;= high ) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> mid = low;</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = low + <span class="number">1</span>; i &lt;= high; ++i ) &#123;</div><div class="line">        <span class="comment">// arr[low] =&gt; pivot</span></div><div class="line">        <span class="comment">// invariant: arr[low + 1, ..., mid] &lt; pivot &amp;&amp; arr[mid + 1, high] &gt;= pivot</span></div><div class="line">        <span class="keyword">if</span>( arr[i] &lt; arr[low] ) &#123;</div><div class="line">            swap( arr[++mid], arr[i] );</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    swap( arr[low], arr[mid] );</div><div class="line">    quickSort( arr, low, mid - <span class="number">1</span> );</div><div class="line">    quickSort( arr, mid + <span class="number">1</span>, high );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　在极端的情况下，例如，输入数组是有序的（ 升序或降序 ）或者数组中的所有元素均相等，算法的复杂度为<code>O(N^2)</code>。</p>
<hr>
<p>　　更好的快速排序，循环不变式：<br><img src="/images/linux/quick3.png" alt=""><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">( T arr[], <span class="keyword">int</span> low, <span class="keyword">int</span> high )</span> </span>&#123;</div><div class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::swap;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span>( low &gt;= high ) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> i = low, j = high + <span class="number">1</span>;</div><div class="line">    T pivot = arr[low];</div><div class="line">    </div><div class="line">    <span class="keyword">while</span>( <span class="literal">true</span> ) &#123;</div><div class="line">	<span class="comment">// arr[low] =&gt; pivot</span></div><div class="line">	<span class="comment">// invariant: arr[low + 1, ..., i] &lt;= pivot &amp;&amp; arr[j, ..., high] &gt;= pivot </span></div><div class="line">        <span class="keyword">while</span>( i &lt; high &amp;&amp; arr[++i] &lt; pivot )</div><div class="line">            ;</div><div class="line">        <span class="keyword">while</span>( j &gt; low &amp;&amp; arr[--j] &gt; pivot )</div><div class="line">            ;</div><div class="line">        <span class="keyword">if</span>( i &gt;= j ) &#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        swap( arr[i], arr[j] );</div><div class="line">    &#125;</div><div class="line">    swap( arr[low], arr[j] );</div><div class="line"></div><div class="line">    quickSort( arr, low, j - <span class="number">1</span> );</div><div class="line">    quickSort( arr, j + <span class="number">1</span>, high );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　循环中维持两个索引<code>i</code>和<code>j</code>，移动索引的过程要是遇到元素与<code>pivot</code>相同，则会停止移动索引并交换这两个元素，尽管这样会使用不必要的交换操作，但若是数组包含大量重复的元素，算法的复杂度仍为<code>O(logN)</code>。</p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">( T arr[], <span class="keyword">int</span> n )</span> </span>&#123;</div><div class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::swap;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> low = <span class="number">0</span>, high = n - <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = low; i &lt; high; ++i ) &#123;</div><div class="line">        <span class="comment">// invariant: arr[0, ..., i - 1] is sorted</span></div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = high; j &gt; i; --j )&#123;</div><div class="line">            <span class="keyword">if</span>( arr[j] &lt; arr[j - <span class="number">1</span>] ) &#123;</div><div class="line">                swap( arr[j], arr[j - <span class="number">1</span>] );</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　稍微改进一下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">( T arr[], <span class="keyword">int</span> n )</span> </span>&#123;</div><div class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::swap;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> low = <span class="number">0</span>, high = n - <span class="number">1</span>;</div><div class="line">    <span class="keyword">bool</span> swapped = <span class="literal">true</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = low; i &lt; high &amp;&amp; swapped; ++i ) &#123;</div><div class="line">        swapped = <span class="literal">false</span>;</div><div class="line">        <span class="comment">// invariant: arr[0, ..., i - 1] is sorted</span></div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = high; j &gt; i; --j )&#123;</div><div class="line">            <span class="keyword">if</span>( arr[j] &lt; arr[j - <span class="number">1</span>] ) &#123;</div><div class="line">                swap( arr[j], arr[j - <span class="number">1</span>] );</div><div class="line">                swapped = <span class="literal">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">( T arr[], T l[], <span class="keyword">int</span> lsize, T r[], <span class="keyword">int</span> rsize )</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> size = lsize + rsize;</div><div class="line"></div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>; k &lt; size; ++k )</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>( i == lsize )</div><div class="line">        &#123;</div><div class="line">            arr[k] = <span class="built_in">std</span>::move( r[j++] );</div><div class="line">        &#125; </div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( j == rsize )</div><div class="line">        &#123;</div><div class="line">            arr[k] = <span class="built_in">std</span>::move( l[i++] );</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( r[j] &lt; l[i] )</div><div class="line">        &#123;</div><div class="line">            arr[k] = <span class="built_in">std</span>::move( r[j++] );</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> </div><div class="line">        &#123;</div><div class="line">            arr[k] = <span class="built_in">std</span>::move( l[i++] );</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">( T arr[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi )</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// we must sure range [lo, hi] is valid</span></div><div class="line">    <span class="keyword">if</span>( hi &lt;= lo )</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> mid = lo + ( hi - lo ) / <span class="number">2</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">auto</span> left  = <span class="keyword">new</span> T[mid - lo + <span class="number">1</span>];</div><div class="line">    <span class="keyword">auto</span> right = <span class="keyword">new</span> T[hi - mid];</div><div class="line">    </div><div class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = lo; i &lt;= mid; ++i )</div><div class="line">    &#123;</div><div class="line">        left[cnt++] = <span class="built_in">std</span>::move( arr[i] );</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    cnt = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = mid + <span class="number">1</span>; i &lt;= hi; ++i )</div><div class="line">    &#123;</div><div class="line">        right[cnt++] = <span class="built_in">std</span>::move( arr[i] );</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mergeSort( left, <span class="number">0</span>, mid - lo );</div><div class="line">    mergeSort( right, <span class="number">0</span>, hi - mid - <span class="number">1</span> );</div><div class="line">    </div><div class="line">    merge( arr, left, mid - lo + <span class="number">1</span>, right, hi - mid );</div><div class="line"></div><div class="line">    <span class="keyword">delete</span>[] left;</div><div class="line">    <span class="keyword">delete</span>[] right;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.amazon.com/Programming-Pearls%C2%A0%C2%A0-PROGRAMMING-PEARLS-Paperback/dp/B008NY8KRU/ref=sr_1_1?ie=UTF8&amp;qid=1439018816&amp;sr=8-1&amp;keywords=programming+pearls+2+e" target="_blank" rel="external">Programming Pearls</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/04/29/C-11并发编程一/" itemprop="url">
                  C++11 并发编程（一）-- 线程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-04-29T22:21:05+08:00" content="2015-04-29">
              2015-04-29
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/并发编程/" itemprop="url" rel="index">
                    <span itemprop="name">并发编程</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="线程介绍"><a href="#线程介绍" class="headerlink" title="线程介绍"></a>线程介绍</h2><p>　　在 C++11 中，线程具有这些特点：</p>
<ul>
<li>C++11 中的线程与操作系统的线程形成一对一的映射。</li>
<li>所有的线程工作在同一地址空间。</li>
<li>线程表示系统资源，因此，线程无法被 copy，但可以被<code>std::move()</code>。</li>
</ul>
<h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><p>　　C++11 使用<code>std::thread</code>来代表线程，<code>std::thread</code>的构造函数是可变模板( variadic template )，因此，可以传递给<code>std::thread</code>的构造函数一个 callable 对象和这个 callable 对象所需的参数，这个 callable 对象可以是函数、成员函数、函数对象或 lambda 表达式。<br>　　另一方面，我们可以通过<code>std::thread</code>的默认构造函数用来构造一个空的线程，很明显，由于没有为其指定需要执行的任务，因此，这个空的线程无法表示实际的执行线程。有几种情况下，<code>std::thread</code>表示空的线程：</p>
<ul>
<li>通过<code>std::thread</code>的默认构造函数来创建的线程，则表示空的线程。</li>
<li>调用<code>std::move(t)</code>之后，<code>t</code>表示空的线程。</li>
<li>调用<code>t.detach()</code>之后，<code>t</code>表示空的线程。</li>
</ul>
<p>　　在<code>std::thread</code>构造结束之后，只要系统能够获得足够的资源，那么<code>std::thread</code>就会立即启动，否则就会抛出<code>std::system_error</code>异常。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">task</span><span class="params">( <span class="keyword">int</span> num )</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; ++i ) &#123;</div><div class="line">        <span class="built_in">std</span>::this_thread::sleep_for( <span class="built_in">std</span>::chrono::seconds&#123;i&#125; );   </div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span> NUM = <span class="number">5</span>;</div><div class="line">    <span class="built_in">std</span>::thread t&#123; task, NUM &#125;;</div><div class="line">    t.join();</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　调用<code>t.join()</code>能够让当前线程处于阻塞状态，等待线程<code>t</code>的执行结束，也就是说，在调用<code>t.join()</code>之后，<code>main()</code>函数将会等待<code>task()</code>执行结束。<br>　　当然，在调用<code>t.join()</code>的时候，假定<code>t</code>已经执行完任务，那么，<code>t.join()</code>将会立即返回。</p>
<h2 id="线程-ID"><a href="#线程-ID" class="headerlink" title="线程 ID"></a>线程 ID</h2><p>　　<code>std::thread::id</code>表示线程 ID，其默认构造函数<code>std::thread::id{}</code>用来表示空的线程 ID。可以通过<code>std::thread</code>的<code>get_id()</code>来获得线程的 ID，我们知道，<code>std::thread</code>可以表示实际的线程，也可以表示空的线程，那么：</p>
<ul>
<li>要是<code>std::thread</code>表示实际的线程，那么，<code>t.get_id()</code>返回一个独一无二的<code>std::thread::id</code>。</li>
<li>要是<code>std::thread</code>表示空的线程，那么，<code>t.get_id()</code>返回<code>std::thread::id{}</code>。</li>
</ul>
<p>　　另一方面，调用<code>t.join()</code>时，需要保证<code>t</code>表示实际的线程，而不能是空的线程，否则将会抛出<code>std::system_error</code>异常。在调用<code>t.join()</code>之前，可以使用<code>t.joinable()</code>来判断<code>t</code>是否表示实际的线程。实际上，<code>std::thread</code>的<code>joinable()</code>成员函数的实现类似于<code>my_joinable()</code>函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">my_joinable</span><span class="params">( <span class="keyword">const</span> <span class="built_in">std</span>::thread &amp;t )</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> t.get_id() != <span class="built_in">std</span>::thread::id&#123;&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　若线程是<code>joinable()</code>的，那么，调用<code>join()</code>等待它的执行结束：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">task</span><span class="params">()</span> </span>&#123;  &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">join_thread</span><span class="params">( <span class="built_in">std</span>::thread &amp;t )</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>( t.joinable() ) &#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The thread "</span> &lt;&lt; t.get_id() &lt;&lt; <span class="string">" is joinable!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">        t.join();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The thread is empty!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">std</span>::thread execution_thread&#123; task &#125;;</div><div class="line">    <span class="built_in">std</span>::thread empty_thread;</div><div class="line">    join_thread( execution_thread );</div><div class="line">    join_thread( empty_thread );</div><div class="line">	</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">The thread 3074423616 is joinable!</div><div class="line">The thread is empty!</div><div class="line">**/</div></pre></td></tr></table></figure></p>
<h2 id="线程析构"><a href="#线程析构" class="headerlink" title="线程析构"></a>线程析构</h2><p>　　<code>std::thread</code>的析构函数负责销毁<code>std::thread</code>对象，当线程调用析构函数的时候，它显然希望线程不再处于执行任务的状态中，也就是说，<code>t.joinable()</code>将返回<code>false</code>。要是<code>t.joinable()</code>返回<code>true</code>，线程析构的时候将会调用<code>std::terminate()</code>来终结程序的运行：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">longTask</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i ) &#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">        <span class="built_in">std</span>::this_thread::sleep_for( <span class="built_in">std</span>::chrono::seconds&#123;<span class="number">1</span>&#125; );</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">std</span>::thread t&#123; longTask &#125;; </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="comment">// call std::terminate() because t still running at the end of it's scope</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　对于线程<code>t</code>来说，使用<code>t.join()</code>有两点需要注意的地方：</p>
<ul>
<li>若<code>t</code>是<code>joinable()</code>的，那么需要调用<code>t.join()</code>来等待线程<code>t</code>执行结束，否则，当<code>t</code>析构的时候，将会调用<code>std::terminate()</code>来终结程序。</li>
<li>若<code>t</code>不是<code>joinable()</code>的，调用<code>t.join()</code>将会抛出<code>std::system_error</code>异常。</li>
</ul>
<hr>
<p>　　考虑以下的代码段，其中的<code>might_throw()</code>可能会抛出异常：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">task1</span><span class="params">()</span> </span>&#123;  &#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">task2</span><span class="params">()</span> </span>&#123;  &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">might_throw</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// do something might throw exception</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bad</span><span class="params">( <span class="keyword">bool</span> flag )</span> </span>&#123;</div><div class="line">    <span class="built_in">std</span>::thread t1&#123; task1 &#125;;</div><div class="line">    <span class="built_in">std</span>::thread t2;</div><div class="line">    <span class="keyword">if</span>( flag ) &#123;</div><div class="line">        <span class="built_in">std</span>::thread t3&#123; task2 &#125;;</div><div class="line">        t2 = <span class="built_in">std</span>::move( t3 );</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    might_throw();  <span class="comment">// might throw exception</span></div><div class="line">    </div><div class="line">    t1.join();</div><div class="line">    t2.join();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　这段程序有几个不正确的地方：</p>
<ul>
<li>若<code>flag</code>的值为<code>false</code>，那么，<code>t2</code>表示空的线程，调用<code>t2.join()</code>将抛出<code>std::system_error</code>异常。</li>
<li>若<code>might_throw()</code>抛出异常，那么，<code>t1</code>的析构函数将调用<code>std::terminate()</code>来终结程序。</li>
</ul>
<hr>
<p>　　当然，我们可以定义一个<code>std::thread</code>的派生类：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> guarded_thread : <span class="keyword">public</span> <span class="built_in">std</span>::thread</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">using</span> thread::thread;</div><div class="line">    <span class="keyword">using</span> thread::<span class="keyword">operator</span>=;</div><div class="line"></div><div class="line">    ~guarded_thread() &#123;</div><div class="line">        <span class="keyword">if</span>( joinable() ) &#123;</div><div class="line">            join();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>　　注意，<code>guarded_thread</code>支持<code>std::thread</code>的构造函数，除此之外，还支持 move assignment operator，接受<code>std::thread</code>作为参数，也就是说支持将<code>std::thread</code>移动给<code>guarded_thread</code>。</p>
<p>　　使用<code>guarded_thread</code>将会更好方便，例如，前面的例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">not_bad</span><span class="params">( <span class="keyword">bool</span> flag )</span> </span>&#123;</div><div class="line">    guarded_thread t1&#123; task1 &#125;;</div><div class="line">    guarded_thread t2;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>( flag ) &#123;</div><div class="line">        thread t3&#123; task2 &#125;;</div><div class="line">        t2 = <span class="built_in">std</span>::move( t3 );</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    might_throw();  <span class="comment">// might throw exception</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　这时，即使<code>might_throw()</code>抛出异常，那么，<code>guarded_thread</code>退出作用域，其析构函数会判断，要是线程是<code>joinable()</code>的，那么，调用<code>join()</code>来等待线程执行结束。</p>
<p>　　但是，注意到，<code>guarded_thread</code>有两点不足：</p>
<ul>
<li>可以将<code>std::thread</code>移动给<code>guarded_thread</code>，但不支持将一个<code>guarded_thread</code>移动给另一个<code>guarded_thread</code>。</li>
<li>由于<code>std::thread</code>的析构函数不是 virtual 函数，不支持多态行为。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">guarded_thread gt1&#123; task &#125;;</div><div class="line">guarded_thread gt2;</div><div class="line">gt2 = <span class="built_in">std</span>::move( gt1 );                             <span class="comment">// ERROR: can't move guarded_thread to another</span></div><div class="line"><span class="built_in">unique_ptr</span>&lt;thread&gt; p&#123; <span class="keyword">new</span> guarded_thread&#123;task&#125; &#125;;   <span class="comment">// ERROR: destructor is not virtual</span></div></pre></td></tr></table></figure>
<hr>
<p>　　从前面可以知道，<code>guarded_thread</code>有着不足的地方。实际上，我们只需要改变<code>std::thread</code>的析构行为。别忘了，智能指针可以让我们指定析构的行为，因此，智能指针可以轻易实现这一点。在 C++14 里面，可以这样做：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">task</span><span class="params">( <span class="keyword">int</span> n )</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i ) &#123;</div><div class="line">        this_thread::sleep_for( chrono::seconds&#123;<span class="number">1</span>&#125; );</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Ts&gt;</div><div class="line"><span class="function"><span class="keyword">auto</span> <span class="title">createThreadPtr</span><span class="params">( Ts&amp;&amp;... params )</span> </span>&#123;</div><div class="line">    <span class="keyword">auto</span> threadDeleter = []( thread *p ) &#123;</div><div class="line">        <span class="keyword">if</span>( p-&gt;joinable() ) &#123;</div><div class="line">            p-&gt;join();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">delete</span> p;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">using</span> threadPtr = <span class="built_in">unique_ptr</span>&lt;thread, <span class="keyword">decltype</span>(threadDeleter)&gt;;</div><div class="line">    threadPtr ptr&#123; <span class="keyword">new</span> thread&#123; forward&lt;Ts&gt;(params)... &#125;, threadDeleter &#125;;</div><div class="line">    <span class="keyword">return</span> ptr;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">auto</span> ptr = createThreadPtr( task, <span class="number">10</span> );            <span class="comment">// OK: very safely and elegant</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　可以看到，<code>createThreadPtr()</code>返回一个指向<code>std::thread</code>的<code>unique_ptr</code>，并且将<code>threadDeleter</code>作为指定的析构函数。那么，当<code>unique_ptr</code>被销毁的时候将会调用<code>threadDeleter</code>，若线程的<code>joinable()</code>成员函数返回<code>true</code>，那么将调用<code>join()</code>等待线程的执行结束。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://theboostcpplibraries.com/boost.thread" target="_blank" rel="external">The Boost C++ Libraries: Chapter 44. Boost.Thread</a></li>
<li><a href="www.amazon.com/gp/product/0321563840/ref=s9_simh_gw_p14_d0_i4?pf_rd_m=ATVPDKIKX0DER&amp;pf_rd_s=desktop-1&amp;pf_rd_r=1K1091VGJG234NP5NA8T&amp;pf_rd_t=36701&amp;pf_rd_p=1970559082&amp;pf_rd_i=desktop">The C++ Programming Language 4th Edition</a></li>
<li><a href="http://book.douban.com/subject/10440485/" target="_blank" rel="external">The C++ Standard Library Second Edition</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/04/26/智能指针3/" itemprop="url">
                  高效 C++11 -- 智能指针（三）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-04-26T10:04:56+08:00" content="2015-04-26">
              2015-04-26
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/编程语言/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h2><p>　　考虑一下以下的例子，类 A 包含<code>shared_ptr</code>的数据成员，用来指向另一个 A 的实例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> A &#123;</div><div class="line">    <span class="built_in">shared_ptr</span>&lt;A&gt; parner;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>　　假定存在两个 A 的实例，各自拥有数据成员<code>shared_ptr</code>指向对方，这种情况就称为循环引用，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> a1 = make_shared&lt;A&gt;();</div><div class="line"><span class="keyword">auto</span> a2 = make_shared&lt;A&gt;();</div><div class="line">a1-&gt;parner = a2;</div><div class="line">a2-&gt;parner = a1;</div><div class="line">a1 = <span class="literal">nullptr</span>;</div><div class="line">a2 = <span class="literal">nullptr</span>;</div></pre></td></tr></table></figure></p>
<p>　　使用<code>shared_ptr</code>时，需要避免出现循环引用的情况发生，因为这样容易导致内存无法释放。尽管我们已经将<code>a1</code>和<code>a2</code>设置成<code>nullptr</code>，但注意，<code>a1</code>和<code>a2</code>所指向的对象内部均包含<code>shared_ptr</code>指向对方，因此，这时两个对象的引用计数均是 1，这就导致了两个对象所占的内存无法被释放。<br><img src="/images/data-structure/am.png" alt=""><br>　　为避免循环引用产生的问题，可以使用<code>weak_ptr</code>。<code>weak_ptr</code>并不拥有其指向的对象，也就是说，当我们创建<code>weak_ptr</code>来指向<code>shared_ptr</code>所拥有的对象时，对象的引用计数并不会增加。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; sp( <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"hello"</span>) );</div><div class="line">weak_ptr&lt;<span class="built_in">string</span>&gt; wp1( sp );             <span class="comment">// sp is a shared_ptr</span></div><div class="line">weak_ptr&lt;<span class="built_in">string</span>&gt; wp2( wp );             <span class="comment">// wp is a weak_ptr</span></div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"use count: "</span> &lt;&lt; sp.use_count() &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"><span class="comment">// use count: 1</span></div></pre></td></tr></table></figure></p>
<p>　　我们知道，<code>shared_ptr</code>除了共享（访问）对象，还拥有对象。而<code>weak_ptr</code>仅是共享（访问）对象，但不拥有对象，也就是说，<code>weak_ptr</code>无法改变引用计数。<br>　　另一方面，要是对象未被销毁，则可以通过<code>weak_ptr</code>来返回一个<code>shared_ptr</code>，有两种方式：</p>
<ul>
<li>调用<code>weak_ptr</code>的<code>lock()</code>成员函数，要是对象已经被销毁，则<code>lock()</code>返回一个空的<code>shared_ptr</code></li>
<li>将<code>weak_ptr</code>传递给<code>shared_ptr</code>的构造函数，要是对象已经被销毁，则抛出<code>std::exception</code>异常</li>
</ul>
<p>　　这样，就可以通过这个<code>shared_ptr</code>来访问对象：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; sp( <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"hello"</span>) );</div><div class="line">weak_ptr&lt;<span class="built_in">string</span>&gt; wp( sp );</div><div class="line">wp.lock()-&gt;append(<span class="string">" world"</span>);                  <span class="comment">// wp.lock() return a shared_ptr&lt;string&gt;</span></div><div class="line"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt;(wp)-&gt;append(<span class="string">"!"</span>);</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"use count: "</span> &lt;&lt; sp.use_count() &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; *sp &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"><span class="comment">/*</span></div><div class="line">use count: 1</div><div class="line">hello world!</div><div class="line">*/</div></pre></td></tr></table></figure></p>
<p>　　但是要怎样判断<code>weak_ptr</code>指向的对象是否还存在？有两种方式：</p>
<ul>
<li>使用<code>weak_ptr</code>的<code>use_count()</code>成员函数，判断引用计数是否为 0</li>
<li>调用<code>weak_ptr</code>的<code>expired()</code>成员函数，要是对象已经被销毁，则<code>expired()</code>将返回<code>true</code></li>
</ul>
<p>　　实际上，比起使用<code>use_count()</code>，使用<code>expired()</code>更加高效：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; sp( <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"hello"</span>) );</div><div class="line">    weak_ptr&lt;<span class="built_in">string</span>&gt; wp = sp;</div><div class="line">    sp.reset();</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"wp.use_count() = "</span> &lt;&lt; wp.use_count() &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"wp.expired() = "</span> &lt;&lt; boolalpha &lt;&lt; wp.expired() &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; p(wp);                  <span class="comment">// throw exception</span></div><div class="line">&#125; <span class="keyword">catch</span>( <span class="keyword">const</span> <span class="built_in">std</span>::exception &amp;e ) &#123;</div><div class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="string">"exception: "</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line">wp.use_count() = 0</div><div class="line">wp.expired() = true</div><div class="line">exception: bad_weak_ptr</div><div class="line">*/</div></pre></td></tr></table></figure></p>
<hr>
<p>　　考虑另一个例子，我们定义<code>Employee</code>和<code>Boss</code>两个类：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">#include &lt;string&gt;</div><div class="line">#include &lt;memory&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">class Boss;</div><div class="line"></div><div class="line">class Employee</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    Employee( const string &amp;s, shared_ptr&lt;Boss&gt; boss )</div><div class="line">        : name_( s ), boss_( boss ) &#123;  &#125;</div><div class="line">    ~Employee() &#123;</div><div class="line">        cout &lt;&lt; "delete " &lt;&lt; name_ &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line">private:</div><div class="line">    string name_;</div><div class="line">    shared_ptr&lt;Boss&gt; boss_;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class Boss</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    explicit Boss( const string &amp;s )</div><div class="line">        : name_( s ) &#123;  &#125;</div><div class="line">    ~Boss() &#123;</div><div class="line">        cout &lt;&lt; "delete " &lt;&lt; name_ &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line">    void addEmployee( shared_ptr&lt;Employee&gt; employee ) &#123;</div><div class="line">        employees_.push_back( employee );</div><div class="line">    &#125;</div><div class="line">private:</div><div class="line">    string name_;</div><div class="line">    vector&lt;shared_ptr&lt;Employee&gt;&gt; employees_;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">int main(int argc, char *argv[])</div><div class="line">&#123;</div><div class="line">    auto boss = make_shared&lt;Boss&gt;( "boss" );</div><div class="line">    boss-&gt;addEmployee( make_shared&lt;Employee&gt;( "employee1", boss ) );</div><div class="line">    boss-&gt;addEmployee( make_shared&lt;Employee&gt;( "employee2", boss ) );</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　<code>Employee</code>内部包含<code>shared_ptr</code>指向<code>Boss</code>，而<code>Boss</code>内部包含<code>shared_ptr</code>指向<code>Employee</code>。两个类的析构函数都会向控制台输出相应信息，但运行这个程序时，控制台并不会出现任何信息，也就是说，当程序退出时，内存并没有被释放从而造成内存泄露。<br>　　当程序退出时，由于两个<code>Employee</code>对象内部均含有执行<code>Boss</code>的指针，这时<code>Boss</code>的引用计数是 2，因此，<code>Boss</code>并不会被销毁。<br>　　使用<code>weak_ptr</code>就能轻易解决这个问题：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Employee</div><div class="line">&#123;</div><div class="line"><span class="comment">// ...</span></div><div class="line">    weak_ptr&lt;Boss&gt; boss_;          <span class="comment">// change shared_ptr to weak_ptr</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>　　也就是说，<code>Boss</code>能够控制<code>Employee</code>的生命周期，但<code>Employee</code>无法控制<code>Boss</code>的生命周期。运行程序，可以看到：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">delete boss</div><div class="line">delete employee1</div><div class="line">delete employee2</div></pre></td></tr></table></figure></p>
<h2 id="共享群组"><a href="#共享群组" class="headerlink" title="共享群组"></a>共享群组</h2><p>　　当多个<code>shared_ptr</code>指向同一对象时，这些<code>shared_ptr</code>就属于同一个 share group。使用<code>shared_ptr</code>时，不能直接通过原生指针来构造多个<code>shared_ptr</code>，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>&#123;<span class="number">10</span>&#125;;</div><div class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; ptr1&#123; p &#125;;</div><div class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; ptr2&#123; p &#125;;         <span class="comment">// ERROR</span></div></pre></td></tr></table></figure></p>
<p>　　很明显，每当通过原生指针来构造<code>shared_ptr</code>时候就会分配一个 control block，这时总有就有两个 control block，也就是说存在两个引用计数。这显然是错误的，因为我们创建了两个 share group，当这两个<code>shared_ptr</code>被销毁时，对象将会被<code>delete</code>两次。</p>
<hr>
<p>　　考虑另一个例子：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class Student</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    explicit Student( const string &amp;name )</div><div class="line">        : name_( name ) &#123; &#125;</div><div class="line">    void addToGroup( vector&lt;shared_ptr&lt;Student&gt;&gt; &amp;group ) &#123;</div><div class="line">        group.push_back( shared_ptr&lt;Student&gt;(this) );          // ERROR: create a new share group</div><div class="line">    &#125;</div><div class="line">private:</div><div class="line">    string name_;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>　　注意，<code>this</code>也是原生指针，每次调用<code>addToGroup()</code>时都会创建一个 share group，同一个对象在多少个 share group 之间共享，最终这个对象就会被<code>delete</code>多少次。<br>　　可以将<code>std::enable_shared_from_this&lt;Student&gt;</code>作为<code>Student</code>的基类：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class Student : public std::enable_shared_from_this&lt;Student&gt;</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    explicit Student( const string &amp;name )</div><div class="line">        : name_( name ) &#123; &#125;</div><div class="line">    void addToGroup( vector&lt;shared_ptr&lt;Student&gt;&gt; &amp;group ) &#123;</div><div class="line">        group.push_back( shared_from_this() );              // OK: will not create a new share group</div><div class="line">    &#125;</div><div class="line">private:</div><div class="line">    string name_;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>　　需要特别注意的是，在调用<code>shared_from_this()</code>之前需要确保对象被<code>share_ptr</code>所持有，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">shared_ptr</span>&lt;Student&gt;&gt; group;</div><div class="line"><span class="keyword">auto</span> goodStudent = make_shared&lt;Student&gt;( <span class="string">"senlin"</span> );  <span class="comment">// Good: ensure object be owned by shared_ptr</span></div><div class="line">goodStudent-&gt;addToGroup( group );</div><div class="line"></div><div class="line"><span class="function">Student <span class="title">badStudent1</span><span class="params">( <span class="string">"bad1"</span> )</span></span>;                        <span class="comment">// ERROR</span></div><div class="line">badStudent1.addToGroup( group );</div><div class="line"></div><div class="line"><span class="keyword">auto</span> badStudent2 = <span class="keyword">new</span> Student( <span class="string">"bad2"</span> );             <span class="comment">// ERROR</span></div><div class="line">badStudent2-&gt;addToGroup( group );</div></pre></td></tr></table></figure></p>
<p>　　理解这一点是很容易的，只有当对象被<code>shared_ptr</code>所持有，那么，使用<code>shared_from_this()</code>所返回的<code>shared_ptr</code>才会属于同一个 share group。<br>　　另外，决不能在<code>Student</code>的构造函数中调用<code>shared_from_this()</code>：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class Student : public std::enable_shared_from_this&lt;Student&gt;</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    explicit Student( const string &amp;name, vector&lt;shared_ptr&lt;Student&gt;&gt; &amp;group )</div><div class="line">        : name_( name ) &#123;</div><div class="line">        group.push_back( shared_from_this() );      // ERROR: shared_from_this() can't be call</div><div class="line">                                                    // in object's constructor</div><div class="line">    &#125;</div><div class="line">private:</div><div class="line">    string name_;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>　　同样，这也很容易理解，我们知道，在调用<code>shared_from_this()</code>之前需要确保对象被<code>shared_ptr</code>所持有，同样我们知道，要使得对象被<code>shared_ptr</code>所持有，对象首先要初始化（调用构造函数）。所以，只有在对象初始化结束之后（调用构造函数之后），才能调用<code>shared_from_this()</code>。</p>
<hr>
<p>　　好了，有几个问题：</p>
<ul>
<li>要怎样才能防止用户以不正确的方式来创建<code>Student</code>对象呢？</li>
<li>同时也要使得，我们可以使用不同的构造方式来创建<code>Student</code>对象。</li>
</ul>
<p>　　可以将<code>Student</code>的构造函数声明为<code>private</code>的，因此，用户无法直接创建<code>Student</code>对象。另一方面，增加<code>create()</code>成员函数，在这个函数里面，我们使用 C++11 的 variadic templates 特性，调用<code>Student</code>的构造函数来构造对象：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">class Student : public std::enable_shared_from_this&lt;Student&gt;</div><div class="line">&#123;</div><div class="line">private:</div><div class="line">    explicit Student( const string &amp;name ) : name_( name ) &#123;  &#125;</div><div class="line"></div><div class="line">    Student( const Student &amp;rhs ) : name_( rhs.name_ )&#123; &#125;</div><div class="line"></div><div class="line">    // can have other constructor</div><div class="line">public:</div><div class="line">    template &lt;typename... Args&gt;</div><div class="line">    static shared_ptr&lt;Student&gt; create( Args&amp;&amp;... args ) &#123;</div><div class="line">        return shared_ptr&lt;Student&gt;( new Student( std::forward&lt;Args&gt;(args)... ) );</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void addToGroup( vector&lt;shared_ptr&lt;Student&gt;&gt; &amp;group ) &#123;</div><div class="line">        group.push_back( shared_from_this() );</div><div class="line">    &#125;</div><div class="line">private:</div><div class="line">    string name_;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>　　通过<code>create()</code>保证了用户创建的对象总是被<code>shared_ptr</code>所持有，我们可以将<code>create()</code>想象成<code>Student</code>构造函数的别名：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">shared_ptr</span>&lt;Student&gt;&gt; group;</div><div class="line"><span class="keyword">auto</span> student1 = Student::create( <span class="string">"senlin"</span> );</div><div class="line"><span class="keyword">auto</span> student2 = Student::create( *student1 );            <span class="comment">// call Student's copy constructor</span></div><div class="line">student1-&gt;addToGroup( group );</div><div class="line">student2-&gt;addToGroup( group );</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"student1.use_count() = "</span> &lt;&lt; student1.use_count() &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"><span class="comment">/*</span></div><div class="line">student1.use_count() = 2</div><div class="line">*/</div></pre></td></tr></table></figure></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.amazon.com/Effective-Modern-Specific-Ways-Improve/dp/1491903996/ref=sr_1_1?ie=UTF8&amp;qid=1428220334&amp;sr=8-1&amp;keywords=effective+modern+c%2B%2B" target="_blank" rel="external">Effective Modern C++: 42 Specific Ways to Improve Your Use of C++11 and C++14 </a></li>
<li><a href="http://stackoverflow.com/questions/712279/what-is-the-usefulness-of-enable-shared-from-this" target="_blank" rel="external">StackOverflow: what is the usefulness of enable_shared_from_this</a></li>
<li><a href="http://mortoray.com/2013/08/02/safely-using-enable_shared_from_this/" target="_blank" rel="external">Safely using enable_shared_from_this</a></li>
<li><a href="http://book.douban.com/subject/10440485/" target="_blank" rel="external">The C++ Standard Library Second Edition</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="John Doe" />
          <p class="site-author-name" itemprop="name">John Doe</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">97</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">14</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">17</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  

  

  

  

</body>
</html>
