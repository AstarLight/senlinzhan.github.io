<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/8/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/page/8/"/>

  <title> Hexo </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Hexo</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/02/07/自制STL之比较算法/" itemprop="url">
                  自制 STL -- 比较算法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-02-07T20:25:27+08:00" content="2015-02-07">
              2015-02-07
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/自制STL/" itemprop="url" rel="index">
                    <span itemprop="name">自制STL</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="顺序相等性比较"><a href="#顺序相等性比较" class="headerlink" title="顺序相等性比较"></a>顺序相等性比较</h2><p>　　可以使用<code>equal()</code>来比较两个范围中的两两对应的元素是否相等，第二个范围中的元素数目应大于或等于第一个范围中的元素数目，比较的次数将取决于第一个范围中的元素数目，因此，若第一个范围为空，则比较结果也为<code>true</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator1, <span class="keyword">typename</span> InputIterator2&gt;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">equal</span><span class="params">( InputIterator1 beg1, InputIterator1 end1, InputIterator2 beg2 )</span> </span>&#123;</div><div class="line">    <span class="keyword">while</span>( beg1 != end1 ) &#123;</div><div class="line">        <span class="keyword">if</span>( *beg1++ != *beg2++ ) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</div><div class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; lst1 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</div><div class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; lst2 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">8</span> &#125;;</div><div class="line"><span class="keyword">if</span>( equal( vec.cbegin(), vec.cend(), lst1.cbegin() ) ) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"vec == lst1"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"vec != lst1"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// vec == lst1</span></div><div class="line"><span class="keyword">if</span>( equal( vec.cbegin(), vec.cend(), lst2.cbegin() ) ) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"vec == lst2"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"vec != lst2"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// vec != lst2</span></div></pre></td></tr></table></figure></p>
<p>　　其重载版本：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator1, <span class="keyword">typename</span> InputIterator2, <span class="keyword">typename</span> BinaryPredicate&gt;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">equal</span><span class="params">( InputIterator1 beg1, InputIterator1 end1, InputIterator2 beg2, BinaryPredicate predicate )</span></span>&#123;</div><div class="line">    <span class="keyword">while</span>( beg1 != end1 ) &#123;</div><div class="line">        <span class="keyword">if</span>( !predicate( *beg1++, *beg2++ ) ) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="无序相等性比较"><a href="#无序相等性比较" class="headerlink" title="无序相等性比较"></a>无序相等性比较</h2><p>　　<code>is_permutation()</code>算法用来比较两个输入范围中元素的是否相等，但不要求元素的顺序相同。例如，使用<code>is_permutation()</code>来比较<code>[1, 2, 3]</code>和<code>[2, 3, 1]</code>将返回<code>true</code>。<br>　　首先，我们让<code>beg1</code>和<code>beg2</code>指向不同的元素：<br><img src="/images/data-structure/com1.png" alt=""><br>　　其次，我们判断<code>[beg1, end1)</code>中的每个元素在<code>[beg1, end1)</code>和<code>[beg2, end2)</code>中出现的次数是否相同，若元素出现的次数不同，则返回<code>false</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ForwardIterator1, <span class="keyword">typename</span> ForwardIterator2&gt;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_permutation</span><span class="params">( ForwardIterator1 beg1, ForwardIterator1 end1, ForwardIterator2 beg2 )</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span>( ; beg1 != end1; ++beg1, ++beg2 ) &#123;</div><div class="line">        <span class="keyword">if</span>( *beg1 != *beg2 ) &#123;</div><div class="line">            <span class="keyword">break</span>;            </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">　　</div><div class="line">　　<span class="comment">// 若两个范围中元素相等并且元素出现顺序相同，则返回 true</span></div><div class="line">    <span class="keyword">if</span>( beg1 == end1 ) &#123;                                </div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> end2 = beg2;</div><div class="line">    <span class="built_in">std</span>::advance( end2, <span class="built_in">std</span>::distance( beg1, end1 ) );  <span class="comment">// 使得[beg2, end2)范围和[beg1, end1)一样大</span></div><div class="line">    <span class="keyword">for</span>( <span class="keyword">auto</span> scan = beg1; scan != end1; ++scan ) &#123;</div><div class="line">        <span class="keyword">if</span>( scan != <span class="built_in">std</span>::find( beg1, scan, *scan ) ) &#123;  <span class="comment">// 若元素 *scan 已经遇到过，则不处理 </span></div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 判断元素 *scan 在[beg1, end1)和[beg2, end2)中出现的次数是否相同</span></div><div class="line">        <span class="keyword">auto</span> matches = <span class="built_in">std</span>::count( beg2, end2, *scan ); </div><div class="line">        <span class="keyword">if</span>( matches == <span class="number">0</span> || <span class="built_in">std</span>::count( scan, end1, *scan ) != matches ) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;            </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec = &#123; <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">7</span> &#125;;</div><div class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; lst = &#123; <span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span> &#125;;</div><div class="line"><span class="keyword">if</span>( is_permutation( vec.cbegin(), vec.cend(), lst.cbegin() ) ) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"vec and lst have equal elements"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// vec and lst have equal elements</span></div></pre></td></tr></table></figure></p>
<p>　　其重载版本：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ForwardIterator1, <span class="keyword">typename</span> ForwardIterator2, <span class="keyword">typename</span> BinaryPredicate&gt;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_permutation</span><span class="params">( ForwardIterator1 beg1, ForwardIterator1 end1, ForwardIterator2 beg2, </span></span></div><div class="line">                     BinaryPredicate predicate ) &#123;</div><div class="line">    <span class="keyword">for</span>( ; beg1 != end1; ++beg1, ++beg2 ) &#123;</div><div class="line">        <span class="keyword">if</span>( !<span class="keyword">bool</span>( predicate( *beg1, *beg2 ) ) ) &#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>( beg1 == end1 ) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">auto</span> end2 = beg2;</div><div class="line">    <span class="built_in">std</span>::advance( end2, <span class="built_in">std</span>::distance( beg1, end1 ) );</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">auto</span> scan = beg1; scan != end1; ++scan ) &#123;</div><div class="line">        <span class="keyword">using</span> <span class="built_in">std</span>::placeholders::<span class="number">_1</span>;</div><div class="line">        <span class="keyword">if</span>( scan != <span class="built_in">std</span>::find_if( beg1, scan, <span class="built_in">std</span>::bind( predicate, <span class="number">_1</span>, *scan ) ) ) &#123;</div><div class="line">            <span class="keyword">continue</span>;             </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">auto</span> matches = <span class="built_in">std</span>::count_if( beg2, end2, <span class="built_in">std</span>::bind( predicate, <span class="number">_1</span>, *scan ) );</div><div class="line">        <span class="keyword">if</span>( matches == <span class="number">0</span> || </div><div class="line">            matches != <span class="built_in">std</span>::count_if( scan, end1, <span class="built_in">std</span>::bind( predicate, <span class="number">_1</span>, *scan ) ) ) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;            </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　例如，我们可以判断两个输入范围中奇数和偶数的个数是否相同，这样，整数就只有奇数和偶数两种类型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</div><div class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; lst = &#123; <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">11</span> &#125;;</div><div class="line"><span class="keyword">if</span>( is_permutation( vec.cbegin(), vec.cend(), lst.cbegin(), </div><div class="line">                    []( <span class="keyword">int</span> elem1, <span class="keyword">int</span> elem2 ) &#123;</div><div class="line">                        <span class="keyword">return</span> elem1 % <span class="number">2</span> == elem2 % <span class="number">2</span>;</div><div class="line">                    &#125;) ) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"numbers of even and odd elements match"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// numbers of even and odd elements match</span></div></pre></td></tr></table></figure></p>
<h2 id="寻找不相同的值"><a href="#寻找不相同的值" class="headerlink" title="寻找不相同的值"></a>寻找不相同的值</h2><p>　　可以使用<code>mismatch()</code>来寻找两个输入范围中第一个不相同的元素，分别对两个范围中相对应的元素进行比较，比较的次数取决于第一个范围中的元素数目。<code>mismatch()</code>将返回<code>std::pair&lt;&gt;</code>对象，包含两个迭代器，分别指向两个输入范围中第一个不同的元素。若无法找到不同的值，则返回的<code>std::pair&lt;&gt;</code>其第一个成员为<code>end1</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator1, <span class="keyword">typename</span> InputIterator2&gt;</div><div class="line"><span class="built_in">std</span>::pair&lt;InputIterator1, InputIterator2&gt;</div><div class="line">mismatch( InputIterator1 beg1, InputIterator1 end1, InputIterator2 beg2 ) &#123;</div><div class="line">    <span class="keyword">for</span>( ; beg1 != end1; ++beg1, ++beg2 ) &#123;</div><div class="line">        <span class="keyword">if</span>( *beg1 != *beg2 ) &#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> &#123; beg1, beg2 &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</div><div class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; lst = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">3</span> &#125;;</div><div class="line"><span class="keyword">auto</span> dif = mismatch( vec.cbegin(), vec.cend(), lst.cbegin() );</div><div class="line"><span class="keyword">if</span>( dif.first == vec.cend() ) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"no mismatch"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"first mismatch: "</span> &lt;&lt; *(dif.first) &lt;&lt; <span class="string">" and "</span>&lt;&lt; *(dif.second) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// first mismatch: 3 and 4</span></div></pre></td></tr></table></figure></p>
<p>　　<code>mismatch()</code>的重载版本：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator1, <span class="keyword">typename</span> InputIterator2, <span class="keyword">typename</span> BinaryPredicate&gt;</div><div class="line"><span class="built_in">std</span>::pair&lt;InputIterator1, InputIterator2&gt;</div><div class="line">mismatch( InputIterator1 beg1, InputIterator1 end1, InputIterator2 beg2, BinaryPredicate predicate ) &#123;</div><div class="line">    <span class="keyword">for</span>( ; beg1 != end1; ++beg1, ++beg2 ) &#123;</div><div class="line">        <span class="keyword">if</span>( !predicate( *beg1, *beg2 ) ) &#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> &#123; beg1, beg2 &#125;;   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　例如，在第一个范围中寻找一个元素，使得这个元素大于第二个范围中相应的元素：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</div><div class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; lst = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">3</span> &#125;;</div><div class="line"><span class="keyword">auto</span> dif = mismatch( vec.cbegin(), vec.cend(), lst.cbegin(), <span class="built_in">std</span>::less_equal&lt;<span class="keyword">int</span>&gt;() );</div><div class="line"><span class="keyword">if</span>( dif.first == vec.cend() ) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"always less-or-equal"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"not less-or-equal: "</span> &lt;&lt; *(dif.first) &lt;&lt; <span class="string">" and "</span>&lt;&lt; *(dif.second) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// not less-or-equal: 6 and 3</span></div></pre></td></tr></table></figure></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://book.douban.com/subject/10440485/" target="_blank" rel="external">The C++ Standard Library Second Edition</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/02/07/自制STL之最值算法/" itemprop="url">
                  自制 STL -- 最值算法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-02-07T13:59:05+08:00" content="2015-02-07">
              2015-02-07
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/自制STL/" itemprop="url" rel="index">
                    <span itemprop="name">自制STL</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>　　可以使用<code>min_element()</code>来寻找输入范围元素的最小值：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator, <span class="keyword">typename</span> Comp&gt;</div><div class="line"><span class="function">ForwardIterator <span class="title">min_element</span><span class="params">( ForwardIterator beg, ForwardIterator end, Comp comp )</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>( beg == end ) &#123;</div><div class="line">        <span class="keyword">return</span> beg;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">auto</span> min = beg;</div><div class="line">    <span class="keyword">while</span>( ++beg != end ) &#123;</div><div class="line">        <span class="keyword">if</span>( comp( *beg, *min ) ) &#123;</div><div class="line">            min = beg;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> min;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator&gt;</div><div class="line"><span class="function">ForwardIterator <span class="title">min_element</span><span class="params">( ForwardIterator beg, ForwardIterator end )</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> min_element( beg, end, <span class="built_in">std</span>::less&lt;<span class="keyword">decltype</span>(*beg)&gt;() );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec = &#123; <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-3</span>, <span class="number">-4</span>, <span class="number">-5</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;; </div><div class="line"><span class="keyword">auto</span> min = min_element( vec.cbegin(), vec.cend() );</div><div class="line"><span class="keyword">if</span>( min != vec.cend() ) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"minimum element: "</span> &lt;&lt; *min &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// minimum element: -5</span></div><div class="line"><span class="keyword">auto</span> absMin = min_element( vec.cbegin(), vec.cend(), </div><div class="line">                           []( <span class="keyword">int</span> elem1, <span class="keyword">int</span> elem2 ) &#123;</div><div class="line">                               <span class="keyword">return</span> <span class="built_in">abs</span>( elem1 ) &lt; <span class="built_in">abs</span>( elem2 );</div><div class="line">                           &#125;);</div><div class="line"><span class="keyword">if</span>( absMin != vec.cend() ) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"minimum absolute element: "</span> &lt;&lt; *absMin &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// minimum absolute element: 0</span></div></pre></td></tr></table></figure></p>
<p>　　可以使用<code>max_element()</code>来寻找输入范围元素的最小值：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator, <span class="keyword">typename</span> Comp&gt;</div><div class="line"><span class="function">ForwardIterator <span class="title">max_element</span><span class="params">( ForwardIterator beg, ForwardIterator end, Comp comp )</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>( beg == end ) &#123;</div><div class="line">        <span class="keyword">return</span> beg;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">auto</span> max = beg;</div><div class="line">    <span class="keyword">while</span>( ++beg != end ) &#123;</div><div class="line">        <span class="keyword">if</span>( comp( *max, *beg ) ) &#123;</div><div class="line">            max = beg;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> max;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator&gt;</div><div class="line"><span class="function">ForwardIterator <span class="title">max_element</span><span class="params">( ForwardIterator beg, ForwardIterator end )</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> max_element( beg, end, <span class="built_in">std</span>::less&lt;<span class="keyword">decltype</span>(*beg)&gt;() );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec = &#123; <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-3</span>, <span class="number">-4</span>, <span class="number">-5</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;; </div><div class="line"><span class="keyword">auto</span> max = max_element( vec.cbegin(), vec.cend() );</div><div class="line"><span class="keyword">if</span>( max != vec.cend() ) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"maximum element: "</span> &lt;&lt; *max &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// maximum element: 3</span></div><div class="line"><span class="keyword">auto</span> absMax = max_element( vec.cbegin(), vec.cend(), </div><div class="line">                           []( <span class="keyword">int</span> elem1, <span class="keyword">int</span> elem2 ) &#123;</div><div class="line">                               <span class="keyword">return</span> <span class="built_in">abs</span>( elem1 ) &lt; <span class="built_in">abs</span>( elem2 );</div><div class="line">                           &#125;);</div><div class="line"><span class="keyword">if</span>( absMax != vec.cend() ) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"maximum absolute element: "</span> &lt;&lt; *absMax &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// maximum absolute element: -5</span></div></pre></td></tr></table></figure></p>
<p>　　可以使用<code>minmax_element()</code>来寻找输入范围元素的最小值和最大值：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator, <span class="keyword">typename</span> Comp&gt;</div><div class="line"><span class="built_in">std</span>::pair&lt;ForwardIterator, ForwardIterator&gt;</div><div class="line">minmax_element( ForwardIterator beg, ForwardIterator end, Comp comp ) &#123;</div><div class="line">    <span class="keyword">if</span>( beg == end ) &#123;</div><div class="line">        <span class="keyword">return</span> &#123; beg, beg &#125;;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">auto</span> min = beg, max = beg;</div><div class="line">    <span class="keyword">while</span>( ++beg != end ) &#123;</div><div class="line">        <span class="keyword">if</span>( comp( *beg, *min ) ) &#123;</div><div class="line">            min = beg;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>( comp( *max, *beg ) ) &#123;</div><div class="line">            max = beg;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> &#123; min, max &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator&gt;</div><div class="line"><span class="built_in">std</span>::pair&lt;ForwardIterator, ForwardIterator&gt;</div><div class="line">minmax_element( ForwardIterator beg, ForwardIterator end ) &#123;</div><div class="line">    <span class="keyword">return</span> minmax_element( beg, end, <span class="built_in">std</span>::less&lt;<span class="keyword">decltype</span>(*beg)&gt;() );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec = &#123; <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-3</span>, <span class="number">-4</span>, <span class="number">-5</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</div><div class="line"><span class="keyword">auto</span> iter = minmax_element( vec.cbegin(), vec.cend() );</div><div class="line"><span class="keyword">if</span>( iter.first != vec.cend() ) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"minimum element: "</span> &lt;&lt; *(iter.first) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// minimum element: -5</span></div><div class="line"><span class="keyword">if</span>( iter.second != vec.cend() ) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"maximum element: "</span> &lt;&lt; *(iter.second) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// maximum element: 3</span></div></pre></td></tr></table></figure></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://book.douban.com/subject/10440485/" target="_blank" rel="external">The C++ Standard Library Second Edition</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/02/07/自制STL之搜索算法/" itemprop="url">
                  自制 STL -- 搜索算法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-02-07T10:36:18+08:00" content="2015-02-07">
              2015-02-07
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/自制STL/" itemprop="url" rel="index">
                    <span itemprop="name">自制STL</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="搜索单个元素"><a href="#搜索单个元素" class="headerlink" title="搜索单个元素"></a>搜索单个元素</h2><p>　　使用<code>find()</code>可以在输入范围中查找指定的元素，并返回指向迭代器，指向这个元素在输入范围中第一次出现的位置：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function">InputIterator <span class="title">find</span><span class="params">( InputIterator beg, InputIterator end, <span class="keyword">const</span> T &amp;value )</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span>( ; beg != end &amp;&amp; *beg != value; ++beg )</div><div class="line">        ;</div><div class="line">    <span class="keyword">return</span> beg;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　例如，在输入的所有整数中查找所有的<code>2</code>:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;; </div><div class="line"><span class="keyword">for</span>( <span class="keyword">auto</span> iter = vec.cbegin(); ( iter = find( iter, vec.cend(), <span class="number">2</span> ) ) != vec.cend(); ++iter ) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="string">" "</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 2 2</span></div></pre></td></tr></table></figure></p>
<p>　　使用<code>find_if()</code>则可以在输入范围中查找第一个符合条件的元素，并返回指向这个元素的迭代器：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> UnaryPredicate&gt;</div><div class="line"><span class="function">InputIterator <span class="title">find_if</span><span class="params">( InputIterator beg, InputIterator end, UnaryPredicate predicate )</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span>( ; beg != end &amp;&amp; !predicate( *beg ); ++beg )</div><div class="line">        ;</div><div class="line">    <span class="keyword">return</span> beg;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　例如，令输入范围中的所有奇数乘以<code>10</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> isOdd = []( <span class="keyword">int</span> elem ) &#123;</div><div class="line">    <span class="keyword">return</span> elem % <span class="number">2</span> != <span class="number">0</span>;</div><div class="line">&#125;;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;; </div><div class="line"><span class="keyword">for</span>( <span class="keyword">auto</span> iter = vec.begin(); ( iter = find_if( iter, vec.end(), isOdd ) ) != vec.end(); ++iter ) &#123;</div><div class="line">    *iter *= <span class="number">10</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span>( <span class="keyword">auto</span> elem : vec ) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; elem &lt;&lt; <span class="string">" "</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 10 2 30 4 50 10 2 30 4 50</span></div></pre></td></tr></table></figure></p>
<p>　　使用<code>find_if_not()</code>则可以在输入范围中查找第一个不符合条件的元素，并返回指向这个元素的迭代器：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> UnaryPredicate&gt;</div><div class="line"><span class="function">InputIterator <span class="title">find_if_not</span><span class="params">( InputIterator beg, InputIterator end, UnaryPredicate predicate )</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span>( ; beg != end &amp;&amp; predicate( *beg ); ++beg )</div><div class="line">        ;</div><div class="line">    <span class="keyword">return</span> beg;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　例如，令输入范围中的所有偶数乘以<code>10</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> isOdd = []( <span class="keyword">int</span> elem ) &#123;</div><div class="line">    <span class="keyword">return</span> elem % <span class="number">2</span> != <span class="number">0</span>;</div><div class="line">&#125;;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;; </div><div class="line"><span class="keyword">for</span>( <span class="keyword">auto</span> iter = vec.begin(); ( iter = find_if_not( iter, vec.end(), isOdd ) ) != vec.end(); ++iter )&#123;</div><div class="line">    *iter *= <span class="number">10</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span>( <span class="keyword">auto</span> elem : vec ) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; elem &lt;&lt; <span class="string">" "</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 1 20 3 40 5 1 20 3 40 5</span></div></pre></td></tr></table></figure></p>
<h2 id="搜索相同的相邻元素"><a href="#搜索相同的相邻元素" class="headerlink" title="搜索相同的相邻元素"></a>搜索相同的相邻元素</h2><p><img src="/images/data-structure/find2.png" alt=""><br>　　可以使用<code>adjacent_find()</code>在<code>[beg, end)</code>中查找第一组相同的相邻元素，返回一个迭代器，指向这组相同元素的第一个元素，要是找不到，就返回<code>end</code>，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">8</span> &#125;;</div><div class="line"><span class="keyword">auto</span> pos = mystl::adjacent_find( vec.cbegin(), vec.cend() );</div><div class="line"><span class="keyword">if</span>( pos != vec.cend() ) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; *pos &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 5</span></div></pre></td></tr></table></figure></p>
<p>　　算法的实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">namespace</span> mystl &#123;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator, <span class="keyword">typename</span> BinaryPredicate&gt;</div><div class="line"><span class="function">ForwardIterator <span class="title">adjacent_find</span><span class="params">( ForwardIterator beg, ForwardIterator end, </span></span></div><div class="line">                               BinaryPredicate predicate ) &#123;</div><div class="line">    <span class="keyword">if</span>( beg == end ) &#123;</div><div class="line">        <span class="keyword">return</span> end;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">auto</span> previous = beg;</div><div class="line">    <span class="keyword">while</span>( ++beg != end ) &#123;</div><div class="line">        <span class="keyword">if</span>( predicate( *previous, *beg ) ) &#123;</div><div class="line">            <span class="keyword">return</span> previous;</div><div class="line">        &#125;</div><div class="line">        ++previous;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> end;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator&gt;</div><div class="line"><span class="function">ForwardIterator <span class="title">adjacent_find</span><span class="params">( ForwardIterator beg, ForwardIterator end )</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> adjacent_find( beg, end, <span class="built_in">std</span>::equal_to&lt;<span class="keyword">decltype</span>(*beg)&gt;&#123;&#125; );</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;;    <span class="comment">// namespace mystl</span></div></pre></td></tr></table></figure></p>
<h2 id="查找首个子范围"><a href="#查找首个子范围" class="headerlink" title="查找首个子范围"></a>查找首个子范围</h2><p>　　可以使用<code>search(beg, end, subBeg, subEnd)</code>在输入范围<code>[beg, end)</code>中查找子范围<code>[subBeg, subEnd)</code>，若查找得到这个子范围，那么<code>search()</code>就会返回迭代器，指向查找到的子范围的第一个元素，若查找不到子范围，就返回<code>end</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; range = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, &#125;;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; subRange = &#123; <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</div><div class="line"><span class="keyword">auto</span> pos = range.cbegin();</div><div class="line"><span class="keyword">auto</span> end = range.cend();</div><div class="line"><span class="keyword">while</span>( ( pos = <span class="built_in">std</span>::search( pos, end, subRange.cbegin(), subRange.cend() ) ) != end ) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"subRange found starting index: "</span> </div><div class="line">         &lt;&lt; <span class="built_in">std</span>::distance( range.cbegin(), pos ) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    ++pos; </div><div class="line">&#125;</div><div class="line"><span class="comment">/***</span></div><div class="line">subRange found starting index: 2</div><div class="line">subRange found starting index: 9</div><div class="line">***/</div></pre></td></tr></table></figure></p>
<p>　　具体实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">namespace</span> mystl &#123;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator1, <span class="keyword">typename</span> ForwardIterator2&gt;</div><div class="line"><span class="function">ForwardIterator1 <span class="title">search</span><span class="params">( ForwardIterator1 beg, ForwardIterator1 end, </span></span></div><div class="line">                         ForwardIterator2 searchBeg, ForwardIterator2 searchEnd ) &#123;</div><div class="line">    <span class="keyword">if</span>( searchBeg == searchEnd ) &#123;</div><div class="line">        <span class="keyword">return</span> beg;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">auto</span> start = beg;</div><div class="line">    <span class="keyword">while</span>( ( start = mystl::find( start, end, *searchBeg ) ) != end ) &#123;</div><div class="line">        <span class="keyword">auto</span> i = start;</div><div class="line">        <span class="keyword">auto</span> j = searchBeg;</div><div class="line">        <span class="keyword">while</span>( ++j != searchEnd &amp;&amp; ++i != end &amp;&amp; *i == *j )</div><div class="line">            ;</div><div class="line">        <span class="keyword">if</span>( j == searchEnd ) &#123;</div><div class="line">            <span class="keyword">return</span> start;</div><div class="line">        &#125;</div><div class="line">        ++start;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> end; </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator1, <span class="keyword">typename</span> ForwardIterator2, <span class="keyword">typename</span> BinaryPredicate&gt;</div><div class="line"><span class="function">ForwardIterator1 <span class="title">search</span><span class="params">( ForwardIterator1 beg, ForwardIterator1 end,</span></span></div><div class="line">                         ForwardIterator2 searchBeg, ForwardIterator2 searchEnd,</div><div class="line">                         BinaryPredicate predicate ) &#123;</div><div class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::placeholders::<span class="number">_1</span>;</div><div class="line">    <span class="keyword">if</span>( searchBeg == searchEnd ) &#123;</div><div class="line">        <span class="keyword">return</span> beg;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">auto</span> start = beg;</div><div class="line">    <span class="keyword">while</span>( ( start = mystl::find_if( start, end, <span class="built_in">std</span>::bind( predicate, <span class="number">_1</span>, *searchBeg ) ) ) != end ) &#123;</div><div class="line">        <span class="keyword">auto</span> i = start;</div><div class="line">        <span class="keyword">auto</span> j = searchBeg;</div><div class="line">        <span class="keyword">while</span>( ++j != searchEnd &amp;&amp; ++i != end &amp;&amp; predicate( *i, *j ) )</div><div class="line">            ;</div><div class="line">        <span class="keyword">if</span>( j == searchEnd ) &#123;</div><div class="line">            <span class="keyword">return</span> start;</div><div class="line">        &#125;</div><div class="line">        ++start;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> end;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;;    <span class="comment">// namespace mystl</span></div></pre></td></tr></table></figure></p>
<h2 id="寻找最后一个子范围"><a href="#寻找最后一个子范围" class="headerlink" title="寻找最后一个子范围"></a>寻找最后一个子范围</h2><p>　　我们知道，<code>search()</code>用来在输入范围中寻找第一个子范围，与此相反，<code>find_end()</code>则用来在输入范围中寻找最后一个子范围。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; coll = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span> &#125;;</div><div class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; subColl = &#123; <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</div><div class="line"><span class="keyword">auto</span> pos = mystl::find_end( coll.cbegin(), coll.cend(), subColl.cbegin(), subColl.cend() );</div><div class="line"><span class="keyword">if</span>( pos != coll.cend() ) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"subcoll found starting with index: "</span> </div><div class="line">         &lt;&lt; <span class="built_in">std</span>::distance( coll.cbegin(), pos ) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125; </div><div class="line"><span class="comment">// subcoll found starting with index: 9</span></div></pre></td></tr></table></figure></p>
<p>　　<code>find_end()</code>的具体实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">namespace</span> mystl &#123;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator1, <span class="keyword">typename</span> ForwardIterator2&gt;</div><div class="line"><span class="function">ForwardIterator1 <span class="title">find_end</span><span class="params">( ForwardIterator1 beg, ForwardIterator1 end,</span></span></div><div class="line">                           ForwardIterator2 searchBeg, ForwardIterator2 searchEnd ) &#123;</div><div class="line">    <span class="keyword">auto</span> pos = mystl::search( beg, end, searchBeg, searchEnd );</div><div class="line">    <span class="keyword">if</span>( pos == end ) &#123;</div><div class="line">        <span class="keyword">return</span> end;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">auto</span> nextPos = pos;</div><div class="line">    <span class="keyword">while</span>( ( nextPos = mystl::search( nextPos, end, searchBeg, searchEnd ) ) != end ) &#123;</div><div class="line">        pos = nextPos;</div><div class="line">        ++nextPos;</div><div class="line">    &#125; </div><div class="line">    <span class="keyword">return</span> pos;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator1, <span class="keyword">typename</span> ForwardIterator2, <span class="keyword">typename</span> BinaryPredicate&gt;</div><div class="line"><span class="function">ForwardIterator1 <span class="title">find_end</span><span class="params">( ForwardIterator1 beg, ForwardIterator1 end, </span></span></div><div class="line">                           ForwardIterator2 searchBeg, ForwardIterator2 searchEnd,</div><div class="line">                           BinaryPredicate predicate ) &#123;</div><div class="line">    <span class="keyword">auto</span> pos = mystl::search( beg, end, searchBeg, searchEnd, predicate );</div><div class="line">    <span class="keyword">if</span>( pos == end ) &#123;</div><div class="line">        <span class="keyword">return</span> end;</div><div class="line">    &#125; </div><div class="line">    <span class="keyword">auto</span> nextPos = pos;</div><div class="line">    <span class="keyword">while</span>( ( nextPos = mystl::search( nextPos, end, searchBeg, searchEnd, predicate ) ) != end ) &#123;</div><div class="line">        pos = nextPos;</div><div class="line">        ++nextPos;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> pos;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;;    <span class="comment">// namespace mystl</span></div></pre></td></tr></table></figure></p>
<h2 id="寻找多个可能值中的一个"><a href="#寻找多个可能值中的一个" class="headerlink" title="寻找多个可能值中的一个"></a>寻找多个可能值中的一个</h2><p>　　使用<code>find_first_of()</code>算法能返回两个范围中第一个相同的元素，若不存在相同的元素，则返回<code>end</code>迭代器，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; coll = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;;</div><div class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; searchColl = &#123; <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</div><div class="line"><span class="keyword">auto</span> pos = mystl::find_first_of( coll.cbegin(), coll.cend(), </div><div class="line">                                 searchColl.cbegin(), searchColl.cend() );</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"first element of searchcoll in coll is element "</span> &lt;&lt; *pos &lt;&lt; <span class="built_in">endl</span>; </div><div class="line"><span class="keyword">auto</span> reversePos = mystl::find_first_of( coll.crbegin(), coll.crend(), </div><div class="line">                                        searchColl.cbegin(), searchColl.cend() );</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"last element of searchcoll in coll is element "</span> &lt;&lt; *reversePos &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"><span class="comment">/***</span></div><div class="line">first element of searchcoll in coll is element 3</div><div class="line">last element of searchcoll in coll is element 5</div><div class="line">***/</div></pre></td></tr></table></figure></p>
<p>　　<code>find_first_of()</code>的实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">namespace</span> mystl &#123;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> ForwardIterator&gt;</div><div class="line"><span class="function">InputIterator <span class="title">find_first_of</span><span class="params">( InputIterator beg, InputIterator end, </span></span></div><div class="line">                             ForwardIterator searchBeg, ForwardIterator searchEnd ) &#123;</div><div class="line">    <span class="keyword">for</span>( ; beg != end; ++beg ) &#123;</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">auto</span> iter = searchBeg; iter != searchEnd; ++iter ) &#123;</div><div class="line">            <span class="keyword">if</span>( *beg == *iter ) &#123;</div><div class="line">                <span class="keyword">return</span> beg;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> end;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> ForwardIterator, <span class="keyword">typename</span> BinaryPredicate&gt;</div><div class="line"><span class="function">InputIterator <span class="title">find_first_of</span><span class="params">( InputIterator beg, InputIterator end, </span></span></div><div class="line">                             ForwardIterator searchBeg, ForwardIterator searchEnd,</div><div class="line">                             BinaryPredicate predicate ) &#123;</div><div class="line">    <span class="keyword">for</span>( ; beg != end; ++beg ) &#123;</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">auto</span> iter = searchBeg; iter != searchEnd; ++iter ) &#123;</div><div class="line">            <span class="keyword">if</span>( predicate( *beg, *iter ) ) &#123;</div><div class="line">                <span class="keyword">return</span> beg;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> end;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;;    <span class="comment">// namespace mystl</span></div></pre></td></tr></table></figure></p>
<h2 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h2><p>　　有时需要在有序的范围中搜索特定元素，那么这时可以使用<code>binary_search()</code>算法。注意，调用<code>binary_search()</code>之前需要确保<strong>输入范围是有序的</strong>。根据迭代器的不同，例如，要是迭代器是<code>random iterator</code>，那么算法的时间复杂度为<code>O(log N)</code>，而对于其它的迭代器，由于需要对元素线性访问，因此，时间复杂度为<code>O(N)</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">namespace</span> mystl &#123;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator, <span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">binary_search</span><span class="params">( ForwardIterator beg, ForwardIterator end, <span class="keyword">const</span> T &amp;elem )</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>( beg == end ) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">auto</span> size = <span class="built_in">std</span>::distance( beg, end );</div><div class="line">    <span class="keyword">auto</span> middle = beg;</div><div class="line">    <span class="built_in">std</span>::advance( middle, size / <span class="number">2</span> );</div><div class="line">    <span class="keyword">if</span>( elem &lt; *middle ) &#123;</div><div class="line">        <span class="keyword">return</span> mystl::binary_search( beg, middle, elem );</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>( *middle &lt; elem ) &#123;</div><div class="line">        <span class="keyword">return</span> mystl::binary_search( ++middle, end, elem );</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Comp&gt;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">binary_search</span><span class="params">( ForwardIterator beg, ForwardIterator end, <span class="keyword">const</span> T &amp;elem, Comp comp )</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>( beg == end ) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">auto</span> size = <span class="built_in">std</span>::distance( beg, end );</div><div class="line">    <span class="keyword">auto</span> middle = beg;</div><div class="line">    <span class="built_in">std</span>::advance( middle, size / <span class="number">2</span> );</div><div class="line">    <span class="keyword">if</span>( comp( elem, *middle ) ) &#123;</div><div class="line">        <span class="keyword">return</span> mystl::binary_search( beg, middle, elem, comp );</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>( comp( *middle, elem ) ) &#123;</div><div class="line">        <span class="keyword">return</span> mystl::binary_search( ++middle, end, elem, comp );</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;;    <span class="comment">// namespace mystl</span></div></pre></td></tr></table></figure></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://book.douban.com/subject/10440485/" target="_blank" rel="external">The C++ Standard Library Second Edition</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/02/07/自制STL之计数算法/" itemprop="url">
                  自制 STL -- 计数算法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-02-07T09:50:21+08:00" content="2015-02-07">
              2015-02-07
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/自制STL/" itemprop="url" rel="index">
                    <span itemprop="name">自制STL</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>　　使用<code>count()</code>，我们可以统计某个元素在输入范围中的出现次数：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">template &lt;typename InputIterator, typename T&gt;</div><div class="line">auto count( InputIterator beg, InputIterator end, </div><div class="line">            const T &amp;value ) -&gt; decltype( beg - beg ) </div><div class="line">&#123;</div><div class="line">    auto num = beg - beg;</div><div class="line">    while( beg != end ) &#123;</div><div class="line">        if( *beg++ == value ) &#123;</div><div class="line">            ++num;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return num;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec = &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span> &#125;;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; count( vec.cbegin(), vec.cend(), <span class="number">0</span> ) &lt;&lt; <span class="built_in">endl</span>;            <span class="comment">// 0</span></div><div class="line"><span class="built_in">cout</span> &lt;&lt; count( vec.cbegin(), vec.cend(), <span class="number">1</span> ) &lt;&lt; <span class="built_in">endl</span>;            <span class="comment">// 2</span></div></pre></td></tr></table></figure></p>
<p>　　另外，也可以统计输入范围中满足条件的元素的次数：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">template &lt;typename InputIterator, typename UnaryPredicate&gt;</div><div class="line">auto count_if( InputIterator beg, InputIterator end, </div><div class="line">               UnaryPredicate predicate ) -&gt; decltype( beg - beg ) </div><div class="line">&#123;</div><div class="line">    auto num = beg - beg;</div><div class="line">    while( beg != end ) &#123;</div><div class="line">        if( predicate( *beg++ ) ) &#123;</div><div class="line">            ++num;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return num;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　例如，在输入范围的整数中统计有多少个奇数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec = &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span> &#125;;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; count_if( vec.cbegin(), vec.cend(), </div><div class="line">                  []( <span class="keyword">int</span> elem ) &#123;</div><div class="line">                      <span class="keyword">return</span> elem % <span class="number">2</span> != <span class="number">0</span>; </div><div class="line">                  &#125;) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"><span class="comment">// 4</span></div><div class="line"><span class="built_in">cout</span> &lt;&lt; count_if( vec.cbegin(), vec.cend(),</div><div class="line">                  bind( modulus&lt;<span class="keyword">int</span>&gt;(), placeholders::<span class="number">_1</span>, <span class="number">2</span> ) );</div><div class="line"><span class="comment">// 4</span></div></pre></td></tr></table></figure></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://book.douban.com/subject/10440485/" target="_blank" rel="external">The C++ Standard Library Second Edition</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/02/06/自制STL之数值算法/" itemprop="url">
                  自制 STL -- 数值算法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-02-06T16:41:17+08:00" content="2015-02-06">
              2015-02-06
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/自制STL/" itemprop="url" rel="index">
                    <span itemprop="name">自制STL</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="累加算法"><a href="#累加算法" class="headerlink" title="累加算法"></a>累加算法</h2><p>　　算法<code>accumulate()</code>用来对<code>[beg, end)</code>之间的元素进行累加，<code>initValue</code>为初始值：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function">T <span class="title">accumulate</span><span class="params">( InputIterator beg, InputIterator end, T initValue )</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span>( ; beg != end; ++beg ) &#123;</div><div class="line">        initValue = initValue + *beg;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> initValue;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> T, <span class="keyword">typename</span> BinaryFunction&gt;</div><div class="line"><span class="function">T <span class="title">accumulate</span><span class="params">( InputIterator beg, InputIterator end, T initValue, </span></span></div><div class="line">              BinaryFunction binaryFunc ) &#123;</div><div class="line">    <span class="keyword">for</span>( ; beg != end; ++beg ) &#123;</div><div class="line">        initValue = binaryFunc( initValue, *beg );</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> initValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　例如，可以对元素执行加法求和：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intVec = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"sum: "</span> &lt;&lt; accumulate( intVec.cbegin(), intVec.cend(), <span class="number">0</span> ) &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">// sum: 15</span></div></pre></td></tr></table></figure></p>
<p>　　也可以对元素执行累乘：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intVec = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"product: "</span> &lt;&lt; accumulate( intVec.cbegin(), intVec.cend(), <span class="number">1</span>, </div><div class="line">                                   multiplies&lt;<span class="keyword">int</span>&gt;() ) &lt;&lt; <span class="built_in">endl</span>;               <span class="comment">// product: 120</span></div></pre></td></tr></table></figure></p>
<p>　　也可以对用户自定义的类型进行累加：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Person</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Person( <span class="built_in">string</span> name, <span class="keyword">double</span> salary )</div><div class="line">        : name_( name ), salary_( salary ) &#123; &#125;</div><div class="line">    <span class="function"><span class="keyword">double</span> <span class="title">salary</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> salary_;</div><div class="line">    &#125; </div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="built_in">string</span> name_;</div><div class="line">    <span class="keyword">double</span> salary_;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="built_in">vector</span>&lt;Person&gt; personVec;</div><div class="line">personVec.emplace_back( <span class="string">"Senlin"</span>, <span class="number">9879.9</span> );</div><div class="line">personVec.emplace_back( <span class="string">"Handsome"</span>, <span class="number">9999.5</span> );</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"total salary: "</span> &lt;&lt; accumulate( personVec.cbegin(), personVec.cend(), <span class="number">0.0</span>, </div><div class="line">                                        []( <span class="keyword">double</span> init, <span class="keyword">const</span> Person &amp;person ) &#123;</div><div class="line">                                            <span class="keyword">return</span> init + person.salary();</div><div class="line">                                        &#125;) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"><span class="comment">// total salary: 19879.4</span></div></pre></td></tr></table></figure></p>
<h2 id="内部乘积"><a href="#内部乘积" class="headerlink" title="内部乘积"></a>内部乘积</h2><p>　　<code>inner_product()</code>算法接受两个输入范围，假定<code>elem1</code>和<code>elem2</code>分别为两个范围中的元素，那么内部乘积的求值过程需要不断地执行以下过程：<br><code>initValue = initValue + elem1 * elem2</code><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function">T <span class="title">inner_product</span><span class="params">( InputIterator beg1, InputIterator end1, InputIterator beg2, T initValue )</span> </span>&#123;</div><div class="line">    <span class="keyword">while</span>( beg1 != end1 ) &#123;</div><div class="line">        initValue = initValue + (*beg1++) * (*beg2++);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> initValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　假定我们需要计算 $ 1\times 1 + 2\times 2 + 3\times 3 + 4\times 4 + 5\times 5$ 的值：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intVec = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; inner_product( intVec.cbegin(), intVec.cend(), intVec.cbegin(), <span class="number">0</span> ) &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">// 55</span></div></pre></td></tr></table></figure></p>
<p>　　其重载版本，这个版本的内部乘积需要不断执行以下过程：<br><code>initValue = binaryFunc1( initValue, binaryFunc2( elem1, elem2 ) )</code><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> T, <span class="keyword">typename</span> BinaryFunction1, <span class="keyword">typename</span> BinaryFunction2&gt;</div><div class="line"><span class="function">T <span class="title">inner_product</span><span class="params">( InputIterator beg1, InputIterator end1, InputIterator beg2, T initValue,</span></span></div><div class="line">                 BinaryFunction1 binaryFunc1, BinaryFunction2 binaryFunc2 ) &#123;</div><div class="line">    <span class="keyword">while</span>( beg1 != end1 ) &#123;</div><div class="line">        initValue = binaryFunc1( initValue, binaryFunc2( *beg1++, *beg2++ ) );</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> initValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　例如，假定需要计算 $(1+1) \times (2+2) \times (3+3) \times (4+4) \times (5+5)$ 的值：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intVec = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; inner_product( intVec.cbegin(), intVec.cend(), intVec.cbegin(), <span class="number">1</span>, </div><div class="line">                       multiplies&lt;<span class="keyword">int</span>&gt;(), plus&lt;<span class="keyword">int</span>&gt;() ) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"><span class="comment">// 3840</span></div></pre></td></tr></table></figure></p>
<h2 id="部分求和"><a href="#部分求和" class="headerlink" title="部分求和"></a>部分求和</h2><p>　　<code>partial_sum()</code>用来对数组元素执行部分求和，假定输入范围的元素为<code>[elem1, elem2, elem3, ...]</code>，那么输出范围的元素为<code>[elem1, elem1 + elem2, elem1 + elem2 + elem3, ...]</code>。<br>　　<code>partial_sum()</code>返回的迭代器将指向写入的最后一个元素其后的一个位置。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> OutputIterator&gt;</div><div class="line"><span class="function">OutputIterator <span class="title">partial_sum</span><span class="params">( InputIterator sourceBeg, InputIterator sourceEnd, </span></span></div><div class="line">                            OutputIterator desBeg ) &#123;</div><div class="line">    <span class="keyword">if</span>( sourceBeg == sourceEnd ) &#123;</div><div class="line">        <span class="keyword">return</span> desBeg;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">auto</span> total = *sourceBeg++;</div><div class="line">    *desBeg++ = total;</div><div class="line">    <span class="keyword">while</span>( sourceBeg != sourceEnd ) &#123;</div><div class="line">        total = total + *sourceBeg++;     </div><div class="line">        *desBeg++ = total;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> desBeg;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　例如，假定输入范围为<code>[1, 2, 3, 4, 5]</code>，那么：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intVec = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</div><div class="line">partial_sum( intVec.cbegin(), intVec.cend(), ostream_iterator&lt;<span class="keyword">int</span>&gt;( <span class="built_in">cout</span>, <span class="string">" "</span> ) );</div><div class="line"><span class="comment">// 1 3 6 10 15</span></div></pre></td></tr></table></figure></p>
<p>　　其重载的版本，假定输入范围的元素为<code>[elem1, elem2, elem3, ...]</code>，那么输出范围的元素为：<br><code>[elem1, binaryFunc( elem1, elem2 ), binaryFunc( binaryFunc( elem1, elem2 ), elem3 ), ...]</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> OutputIterator, <span class="keyword">typename</span> BinaryFunction&gt;</div><div class="line"><span class="function">OutputIterator <span class="title">partial_sum</span><span class="params">( InputIterator sourceBeg, InputIterator sourceEnd, </span></span></div><div class="line">                            OutputIterator desBeg, BinaryFunction binaryFunc ) &#123;</div><div class="line">    <span class="keyword">if</span>( sourceBeg == sourceEnd ) &#123;</div><div class="line">        <span class="keyword">return</span> desBeg;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">auto</span> total = *sourceBeg++;</div><div class="line">    *desBeg++ = total;</div><div class="line">    <span class="keyword">while</span>( sourceBeg != sourceEnd ) &#123;</div><div class="line">        total = binaryFunc( total, *sourceBeg++ );</div><div class="line">        *desBeg++ = total;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> desBeg;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　假定输入范围为<code>[1, 2, 3, 4, 5]</code>，那么：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intVec = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</div><div class="line">partial_sum( intVec.cbegin(), intVec.cend(), ostream_iterator&lt;<span class="keyword">int</span>&gt;( <span class="built_in">cout</span>, <span class="string">" "</span> ),</div><div class="line">             multiplies&lt;<span class="keyword">int</span>&gt;() );</div><div class="line"><span class="comment">// 1 2 6 24 120</span></div></pre></td></tr></table></figure></p>
<h2 id="求相邻差"><a href="#求相邻差" class="headerlink" title="求相邻差"></a>求相邻差</h2><p>　　<code>adjacent_difference()</code>用来对数组相邻元素求差，假定输入范围的元素为<code>[elem1, elem2, elem3, ...]</code>，那么输出范围的元素为<code>[elem1, elem2 - elem1, elem3 - elem2, ...]</code>。<br>　　<code>adjacent_difference()</code>返回的迭代器将指向写入的最后一个元素其后的一个位置。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> OutputIterator&gt;</div><div class="line"><span class="function">OutputIterator <span class="title">adjacent_difference</span><span class="params">( InputIterator sourceBeg, InputIterator sourceEnd, </span></span></div><div class="line">                                    OutputIterator desBeg ) &#123;</div><div class="line">    <span class="keyword">if</span>( sourceBeg == sourceEnd ) &#123;</div><div class="line">        <span class="keyword">return</span> desBeg;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">auto</span> previous = *sourceBeg++;</div><div class="line">    *desBeg++ = previous;</div><div class="line">    <span class="keyword">while</span>( sourceBeg != sourceEnd ) &#123;</div><div class="line">        <span class="keyword">auto</span> tmp = *sourceBeg++;</div><div class="line">        *desBeg++ = tmp - previous;</div><div class="line">        previous = tmp;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> desBeg;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　假定输入范围为<code>[1, 2, 3, 4, 5]</code>，那么：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intVec = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</div><div class="line">adjacent_difference( intVec.cbegin(), intVec.cend(), ostream_iterator&lt;<span class="keyword">int</span>&gt;( <span class="built_in">cout</span>, <span class="string">" "</span> ) );</div><div class="line"><span class="comment">// 1 1 1 1 1</span></div></pre></td></tr></table></figure></p>
<p>　　其重载版本，假定输入范围的元素为<code>[elem1, elem2, elem3, ...]</code>，那么输出范围的元素为：<br><code>[elem1, binaryFunc( elem2, elem1 ), binaryFunc( elem3, elem2 ), ...]</code><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> OutputIterator, <span class="keyword">typename</span> BinaryFunction&gt;</div><div class="line"><span class="function">OutputIterator <span class="title">adjacent_difference</span><span class="params">( InputIterator sourceBeg, InputIterator sourceEnd, </span></span></div><div class="line">                                    OutputIterator desBeg, BinaryFunction binaryFunc ) &#123;</div><div class="line">    <span class="keyword">if</span>( sourceBeg == sourceEnd ) &#123;</div><div class="line">        <span class="keyword">return</span> desBeg;</div><div class="line">    &#125; </div><div class="line">    <span class="keyword">auto</span> previous = *sourceBeg++;</div><div class="line">    *desBeg++ = previous;</div><div class="line">    <span class="keyword">while</span>( sourceBeg != sourceEnd ) &#123;</div><div class="line">        <span class="keyword">auto</span> tmp = *sourceBeg++;</div><div class="line">        *desBeg++ = binaryFunc( tmp, previous );</div><div class="line">        previous = tmp;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> desBeg;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　假定输入范围为<code>[1, 2, 3, 4, 5]</code>，那么：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intVec = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</div><div class="line">adjacent_difference( intVec.cbegin(), intVec.cend(), </div><div class="line">                     ostream_iterator&lt;<span class="keyword">int</span>&gt;( <span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">" "</span> ), <span class="built_in">std</span>::multiplies&lt;<span class="keyword">int</span>&gt;() );</div><div class="line"><span class="comment">// 1 2 6 12 20</span></div></pre></td></tr></table></figure></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://book.douban.com/subject/10440485/" target="_blank" rel="external">The C++ Standard Library Second Edition</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/02/05/高阶过程/" itemprop="url">
                  Scheme -- 高阶过程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-02-05T09:00:42+08:00" content="2015-02-05">
              2015-02-05
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/编程方法/" itemprop="url" rel="index">
                    <span itemprop="name">编程方法</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>　　对于求和公式$\sum_{i=a}^b i$，我们可以将其转换成为<code>Scheme</code>程序：<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">sum-int</span> a b)</div><div class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&gt;</span></span> a b)</div><div class="line">      <span class="number">0</span></div><div class="line">      (<span class="name"><span class="builtin-name">+</span></span> a </div><div class="line">	 (<span class="name">sum-int</span> (<span class="name">1+</span> a) b))))</div></pre></td></tr></table></figure></p>
<p>　　类似地，对于公式$\sum_{i=a}^b i^2$，将其转换成为程序：<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">square</span> a) (<span class="name"><span class="builtin-name">*</span></span> a a))</div><div class="line"></div><div class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">sum-square</span> a b)</div><div class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&gt;</span></span> a b)</div><div class="line">      <span class="number">0</span></div><div class="line">      (<span class="name"><span class="builtin-name">+</span></span> (<span class="name">square</span> a)</div><div class="line">	 (<span class="name">sum-square</span> (<span class="name">1+</span> a) b))))</div></pre></td></tr></table></figure></p>
<p>　　好了，可以发现，这两段程序及其相似。<br>　　接着，考虑另一公式<br>$ \sum_{i=a}^b \frac{1}{i(i+2)}, \quad i = a, a+4, a+8, a+12, a+16 … $　<br>　　例如，当$a$的值为$1$，$b$的值为$9$，那么公式可以展开成为：<br>$ \frac{1}{3} + \frac{1}{5\times 7} + \frac{1}{9 \times 11}$<br>　　同样，我们可以将其转换成为程序：<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">sum-fraction</span> a b)</div><div class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&gt;</span></span> a b)</div><div class="line">      <span class="number">0</span></div><div class="line">      (<span class="name"><span class="builtin-name">+</span></span> (<span class="name"><span class="builtin-name">/</span></span> <span class="number">1</span> (<span class="name"><span class="builtin-name">*</span></span> a (<span class="name"><span class="builtin-name">+</span></span> a <span class="number">2</span>)))</div><div class="line">	 (<span class="name">sum-fraction</span> (<span class="name"><span class="builtin-name">+</span></span> a <span class="number">4</span>) b))))</div></pre></td></tr></table></figure></p>
<h2 id="传递函数"><a href="#传递函数" class="headerlink" title="传递函数"></a>传递函数</h2><p>　　显然，这三段程序及其相似，那么，我们需要找出一种方式高度地概括这三段程序，以提高代码的可复用性：<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">sum</span> term a next b)</div><div class="line">  (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&gt;</span></span> a b)</div><div class="line">      <span class="number">0</span></div><div class="line">      (<span class="name"><span class="builtin-name">+</span></span> (<span class="name">term</span> a)</div><div class="line">	 (<span class="name">sum</span> term </div><div class="line">	      (<span class="name">next</span> a) </div><div class="line">	      next </div><div class="line">	      b))))</div></pre></td></tr></table></figure></p>
<p>　　可以看到，<code>term</code>和<code>next</code>均为匿名函数，那么我们可以根据<code>sum</code>例程改写上面三段程序：<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">sum-int</span> a b)</div><div class="line">  (<span class="name">sum</span> (<span class="name"><span class="builtin-name">lambda</span></span>(i) i) </div><div class="line">       a </div><div class="line">       <span class="number">1</span>+ </div><div class="line">       b))</div><div class="line"></div><div class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">sum-square</span> a b)</div><div class="line">  (<span class="name">sum</span> (<span class="name"><span class="builtin-name">lambda</span></span>(i) (<span class="name"><span class="builtin-name">*</span></span> i i))</div><div class="line">       a </div><div class="line">       <span class="number">1</span>+ </div><div class="line">       b))</div><div class="line"></div><div class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">sum-fraction</span> a b)</div><div class="line">  (<span class="name">sum</span> (<span class="name"><span class="builtin-name">lambda</span></span>(i) (<span class="name"><span class="builtin-name">/</span></span> <span class="number">1</span> (<span class="name"><span class="builtin-name">*</span></span> i (<span class="name"><span class="builtin-name">+</span></span> i <span class="number">2</span>))))</div><div class="line">       a </div><div class="line">       (<span class="name"><span class="builtin-name">lambda</span></span>(i) (<span class="name"><span class="builtin-name">+</span></span> i <span class="number">4</span>))</div><div class="line">       b))</div></pre></td></tr></table></figure></p>
<p>　　我们将具体的功能实现放在<code>sum</code>例程中，这样做会带来很多好处，例如，假定我们将<code>sum</code>例程从递归式改成迭代式：<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">sum</span> term a next b)</div><div class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">iter</span> i init)</div><div class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&gt;</span></span> i b)</div><div class="line">	init </div><div class="line">	(<span class="name">iter</span> (<span class="name">next</span> i)</div><div class="line">	      (<span class="name"><span class="builtin-name">+</span></span> (<span class="name">term</span> i)</div><div class="line">		 init))))</div><div class="line">  (<span class="name">iter</span> a <span class="number">0</span>))</div></pre></td></tr></table></figure></p>
<p>　　此时，我们修改<code>sum</code>例程而不会影响那些使用<code>sum</code>例程的程序。</p>
<h2 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h2><p>　　让我们编写一个求平方根的程序：<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">average</span> x y)</div><div class="line">  (<span class="name"><span class="builtin-name">/</span></span> (<span class="name"><span class="builtin-name">+</span></span> x y) </div><div class="line">     <span class="number">2</span>))</div><div class="line"></div><div class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name"><span class="builtin-name">sqrt</span></span> x)</div><div class="line">  (<span class="name"><span class="builtin-name">define</span></span> tolerance <span class="number">0.00001</span>)</div><div class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">good-enough</span> y)</div><div class="line">    (<span class="name"><span class="builtin-name">&lt;</span></span> (<span class="name"><span class="builtin-name">abs</span></span> (<span class="name"><span class="builtin-name">-</span></span> (<span class="name"><span class="builtin-name">*</span></span> y y) x)) </div><div class="line">       tolerance))</div><div class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">improve</span> y)</div><div class="line">    (<span class="name">average</span> (<span class="name"><span class="builtin-name">/</span></span> x y) </div><div class="line">	     y))</div><div class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">try</span> y)</div><div class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name">good-enough</span> y)</div><div class="line">	y</div><div class="line">	(<span class="name">try</span> (<span class="name">improve</span> y))))</div><div class="line">  (<span class="name">try</span> <span class="number">1</span>))</div></pre></td></tr></table></figure></p>
<p>　　例如，假定我们要找出<code>x</code>的平方根<code>y</code>，可以先假定<code>y</code>的值为<code>1</code>，此时，一旦我们发现<code>y</code>的值并不合适，那么可以令<code>y</code>的值为<code>(x/y + y)/2</code>，不断地循环这个过程，直到<code>y</code>的平方与<code>x</code>足够的接近，那么就可以认为<code>y</code>就是<code>x</code>的平方根。<br>　　从更广的角度上看，求平方根的过程就是一个不断迭代的过程，直到程序到达某一点时，这个迭代过程就会结束。那么，我们可以定义一个<code>fixed-point</code>函数，接受一个 lambda 表达式<code>f</code>和一个初始值<code>start</code>作为参数。<code>f</code>会接受一个输入值并产生新的值作为返回值，而<code>fixed-point</code>的任务就是不断地执行<code>f</code>，一旦<code>f</code>的返回值是我们所需要的，那么这个迭代的过程就会停止：<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">fixed-point</span> f start)</div><div class="line">  (<span class="name"><span class="builtin-name">define</span></span> tolerance <span class="number">0.00001</span>)</div><div class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">close-enough</span> u v)</div><div class="line">    (<span class="name"><span class="builtin-name">&lt;</span></span> (<span class="name"><span class="builtin-name">abs</span></span> (<span class="name"><span class="builtin-name">-</span></span> u v)) tolerance))</div><div class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">iter</span> old new)</div><div class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name">close-enough</span> old new)</div><div class="line">	new </div><div class="line">	(<span class="name">iter</span> new (<span class="name">f</span> new))))</div><div class="line">  (<span class="name">iter</span> start (<span class="name">f</span> start)))</div></pre></td></tr></table></figure></p>
<p>　　我们可以利用这个<code>fixed-point</code>函数来实现求解平方根的程序：<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name"><span class="builtin-name">sqrt</span></span> x)</div><div class="line">  (<span class="name">fixed-point</span> (<span class="name"><span class="builtin-name">lambda</span></span>(y) (<span class="name">average</span> (<span class="name"><span class="builtin-name">/</span></span> x y) y))</div><div class="line">	       <span class="number">1</span>))</div></pre></td></tr></table></figure></p>
<p>　　注意，这里<code>fixed-point</code>接受一个 lambda 表达式，用来求<code>x/y</code>和<code>y</code>的平均值。同样，从更广的角度看，我们可以定义一个<code>average-damp</code>函数，接受一个 lambda 表达式，并返回另一个 lambda 表达式：<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">define</span></span> average-damp </div><div class="line">  (<span class="name"><span class="builtin-name">lambda</span></span>(f)</div><div class="line">    (<span class="name"><span class="builtin-name">lambda</span></span>(x) (<span class="name">average</span> (<span class="name">f</span> x) x))))</div></pre></td></tr></table></figure></p>
<p>　　可以看到，<code>average-damp</code>代表一种求解平均数的过程。由此，求解平方根的程序可以这样写：<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name"><span class="builtin-name">sqrt</span></span> x)</div><div class="line">  (<span class="name">fixed-point</span> </div><div class="line">   (<span class="name">average-damp</span> (<span class="name"><span class="builtin-name">lambda</span></span>(y) (<span class="name"><span class="builtin-name">/</span></span> x y)))</div><div class="line">		 <span class="number">1</span>))</div></pre></td></tr></table></figure></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://book.douban.com/subject/1148282/" target="_blank" rel="external">Structure and Interpretation of Computer Programs</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/02/03/算法-基数排序/" itemprop="url">
                  排序算法（四）-- 基数排序
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-02-03T19:23:52+08:00" content="2015-02-03">
              2015-02-03
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/算法分析/" itemprop="url" rel="index">
                    <span itemprop="name">算法分析</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="低位优先"><a href="#低位优先" class="headerlink" title="低位优先"></a>低位优先</h2><p>　　低位优先（Least Significant Digit first）的字符串排序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">LSDSort</span><span class="params">( <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;arr, <span class="keyword">int</span> stringLen )</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span> BUCKETS = <span class="number">256</span>;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; buffer( arr.size() );</div><div class="line"></div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> pos = stringLen - <span class="number">1</span>; pos &gt;= <span class="number">0</span>; --pos )</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; count( BUCKETS + <span class="number">1</span> );</div><div class="line"></div><div class="line">        <span class="keyword">for</span>( <span class="keyword">const</span> <span class="keyword">auto</span> &amp;elem : arr )</div><div class="line">        &#123;</div><div class="line">            ++count[ elem[pos] + <span class="number">1</span> ];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> b = <span class="number">0</span>; b &lt; BUCKETS; ++b )</div><div class="line">        &#123;</div><div class="line">            count[b + <span class="number">1</span>] += count[b];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span>( <span class="keyword">const</span> <span class="keyword">auto</span> &amp;elem : arr )</div><div class="line">        &#123;</div><div class="line">            buffer[ count[ elem[pos] ]++ ] = elem;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="built_in">std</span>::copy( buffer.begin(), buffer.end(), arr.begin() );</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/02/01/快速排序/" itemprop="url">
                  排序算法（三）-- 快速排序
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-02-01T11:51:13+08:00" content="2015-02-01">
              2015-02-01
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/算法分析/" itemprop="url" rel="index">
                    <span itemprop="name">算法分析</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>　　快速排序的时间复杂度为$O(N\log N)$，快速排序算法首先会将数组划分成为两个子数组，其次调用其自身递归地对两个子数组进行排序。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Comp = <span class="built_in">std</span>::less&lt;T&gt;&gt;</div><div class="line"><span class="keyword">void</span> quick_sort( T arr[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, Comp comp = Comp&#123;&#125; ) &#123;</div><div class="line">    <span class="keyword">if</span>( hi &lt;= lo ) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">auto</span> pos = partition( arr, lo, hi, comp );</div><div class="line">    quick_sort( arr, lo, pos - <span class="number">1</span>, comp );</div><div class="line">    quick_sort( arr, pos + <span class="number">1</span>, hi, comp );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="划分元素"><a href="#划分元素" class="headerlink" title="划分元素"></a>划分元素</h2><p>　　快速排序的关键部分在于<code>partition()</code>函数，用来将数组划分成为两个子数组。实际上，<code>partition()</code>返回的变量<code>pos</code>为元素的下标，那么元素<code>arr[pos]</code>将作为两个子数组的界定元素，也就是说，左子数组的元素都小于<code>arr[pos]</code>，而右子数组的元素都大于<code>arr[pos]</code>，那么很明显，<code>arr[pos]</code>元素已经在其最终位置上，无需再被挪动了。在划分数组之后，只要对左子数组和右子数组进行排序，那么整个数组就是有序的了。</p>
<p>　　那么问题来了，我们要选择哪一个元素当做界定元素呢？<br>　　为了方便，我们通常选择数组的最后一个元素作为界定元素，例如，对于以下数组：<br><img src="/images/data-structure/pm1.png" alt=""><br>　　在执行划分操作之后，界定元素<code>35</code>将大于其左边的元素，并且小于其右边的元素：<br><img src="/images/data-structure/pm2.png" alt=""></p>
<p>　　在划分操作中，我们使用<code>left</code>和<code>right</code>两个索引，实际的执行过程：</p>
<ul>
<li>不断地向右移动<code>left</code>，直到<code>left</code>指向的元素大于或等于界定元素<code>elem</code>。</li>
<li>不断地向左移动<code>right</code>，直到<code>right</code>指向的元素小于或等于界定元素<code>elem</code>。</li>
<li>若<code>left</code>和<code>right</code>有效，那么就对其指向的两个元素进行交换。</li>
<li>当<code>left</code>和<code>right</code>相遇之后，就将元素<code>arr[right]</code>与右子数组的第一个元素进行交换。</li>
</ul>
<p>　　例如，假定我们需要对以下数组进行排序：<br><img src="/images/data-structure/pm1.png" alt=""></p>
<p>　　那么划分操作实际的执行过程：<br><img src="/images/data-structure/pm3.png" alt="">–&gt;<img src="/images/data-structure/pm4.png" alt=""><br><img src="/images/data-structure/pm5.png" alt="">–&gt;<img src="/images/data-structure/pm6.png" alt=""><br><img src="/images/data-structure/pm7.png" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Comp&gt;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">( T arr[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, Comp comp )</span> </span>&#123;</div><div class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::swap;</div><div class="line">    <span class="keyword">auto</span> left = lo - <span class="number">1</span>, right = hi;</div><div class="line">    <span class="keyword">auto</span> elem = arr[hi];</div><div class="line">    <span class="keyword">while</span>( <span class="literal">true</span> ) &#123;</div><div class="line">        <span class="keyword">while</span>( comp( arr[++left], elem ) )</div><div class="line">            ;</div><div class="line">        <span class="keyword">while</span>( right &gt; lo &amp;&amp; comp( elem, arr[--right] ) )</div><div class="line">            ;</div><div class="line">        <span class="keyword">if</span>( left &gt;= right ) &#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        swap( arr[left], arr[right] );</div><div class="line">    &#125;</div><div class="line">    swap( arr[left], arr[hi] );</div><div class="line">    <span class="keyword">return</span> left;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　在划分操作中，为了保证<code>left</code>和<code>right</code>不会越界访问，我们需要考虑两种情况：</p>
<ul>
<li>界定元素是数组中的最大元素。</li>
<li>界定元素是数组中的最小元素。</li>
</ul>
<p>　　由于界定元素是数组的最后一个元素，因此，当界定元素为数组的最大元素时，<code>left</code>并不会越界访问。而当界定元素是数组的最小元素时，则在访问元素<code>arr[--right]</code>时需要保证<code>right &gt; lo</code>即可。<br>　　在划分操作中，很明显，要是<code>arr[left]</code>和<code>arr[right]</code>与界定元素相等，那么<code>arr[left]</code>和<code>arr[right]</code>之间也会进行交换，因此，划分操作不是<code>stable</code>的。<br>　　可以看到，在<code>partition()</code>操作中，我们向右移动<code>left</code>，向左移动<code>right</code>，当<code>left</code>指向的元素等于界定元素，就会停止移动<code>left</code>，对于<code>right</code>来说也是这样。那么，假定<code>left</code>和<code>right</code>指向的元素等于界定元素，那么需要对<code>left</code>和<code>right</code>指向的元素进行交换。尽管这样做会带来交换元素的开销，但可以防止出现最坏情况，例如，假定数组包含很多具有相同键的元素，那么快速排序算法的执行性能仍然是<code>O(N logN)</code>。<br>　　相反地，考虑存在<code>partition()</code>的另一种实现：当<code>left</code>指向的元素等于界定元素时并不会停止向右移动，同样，当<code>right</code>指向的元素等于界定元素时并不会停止向左移动。要是<code>partition()</code>是这样实现的，假定需要排序的数组中包含大量键重复的元素，那么此时快速排序的执行性能将退化到$O(N^2)$。</p>
<h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><p>　　若需要排序的数组本来就是有序的，那么这时执行快速排序将会出现最坏情况，比较的次数将接近于$N^2/2$，因此，时间复杂度为$O(N^2)$。<br>　　而在平均情况下，快速排序将进行$2N\ln N$次比较，大约等于$1.39N\lg N$次比较。</p>
<h2 id="非递归快速排序"><a href="#非递归快速排序" class="headerlink" title="非递归快速排序"></a>非递归快速排序</h2><p>　　使用递归的快速排序算法对随机文件排序，那么，递归栈的深度与<code>log N</code>成正比。然而，我们需要分析最坏情况，考虑到若文件中的数据在排序之前就是有序的，那么，递归栈的深度将与<code>N</code>成正比。我们知道，若递归栈的深度过大，程序可能在运行时奔溃。为了解决这个问题，我们可以使用非递归的快速排序算法。<br>　　在递归的<code>quick_sort()</code>算法里面，使用<code>partition()</code>函数将数组划分成为两个子数组，在分别对两个子数组执行<code>quick_sort()</code>进行排序。为了将这个递归算法转换成为非递归算法，我们可以将<code>quick_sort()</code>的<code>lo</code>和<code>hi</code>参数存储在一个<code>stack</code>容器中。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">( <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; &amp;coll, <span class="keyword">int</span> first, <span class="keyword">int</span> second )</span> </span>&#123;</div><div class="line">    coll.push( first );</div><div class="line">    coll.push( second );</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">( <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; &amp;coll )</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> value = coll.top();</div><div class="line">    coll.pop();</div><div class="line">    <span class="keyword">return</span> value;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 非递归版本 1</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Comp = <span class="built_in">std</span>::less&lt;T&gt;&gt;</div><div class="line"><span class="keyword">void</span> quick_sort( T arr[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, Comp comp = Comp&#123;&#125; ) &#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</div><div class="line">    push( s, lo, hi );</div><div class="line">    <span class="keyword">while</span>( !s.empty() ) &#123;</div><div class="line">        hi = pop( s );</div><div class="line">        lo = pop( s );</div><div class="line">        <span class="keyword">if</span>( hi &lt;= lo ) &#123;</div><div class="line">            <span class="keyword">continue</span>; </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> pos = partition( arr, lo, hi, comp );</div><div class="line">        <span class="keyword">if</span>( pos - lo &gt; hi - pos ) &#123;</div><div class="line">            push( s, lo, pos - <span class="number">1</span> );</div><div class="line">            push( s, pos + <span class="number">1</span>, hi );</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            push( s, pos + <span class="number">1</span>, hi );</div><div class="line">            push( s, lo, pos - <span class="number">1</span> );</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　这里需要注意的是，对数组进行划分，我们将得到两组数组的边界，分别是<code>[lo, pos - 1]</code>和<code>[pos + 1, hi]</code>，那么问题来了，我们要将哪组数组边界先压入<code>stack</code>中呢？<br>　　实际上数组边界范围大的那一组需要先入栈，而范围小的那一组后入栈。认真考虑一下就可以知道，这样将使得<code>stack</code>的大小保持尽量小，并且，这样做使得无论在哪种情况下，<code>stack</code>的大小都不会超过<code>log N</code>。</p>
<p>　　实际上我们可以对非递归的快速排序算法进行改进，可以看到，每次向<code>stack</code>中压入两组数组边界之后，再下一次循环中又需要从<code>stack</code>中弹出一组数组边界，显然，这样做是没有必要的。实际上，在每次循环中，只需要压入范围较大的那组边界，而将范围较小的那组边界用来直接设置<code>lo</code>和<code>hi</code>的值。<br>　　另外一点可以改进的是，当我们将数组边界压入<code>stack</code>之前，可以先判断这个数组边界中的元素数目是否小于或等于<code>1</code>，若是，那么就不需要将这个边界压入<code>stack</code>中了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 非递归版本 2</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Comp = <span class="built_in">std</span>::less&lt;T&gt;&gt;</div><div class="line"><span class="keyword">void</span> quick_sort( T arr[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, Comp comp = Comp&#123;&#125; ) &#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        <span class="keyword">if</span>( hi &lt;= lo ) &#123;</div><div class="line">            hi = pop( s );</div><div class="line">            lo = pop( s );</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> pos = partition( arr, lo, hi, comp );</div><div class="line">        <span class="keyword">if</span>( pos - lo &gt; hi - pos ) &#123;</div><div class="line">            <span class="keyword">if</span>( pos - <span class="number">1</span> &gt; lo ) &#123;</div><div class="line">                push( s, lo, pos - <span class="number">1</span> );</div><div class="line">            &#125;</div><div class="line">            lo = pos + <span class="number">1</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span>( hi &gt; pos + <span class="number">1</span> ) &#123;</div><div class="line">                push( s, pos + <span class="number">1</span>, hi );</div><div class="line">            &#125;</div><div class="line">            hi = pos - <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">while</span>( !s.empty() );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="三数取中划分"><a href="#三数取中划分" class="headerlink" title="三数取中划分"></a>三数取中划分</h2><p>　　我们知道，若原来的数组是有序的，使用快速排序来排定数组，那么执行性能将退化到$O(N^2)$。仔细考虑，要是在数组中随机选择元素充当界定元素，那么就可以避免这种情况。一种更简单的办法就是，计算数组第一个元素，中间元素和最后一个元素的中位数，并选择这个中位数作为界定元素。实际上，对于随机数组，相较于原来的划分方式，三数取中划分也会提升快速排序算法的执行性能。<br>　　实际上，还可以做的更好。考虑到对于部分有序的数组来说，使用插入排序可以取得比较好的执行性能。我们可以设定一个<code>M</code>值，当数组元素的数目小于<code>M</code>时，就不对数组作处理，当数组元素数目大于<code>M</code>时，就是用快速排序来排定数组。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Comp&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort_helper</span><span class="params">( T arr[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, Comp comp )</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>( hi - lo &lt;= <span class="number">10</span> ) &#123;                         <span class="comment">// 数组元素数目小于或等于 11 则不作处理</span></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::swap;</div><div class="line">    swap( arr[(lo + hi) / <span class="number">2</span>], arr[hi - <span class="number">1</span>] );      <span class="comment">// 将数组中间元素与 arr[hi - 1] 交换</span></div><div class="line">    <span class="keyword">if</span>( comp( arr[hi - <span class="number">1</span>], arr[lo] ) ) &#123;</div><div class="line">        swap( arr[hi - <span class="number">1</span>], arr[lo] );</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>( comp( arr[hi], arr[lo] ) ) &#123;</div><div class="line">        swap( arr[hi], arr[lo] );</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>( comp( arr[hi], arr[hi - <span class="number">1</span>] ) ) &#123;</div><div class="line">        swap( arr[hi], arr[hi - <span class="number">1</span>] );</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> pos = partition( arr, lo + <span class="number">1</span>, hi - <span class="number">1</span>, comp );</div><div class="line">    quick_sort_helper( arr, lo, pos - <span class="number">1</span>, comp );</div><div class="line">    quick_sort_helper( arr, pos + <span class="number">1</span>, hi, comp );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　首先，我们将数组中间元素与<code>arr[hi - 1]</code>交换，接着，对元素<code>arr[lo]</code>、<code>arr[hi - 1]</code>和<code>arr[hi]</code>这三个元素进行排序，在排序过后，显然，<code>arr[hi - 1]</code>就是这三个元素的中位数，我们将这个中位数作为界定元素，那么，<code>partition()</code>就只需要对<code>arr[lo + 1]</code>和<code>arr[hi - 1]</code>之间的元素做处理就可以了。<br>　　注意到，使用<code>quick_sort_helper()</code>排序后的数组是部分有序的，那么，我们可以使用插入排序继续进行排序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Comp = <span class="built_in">std</span>::less&lt;T&gt;&gt;</div><div class="line"><span class="keyword">void</span> insertion_sort( T arr[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, Comp comp = Comp&#123;&#125; ) &#123;</div><div class="line">    <span class="keyword">if</span>( hi &lt;= lo ) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = lo + <span class="number">1</span>; i &lt;= hi; ++i ) &#123;</div><div class="line">        T elem = <span class="built_in">std</span>::move( arr[i] );</div><div class="line">        <span class="keyword">int</span> j;</div><div class="line">        <span class="keyword">for</span>( j = i; j &gt; lo &amp;&amp; comp( elem, arr[j - <span class="number">1</span>] ); --j ) &#123;</div><div class="line">            arr[j] = <span class="built_in">std</span>::move( arr[j - <span class="number">1</span>] );</div><div class="line">        &#125;</div><div class="line">        arr[j] = <span class="built_in">std</span>::move( elem );</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Comp = <span class="built_in">std</span>::less&lt;T&gt;&gt;</div><div class="line"><span class="keyword">void</span> quick_sort( T arr[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, Comp comp = Comp&#123;&#125; ) &#123;</div><div class="line">    quick_sort_helper( arr, lo, hi, comp );</div><div class="line">    insertion_sort( arr, lo, hi, comp );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="三路划分"><a href="#三路划分" class="headerlink" title="三路划分"></a>三路划分</h2><p>　　当需要排序的数组中包含大量具有相同键的元素时，递归的快速排序算法的复杂度为<code>O(N logN)</code>，实际上，在这种情况下，我们可以做得更好，使算法复杂度降至<code>O(N)</code>。<br>　　我们将元素<code>arr[lo]</code>作为界定元素，使用三个下标<code>le</code>、<code>eq</code>和<code>ge</code>表示三个范围：</p>
<ul>
<li><code>arr[lo]</code>到<code>arr[le - 1]</code>之间的元素都小于界定元素。</li>
<li><code>arr[le]</code>到<code>arr[eq - 1]</code>之间的元素都等于界定元素。</li>
<li><code>arr[ge + 1]</code>到<code>arr[hi]</code>之间的元素都大于界定元素。</li>
<li><code>arr[eq]</code>到<code>arr[ge]</code>之间的元素为未处理元素。<br>　　很明显，三路划分算法将数组中处理过的元素划分为三个范围，这三个范围中的元素分别小于、等于和大于界定元素。我们使用<code>elem</code>来表示界定元素，那么算法的执行过程：</li>
<li>要是<code>arr[eq]</code>小于<code>elem</code>，就将<code>arr[eq]</code>与<code>arr[le]</code>交换，同时向右移动<code>le</code>和<code>eq</code>下标。</li>
<li>要是<code>arr[eq]</code>大于<code>elem</code>，就将<code>arr[eq]</code>与<code>arr[ge]</code>交换，同时向左移动<code>ge</code>下标。</li>
<li>要是<code>arr[eq]</code>等于<code>elem</code>，则向右移动<code>eq</code>。<br>　　例如，我们对以下数组执行三路划分：<br><img src="/images/data-structure/qq1.png" alt="">　–&gt;　<img src="/images/data-structure/qq2.png" alt=""><br><img src="/images/data-structure/qq3.png" alt="">　–&gt;　<img src="/images/data-structure/qq4.png" alt=""><br><img src="/images/data-structure/qq5.png" alt="">  –&gt;  <img src="/images/data-structure/qq6.png" alt=""><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Comp = <span class="built_in">std</span>::less&lt;T&gt;&gt;</div><div class="line"><span class="keyword">void</span> quick_sort( T arr[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, Comp comp = Comp&#123;&#125; ) &#123;</div><div class="line">    <span class="keyword">if</span>( hi &lt;= lo ) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::swap;</div><div class="line">    <span class="keyword">int</span> le = lo, eq = lo + <span class="number">1</span>, ge = hi;</div><div class="line">    <span class="keyword">auto</span> elem = arr[lo];</div><div class="line">    <span class="keyword">while</span>( eq &lt;= ge ) &#123;</div><div class="line">        <span class="keyword">if</span>( comp( arr[eq], elem ) ) &#123;</div><div class="line">            swap( arr[eq++], arr[le++] );</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>( comp( elem, arr[eq] ) ) &#123;</div><div class="line">            swap( arr[eq], arr[ge--] );</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            ++eq;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    quick_sort( arr, lo, le - <span class="number">1</span>, comp );</div><div class="line">    quick_sort( arr, ge + <span class="number">1</span>, hi, comp );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="快速选择"><a href="#快速选择" class="headerlink" title="快速选择"></a>快速选择</h2><p>　　有时我们需要在数组中选择若干个最小的元素，这种选择问题并不要求数组本身是有序的。例如，假定需要在<code>arr[lo]</code>和<code>arr[hi]</code>之间的元素选出<code>k-lo</code>个最小的元素，那么我们就需要使<code>arr[lo]</code>到<code>arr[k - 1]</code>之间的元素小于或等于<code>arr[k]</code>，而使<code>arr[k + 1]</code>到<code>arr[hi]</code>之间的元素大于<code>arr[k]</code>，实际的算法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Comp = <span class="built_in">std</span>::less&lt;T&gt;&gt;</div><div class="line"><span class="keyword">void</span> select( T arr[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> k, Comp comp = Comp&#123;&#125; ) &#123;</div><div class="line">    <span class="keyword">if</span>( hi &lt; lo ) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">auto</span> pos = partition( arr, lo, hi, comp );</div><div class="line">    <span class="keyword">if</span>( k &lt; pos ) &#123;</div><div class="line">        select( arr, lo, pos - <span class="number">1</span>, k, comp );</div><div class="line">    &#125; </div><div class="line">    <span class="keyword">if</span>( k &gt; pos ) &#123;</div><div class="line">        select( arr, pos + <span class="number">1</span>, hi, k, comp );</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　例如，假定我们需要在含有<code>N</code>个元素的数组<code>arr</code>中选出中位数，那么可以这样做：</p>
<pre><code>selection( arr, 0, N - 1, N / 2 );
</code></pre><p>　　那么，元素<code>arr[N / 2]</code>就是数组的中位数。实际上，还可以用非递归算法来实现快速选择算法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Comp = <span class="built_in">std</span>::less&lt;T&gt;&gt;</div><div class="line"><span class="keyword">void</span> select( T arr[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> k, Comp comp = Comp&#123;&#125; ) &#123;</div><div class="line">    <span class="keyword">while</span>( hi &gt; lo ) &#123;</div><div class="line">        <span class="keyword">auto</span> pos = partition( arr, lo, hi );</div><div class="line">        <span class="keyword">if</span>( k &lt; pos ) &#123;</div><div class="line">            hi = pos - <span class="number">1</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>( k &gt; pos ) &#123;</div><div class="line">            lo = pos + <span class="number">1</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.amazon.com/Algorithms-Parts-1-4-Fundamentals-Structure/dp/0201350882" target="_blank" rel="external">Algorithms in C++ 3rd Edition by Robert Sedgewick</a><br><a href="http://www.amazon.com/Data-Structures-Algorithm-Analysis-C/dp/013284737X/ref=sr_1_4?s=books&amp;ie=UTF8&amp;qid=1422255950&amp;sr=1-4&amp;keywords=data+structure+and+algorithm+in+c%2B%2B" target="_blank" rel="external">Data Structures and Algorithm Analysis in C++ 4th Edition by Mark A. Weiss</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/01/28/链表排序算法/" itemprop="url">
                  排序算法（二）-- 链表排序算法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-01-28T15:26:39+08:00" content="2015-01-28">
              2015-01-28
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/算法分析/" itemprop="url" rel="index">
                    <span itemprop="name">算法分析</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>　　对于单向链表，根据头部指针的不同，我们有两种方式来实现链表：</p>
<ul>
<li>一种是使用头部指针指向第一个节点。</li>
<li>另一种则是使用头部指针指向一个哑元节点，而这个哑元节点中包含指向第一个节点的指针。</li>
</ul>
<p>　　好了，假定单向链表中包含两个元素<code>1</code>和<code>2</code>，那么链表的两种表示方式正如下图所示：<br><img src="/images/data-structure/a1.png" alt=""></p>
<p>　　实际上，我们更经常用到第二种方式，即使用头部指针指向哑元节点，并利用哑元节点来指向第一个节点，这种方式在实现的链表操作时更加方便，因为在链表中插入元素时我们并不需要考虑链表是否是空链表，因为链表总是至少会包含一个哑元节点，而付出的代价仅是多分配一个节点的内存。</p>
<h2 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h2><p>　　我们实现一个简易的单向链表，其中使用头部指针指向哑元节点，并利用哑元节点来指向第一个节点：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;queue&gt;</div><div class="line"></div><div class="line">template &lt;typename T&gt;</div><div class="line">class List</div><div class="line">&#123;</div><div class="line">    template &lt;typename Type&gt;</div><div class="line">    friend std::ostream &amp; operator&lt;&lt;( std::ostream &amp;, const List&lt;Type&gt; &amp; );</div><div class="line"></div><div class="line">private:</div><div class="line">    struct Node &#123;</div><div class="line">        T elem;</div><div class="line">        Node *next;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    Node *head = new Node&#123; T&#123;&#125;, nullptr &#125;;                 // head 指向哑元节点</div><div class="line"></div><div class="line">public:</div><div class="line">    List() = default;</div><div class="line">    List( const List &amp; ) = delete;                         // 无法调用 copy constructor</div><div class="line">    List &amp; operator=( const List &amp; ) = delete;             // 无法调用 assignment copy operator</div><div class="line">    virtual ~List() &#123;</div><div class="line">        deleteNode( head-&gt;next );</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void push_front( const T &amp;elem ) &#123;</div><div class="line">        head-&gt;next = new Node&#123; elem, head-&gt;next &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    bool empty() const &#123;</div><div class="line">        return head-&gt;next == nullptr;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    template &lt;typename Comp = std::less&lt;T&gt;&gt;</div><div class="line">    void insertion_sort( Comp comp = Comp&#123;&#125; );             // 插入排序算法 </div><div class="line"></div><div class="line">    template &lt;typename Comp = std::less&lt;T&gt;&gt;</div><div class="line">    void selection_sort( Comp comp = Comp&#123;&#125; );             // 选择排序算法</div><div class="line">   </div><div class="line">    template &lt;typename Comp = std::less&lt;T&gt;&gt;                // 归并排序算法</div><div class="line">    void merge_sort( Comp comp = Comp&#123;&#125; );</div><div class="line"></div><div class="line">private:</div><div class="line">    template &lt;typename Comp&gt;</div><div class="line">    auto merge( Node *left, Node *right, Comp comp ) -&gt; decltype( left );</div><div class="line"></div><div class="line">    template &lt;typename Comp&gt;</div><div class="line">    auto merge_sort( Node *link, Comp comp ) -&gt; decltype( link );</div><div class="line"></div><div class="line">    void deleteNode( Node *nodePtr ) &#123;</div><div class="line">        if( nodePtr == nullptr ) &#123;</div><div class="line">            return;</div><div class="line">        &#125; else &#123;</div><div class="line">            deleteNode( nodePtr-&gt;next );</div><div class="line">            delete nodePtr;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">template &lt;typename T&gt;</div><div class="line">std::ostream &amp; operator&lt;&lt;( std::ostream &amp;os, const List&lt;T&gt; &amp;lst ) &#123;</div><div class="line">    for( auto iter = (lst.head)-&gt;next; iter != nullptr; iter = iter-&gt;next ) &#123;</div><div class="line">        os &lt;&lt; iter-&gt;elem &lt;&lt; " ";</div><div class="line">    &#125;</div><div class="line">    return os;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>　　对链表执行插入排序，除了原来的链表之外，我们需要创建新的链表，用来存储排序后的节点：</p>
<ul>
<li>移出原来链表中的第一个节点。</li>
<li>将移出的这个节点插入到新建的链表中，同时需要保证新建的链表中元素是有序的。</li>
<li>不断地重复这个过程，直到原来的链表中所有节点都被移出。</li>
</ul>
<p>　　下图展示了对节点<code>20</code>进行排序的过程，首先，我们将<code>head</code>链表的第一个节点移出：<br><img src="/images/data-structure/a2.png" alt=""><br>　　其次，需要在链表<code>newHead</code>中找到合适的位置，将移出的节点插入到合适的位置，以维持<code>newHead</code>链表的有序性。<br><img src="/images/data-structure/a3.png" alt=""><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Comp&gt;</div><div class="line"><span class="keyword">void</span> List&lt;T&gt;::insertion_sort( Comp comp ) &#123;</div><div class="line">    <span class="keyword">if</span>( empty() || ( head-&gt;next-&gt;next == <span class="literal">nullptr</span> ) ) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">auto</span> newHead = <span class="keyword">new</span> Node&#123; T&#123;&#125;, <span class="literal">nullptr</span> &#125;;</div><div class="line">    Node *next, *nodeInserted, *current;</div><div class="line">    <span class="keyword">for</span>( nodeInserted = head-&gt;next; nodeInserted != <span class="literal">nullptr</span>; nodeInserted = next ) &#123;</div><div class="line">        next = nodeInserted-&gt;next;</div><div class="line">        <span class="keyword">for</span>( current = newHead; current-&gt;next != <span class="literal">nullptr</span>; current = current-&gt;next ) &#123;</div><div class="line">            <span class="keyword">if</span>( comp( nodeInserted-&gt;elem, current-&gt;next-&gt;elem ) ) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        nodeInserted-&gt;next = current-&gt;next;</div><div class="line">        current-&gt;next = nodeInserted;</div><div class="line">    &#125;</div><div class="line">    head = newHead;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>　　同样，在选择算法中，除了原来的链表之外，我们需要创建新的链表，用来存储排序后的节点：</p>
<ul>
<li>在原来的链表中寻找最大元素所在的节点，并移出这个节点。</li>
<li>将移出的这个节点插入到新建链表的开头。</li>
<li>不断地重复这个过程，直到原来链表中所有节点都被移出。</li>
</ul>
<p>　　例如，在链表的排序过程中，我们首先需要在原来链表中选择包含最大元素的节点，如下图所示，假定这个节点的元素是<code>55</code>，那么就需要将这个节点从链表中移出：<br><img src="/images/data-structure/a4.png" alt=""><br>　　将节点移出之后，由于链表<code>newHead</code>是有序的，因此，只要将移出的元素插入到<code>newHead</code>链表的开头即可：<br><img src="/images/data-structure/a5.png" alt=""><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Comp&gt;</div><div class="line"><span class="keyword">void</span> List&lt;T&gt;::selection_sort( Comp comp ) &#123;</div><div class="line">    <span class="keyword">if</span>( empty() || ( head-&gt;next-&gt;next == <span class="literal">nullptr</span> ) ) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">auto</span> newHead = <span class="keyword">new</span> Node&#123; T&#123;&#125;, <span class="literal">nullptr</span> &#125;;</div><div class="line">    Node *beforeMax, *max;</div><div class="line">    <span class="keyword">while</span>( head-&gt;next != <span class="literal">nullptr</span> ) &#123;</div><div class="line">        beforeMax = head;</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">auto</span> iter = head-&gt;next; iter-&gt;next != <span class="literal">nullptr</span>; iter = iter-&gt;next ) &#123;</div><div class="line">            <span class="keyword">if</span>( comp( beforeMax-&gt;next-&gt;elem, iter-&gt;next-&gt;elem ) ) &#123;</div><div class="line">                beforeMax = iter;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        max = beforeMax-&gt;next;</div><div class="line">        beforeMax-&gt;next = max-&gt;next;</div><div class="line">        max-&gt;next = newHead-&gt;next;</div><div class="line">        newHead-&gt;next = max;</div><div class="line">    &#125;</div><div class="line">    head = newHead;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><p>　　在<a href="http://senlinzhan.github.io/2015/01/26/%E8%87%AA%E5%88%B6STL%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" target="_blank" rel="external">自制STL之基本排序算法</a>中，<code>selection_sort()</code>和<code>bubble_sort()</code>排序算法都可以对标准库的容器<code>forward_list</code>进行排序，也可以对<code>vector</code>或<code>list</code>这些容器进行排序。实际上，在这两个算法中需要使用<code>std::move()</code>或<code>std::swap()</code>来移动或交换元素，然而，当元素所占内存比较大时，这样做的效率比较低。</p>
<p>　　实际上，对链表进行排序时，我们并不需要交换或移动元素，正如<code>List&lt;T&gt;::selection_sort()</code>和<code>List&lt;T&gt;::insertion_sort()</code>所示，执行这两个算法时，链表中节点指针指向的位置将会改变，而元素本身在内存中是不会被移动或交换的，例如，假定在排序之前，链表中指针的指向如下图所示：<br><img src="/images/data-structure/a6.png" alt=""><br>　　那么，在排序过后，链表中指针指向的位置就改变了，而元素的位置则始终没有改变：<br><img src="/images/data-structure/a7.png" alt=""></p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>　　我们使用<code>merge_sort()</code>来实现归并排序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Comp&gt;</div><div class="line"><span class="keyword">void</span> List&lt;T&gt;::merge_sort( Comp comp ) &#123;</div><div class="line">    head-&gt;next = merge_sort( head-&gt;next, comp );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　注意，由于<code>head</code>指向的是哑元节点，因此，<code>head-&gt;next</code>将指向第一个节点。由于归并排序是递归算法，因此，我们将实际的排序任务委托给<code>merge_sort()</code>的重载版本。<br>　　在<code>merge_sort()</code>的重载版本中，我们将<code>link</code>指向的链表分成<code>left</code>和<code>right</code>两部分：<br><img src="/images/data-structure/listme.png" alt=""><br>　　递归地调用<code>merge_sort()</code>对这两部分进行排序，那么<code>left</code>和<code>right</code>指向的链表就是有序的了，接着，再执行<code>merge()</code>对<code>left</code>和<code>right</code>进行合并，那么我们将得到有序的链表。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Comp&gt;</div><div class="line"><span class="keyword">auto</span> List&lt;T&gt;::merge_sort( Node *link, Comp comp ) -&gt; <span class="keyword">decltype</span>( link ) &#123;</div><div class="line">    <span class="keyword">if</span>( link == <span class="literal">nullptr</span> || link-&gt;next == <span class="literal">nullptr</span> ) &#123;        <span class="comment">// 若 link 链路的节点数小于 2，则返回</span></div><div class="line">        <span class="keyword">return</span> link;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">auto</span> left = link;</div><div class="line">    <span class="keyword">auto</span> right = link-&gt;next;</div><div class="line">    <span class="keyword">while</span>( right != <span class="literal">nullptr</span> &amp;&amp; right-&gt;next != <span class="literal">nullptr</span> ) &#123;</div><div class="line">        link = link-&gt;next;</div><div class="line">        right = right-&gt;next-&gt;next;</div><div class="line">    &#125;</div><div class="line">    right = link-&gt;next;</div><div class="line">    link-&gt;next = <span class="literal">nullptr</span>;</div><div class="line">    left = merge_sort( left, comp );</div><div class="line">    right = merge_sort( right, comp );</div><div class="line">    <span class="keyword">return</span> merge( left, right, comp );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　<code>merge()</code>负责将两条有序的链表合并成为一条有序的链表，我们在栈上分配一个哑元节点，以简化合并操作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Comp&gt;</div><div class="line"><span class="keyword">auto</span> List&lt;T&gt;::merge( Node *left, Node *right, Comp comp ) -&gt; <span class="keyword">decltype</span>( left )&#123;</div><div class="line">    Node headNode&#123; T&#123;&#125;, <span class="literal">nullptr</span> &#125;;                               <span class="comment">// 在栈上分配哑元节点</span></div><div class="line">    <span class="keyword">auto</span> headPtr = &amp;headNode;                                    <span class="comment">// headPtr 指向哑元节点</span></div><div class="line">    <span class="keyword">auto</span> current = headPtr;</div><div class="line">    <span class="keyword">while</span>( left != <span class="literal">nullptr</span> &amp;&amp; right != <span class="literal">nullptr</span> ) &#123;</div><div class="line">        <span class="keyword">if</span>( comp( left-&gt;elem, right-&gt;elem ) ) &#123;                  <span class="comment">// 先拼接小的节点</span></div><div class="line">            current-&gt;next = left;</div><div class="line">            current = current-&gt;next;</div><div class="line">            left = left-&gt;next;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            current-&gt;next = right;</div><div class="line">            current = current-&gt;next;</div><div class="line">            right = right-&gt;next;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>( left == <span class="literal">nullptr</span> ) &#123;</div><div class="line">        current-&gt;next = right;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        current-&gt;next = left;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> headPtr-&gt;next;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　实际上，我们可以实现非递归的归并排序算法，首先，我们使用<code>std::queue&lt;Node*&gt;</code>来存储所有节点，每次我们从队列中弹出两条链表，再将这两条链表合并成有序的链表，接着，我们再将合并之后的链表放到队列末尾。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Comp&gt;</div><div class="line"><span class="keyword">auto</span> List&lt;T&gt;::merge_sort( Node *link, Comp comp ) -&gt; <span class="keyword">decltype</span>( link )&#123;</div><div class="line">    <span class="keyword">if</span>( link == <span class="literal">nullptr</span> || link-&gt;next == <span class="literal">nullptr</span> ) &#123;          <span class="comment">// 不处理节点数小于 2 的情况</span></div><div class="line">        <span class="keyword">return</span> link;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;Node*&gt; que;</div><div class="line"></div><div class="line">    Node *current = <span class="literal">nullptr</span>;</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        current = link;</div><div class="line">        link = link-&gt;next;</div><div class="line">        current-&gt;next = <span class="literal">nullptr</span>;</div><div class="line">        que.push( current );</div><div class="line">    &#125; <span class="keyword">while</span>( link != <span class="literal">nullptr</span> );</div><div class="line"></div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        link = que.front(); </div><div class="line">        que.pop();</div><div class="line">        <span class="keyword">if</span>( que.empty() ) &#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">auto</span> right = que.front();</div><div class="line">        que.pop();</div><div class="line">        que.push( merge( link, right, comp ) );</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">while</span>( !que.empty() );</div><div class="line"></div><div class="line">    <span class="keyword">return</span> link;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.amazon.com/Algorithms-Parts-1-4-Fundamentals-Structure/dp/0201350882" target="_blank" rel="external">Algorithms in C++ 3rd Edition by Robert Sedgewick</a></li>
<li><a href="http://www.amazon.com/Data-Structures-Algorithm-Analysis-C/dp/013284737X/ref=sr_1_4?s=books&amp;ie=UTF8&amp;qid=1422255950&amp;sr=1-4&amp;keywords=data+structure+and+algorithm+in+c%2B%2B" target="_blank" rel="external">Data Structures and Algorithm Analysis in C++ 4th Edition by Mark A. Weiss</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/01/26/自制STL之基本排序算法/" itemprop="url">
                  自制 STL -- 基本排序算法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-01-26T13:13:22+08:00" content="2015-01-26">
              2015-01-26
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/自制STL/" itemprop="url" rel="index">
                    <span itemprop="name">自制STL</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>　　假定数组<code>arr</code>中有<code>N</code>个元素，那么选择排序算法的执行过程：</p>
<ul>
<li>首先，我们从数组中选择最小的元素，将这个元素与<code>arr[0]</code>交换，那么，此时<code>arr[0]</code>就能确定了。</li>
<li>接着，我们从<code>arr[1]</code>到<code>arr[N-1]</code>中选择最小的元素，并将这个元素与<code>arr[1]</code>交换，此时<code>arr[1]</code>就已经确定了。</li>
<li>不断地重复这个过程，直到数组的所有元素都是有序的。<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator, <span class="keyword">typename</span> Comp&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">( ForwardIterator first, ForwardIterator last, Comp comp )</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>( first == last ) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::swap;</div><div class="line">    ForwardIterator min, current;</div><div class="line">    <span class="keyword">for</span>( ; first != last; ++ first ) &#123;</div><div class="line">        min = current = first;</div><div class="line">        <span class="keyword">for</span>( ++current; current != last; ++current ) &#123;</div><div class="line">            <span class="keyword">if</span>( comp( *current, *min ) ) &#123;</div><div class="line">                min = current;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>( first != min ) &#123;</div><div class="line">            swap( *first, *min );</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">( ForwardIterator first, ForwardIterator last )</span> </span>&#123;</div><div class="line">    selection_sort( first, last, <span class="built_in">std</span>::less&lt;<span class="keyword">decltype</span>(*first)&gt;&#123;&#125; );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>　　选择排序算法的特性：</p>
<ul>
<li>优点：对于含有<code>N</code>个元素的数组，选择排序最多需要执行<code>N-1</code>次<code>swap()</code>操作。</li>
<li>缺点：无论原先数组的元素是否有序，选择排序算法的执行时间都是相同的，均为$O(N^2)$。</li>
</ul>
<p>　　由于选择排序算法支持<code>forward iterator</code>，因此也可以利用选择排序算法来排序单向链表：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::forward_list&lt;<span class="keyword">int</span>&gt; arr = &#123; <span class="number">89</span>, <span class="number">89</span>, <span class="number">211</span>, <span class="number">23</span>, <span class="number">200</span>, <span class="number">500</span>, <span class="number">2</span>, <span class="number">45</span> &#125;;</div><div class="line">selection_sort( arr.begin(), arr.end() );</div><div class="line"><span class="keyword">for</span>( <span class="keyword">const</span> <span class="keyword">auto</span> &amp;elem : arr ) &#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; elem &lt;&lt; <span class="string">" "</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 2 23 45 89 89 200 211 500</span></div></pre></td></tr></table></figure></p>
<p>　　性能分析：对于选择排序算法，无论输入数据如何，算法最多需要执行<code>N-1</code>次<code>swap()</code>操作，同时，算法需要执行<code>N(N-1)/2</code>次<code>comp()</code>操作。<br>　　由于插入排序算法所需要执行的元素交换操作比较少，因此，若数组中的元素所占内存很大，则<code>swap()</code>操作的开销将比较大，而此时若<code>comp()</code>操作执行很快，那么，在这种场合，使用选择排序算法就比较合适。</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>　　假定数组<code>arr</code>中有<code>N</code>个元素，那么插入排序算法的执行过程：</p>
<ul>
<li>若<code>arr[1]</code>小于<code>arr[0]</code>，那么就交换这两个元素的位置。</li>
<li>若<code>arr[2]</code>小于<code>arr[1]</code>，那么就交换这两个元素的位置，接着，若<code>arr[1]</code>小于<code>arr[0]</code>，就交换这两个元素的位置。</li>
<li>不断重复这个过程，直到数组中全部元素有序。<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 插入排序：版本 1</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> BidirectionalIterator, <span class="keyword">typename</span> Comp&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertion_sort</span><span class="params">( BidirectionalIterator first, BidirectionalIterator last, Comp comp )</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>( first == last ) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::swap;</div><div class="line">    <span class="keyword">auto</span> sorted = first;</div><div class="line">    <span class="keyword">for</span>( ++sorted; sorted != last; ++sorted ) &#123;</div><div class="line">        <span class="keyword">auto</span> left = sorted, current = sorted;</div><div class="line">        <span class="keyword">for</span>( --left; current != first &amp;&amp; comp( *current, *left ); --current )&#123;</div><div class="line">            swap( *current, *left );</div><div class="line">            <span class="keyword">if</span>( left != first ) &#123;                   <span class="comment">// 防止 left 指向无效的范围</span></div><div class="line">                --left;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> BidirectionalIterator&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertion_sort</span><span class="params">( BidirectionalIterator first, BidirectionalIterator last )</span> </span>&#123;</div><div class="line">    insertion_sort( first, last, <span class="built_in">std</span>::less&lt;<span class="keyword">decltype</span>(*first)&gt;&#123;&#125; );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>　　由于插入排序算法支持<code>bidirection iterator</code>，我们可以也利用插入排序算法来排序双向链表：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; arr = &#123; <span class="number">500</span>, <span class="number">20</span>, <span class="number">13</span>, <span class="number">634</span>, <span class="number">2</span>, <span class="number">53</span>, <span class="number">21</span> &#125;;</div><div class="line">insertion_sort( arr.begin(), arr.end() );</div><div class="line"><span class="keyword">for</span>( <span class="keyword">const</span> <span class="keyword">auto</span> &amp;elem : arr ) &#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; elem &lt;&lt; <span class="string">" "</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 2 13 20 21 53 500 634</span></div></pre></td></tr></table></figure></p>
<p>　　实际上我们可以对插入排序算法进行优化，使用移动元素的操作来代替交换元素的操作，假定数组<code>arr</code>中有<code>N</code>个元素，那么优化后的插入排序算法的执行过程：</p>
<ul>
<li>假定<code>a[0]</code>到<code>a[k]</code>的元素是有序的，现在需要<code>a[k+1]</code>在数组中的位置。</li>
<li>将<code>a[k+1]</code>保存在临时变量<code>elem</code>中。</li>
<li>假定<code>a[0]</code>到<code>a[k]</code>中存在元素<code>a[l]</code>小于元素<code>elem</code>，并且<code>a[l+1]</code>大于元素<code>elem</code>，那么就需要将<code>a[l+1]</code>到<code>a[k]</code>之间的所有元素分别向右移动一个位置，这时，<code>a[l+1]</code>就空出来了，接着，执行<code>a[l+1] = std::move(elem)</code>操作。</li>
<li>不断重复这个过程，直到数组中全部元素有序。<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 插入排序：版本 2</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> BidirectionalIterator, <span class="keyword">typename</span> Comp&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertion_sort</span><span class="params">( BidirectionalIterator first, BidirectionalIterator last, Comp comp )</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>( first == last ) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">auto</span> sorted = first;</div><div class="line">    <span class="keyword">for</span>( ++sorted; sorted != last; ++sorted ) &#123;</div><div class="line">        <span class="keyword">auto</span> left = sorted, current = sorted;</div><div class="line">        <span class="keyword">auto</span> elem = *current;</div><div class="line">        <span class="keyword">for</span>( --left; current != first &amp;&amp; comp( elem, *left ); --current )&#123;</div><div class="line">            *current = <span class="built_in">std</span>::move( *left );</div><div class="line">            <span class="keyword">if</span>( left != first ) &#123;                  <span class="comment">// 防止 left 指向无效的范围</span></div><div class="line">                --left;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        *current = <span class="built_in">std</span>::move( elem );</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>　　可以注意到在内部循环中，为了防止迭代器<code>left</code>指向无效的范围，每次都需要判断<code>left != first</code>，我们可以优化代码，以避免这种判断：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 插入排序：版本 3</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> BidirectionalIterator, <span class="keyword">typename</span> Comp&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertion_sort</span><span class="params">( BidirectionalIterator first, BidirectionalIterator last, Comp comp )</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>( first == last ) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">auto</span> sorted = first;</div><div class="line">    <span class="keyword">for</span>( ++sorted; sorted != last; ++sorted ) &#123;</div><div class="line">        <span class="keyword">auto</span> left = sorted, current = sorted;</div><div class="line">        <span class="keyword">auto</span> elem = <span class="built_in">std</span>::move( *current );</div><div class="line">        <span class="keyword">for</span>( ; current != first &amp;&amp; comp( elem, *(--left) ); --current )&#123;</div><div class="line">            *current = <span class="built_in">std</span>::move( *left );</div><div class="line">        &#125;</div><div class="line">        *current = <span class="built_in">std</span>::move( elem );</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　与选择排序不同，插入排序算法的运行时间将取决于输入元素的有序性，假定原来数组就已经是有序的，那么使用选择排序的执行时间是$O(N^2)$，而使用插入排序的执行时间则是$O(N)$。<br>　　性能分析：使用插入排序算法排序数组，在平均情况下需要执行$N^2/4$次<code>comp()</code>操作和$N^2/4$次<code>swap()</code>操作，而在最坏情况下，需要执行$N^2/2$次<code>comp()</code>操作和$N^2/2$次<code>swap()</code>操作。<br>　　一种特定情况是，假定我们在包含有序元素的文件之后追加数据，这时使用插入排序将是比较好的选择，而这时选择排序和冒泡排序都不适合。</p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>　　假定数组arr中有N个元素，那么冒泡排序算法的执行过程：</p>
<ul>
<li>若<code>a[1]</code>大于<code>a[0]</code>，则交换这两个元素，同样，若<code>a[2]</code>大于<code>a[1]</code>，则交换这两个元素，以此类推，那么最后数组中最大的元素就在数组的最后一个位置，这样，下一趟排序只需要对<code>a[0]</code>到<code>a[N-2]</code>的元素进行排序，因此，我们可以使迭代器<code>last</code>指向元素<code>a[N-1]</code>，这样，<code>first</code>和<code>last</code>迭代器指向元素的有效范围就是<code>a[0]</code>到<code>a[N-2]</code>了。</li>
<li>不断重复这个过程，直到数组中全部元素有序。<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 冒泡排序：版本1</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator, <span class="keyword">typename</span> Comp&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">( ForwardIterator first, ForwardIterator last, Comp comp )</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>( first == last ) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::swap;</div><div class="line">    ForwardIterator current, right;</div><div class="line">    <span class="keyword">for</span>( ; last != first; last = current ) &#123;</div><div class="line">        current = right = first;</div><div class="line">        <span class="keyword">for</span>( ++right; right != last; ++current, ++right ) &#123;</div><div class="line">            <span class="keyword">if</span>( comp( *right, *current ) ) &#123;</div><div class="line">                swap( *right, *current );</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">( ForwardIterator first, ForwardIterator last )</span> </span>&#123;</div><div class="line">    bubble_sort( first, last, <span class="built_in">std</span>::less&lt;<span class="keyword">decltype</span>(*first)&gt;&#123;&#125; );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>　　同样，由于冒泡排序算法支持<code>forward iterator</code>，因此，可以使用冒泡排序算法对<code>forward_list</code>或<code>list</code>容器进行排序。<br>　　实际上，我们可以对冒泡排序算法进行改进，很显然，假定我们使用冒泡排序算法对已经有序的数组进行排序，那么在一趟排序中，实际上并不需要对元素进行交换，此时，可以使用一个<code>swapped</code>变量来记录算法是否交换了元素，若没有交换元素，则说明元素本来就是有序的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 冒泡排序：版本2</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator, <span class="keyword">typename</span> Comp&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">( ForwardIterator first, ForwardIterator last, Comp comp )</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>( first == last ) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::swap;</div><div class="line">    <span class="keyword">bool</span> swapped;</div><div class="line">    ForwardIterator current, right;</div><div class="line">    <span class="keyword">for</span>( ; last != first; last = current ) &#123;</div><div class="line">        swapped = <span class="literal">false</span>;</div><div class="line">        current = right = first;</div><div class="line">        <span class="keyword">for</span>( ++right; right != last; ++current, ++right ) &#123;</div><div class="line">            <span class="keyword">if</span>( comp( *right, *current ) ) &#123;</div><div class="line">                swapped = <span class="literal">true</span>;</div><div class="line">                swap( *right, *current );</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>( !swapped ) &#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　性能分析：无论是平均情况或是最坏情况，冒泡排序算法都需要执行$N^2/2$次<code>comp()</code>操作和$N^2/2$次<code>swap()</code>操作。在最好情况下，假定数组中的元素本来就是有序的，那么使用改进后的冒泡排序算法所需的时间为<code>O(N)</code>。<br>　　若数组中的元素是部分有序的，那么使用冒泡排序或是插入排序都是较好的选择。</p>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>　　在插入排序算法中，每次只能对相邻的元素进行比较，因此，假定一开始最小的元素位于数组的末尾，那么我们需要执行<code>N-1</code>次比较才能将这个最小的元素移动到数组的头部。<br>　　如果我们对相隔为<code>k</code>的元素进行比较，而不是对相邻的元素进行比较，那么我们可以在插入排序的基础上实现希尔排序，这个<code>k</code>就称为步长。</p>
<p>　　例如，假定我们有<code>10</code>个元素需要排序：<br><img src="/images/data-structure/s1.png" alt=""><br>　　那么若设置步长为<code>3</code>，则可以将这<code>10</code>个元素分成<code>3</code>组，颜色相同的代表同一组：<br><img src="/images/data-structure/s2.png" alt=""><br>　　这时，就得到了<code>[23, 8, 21, 87]</code>、<code>[45, 50, 2]</code>和<code>[12, 33, 19]</code>这三组元素。分别使用插入排序算法对这三组元素进行排序，这时这三组元素就是<code>[8, 21, 23, 87]</code>、<code>[2, 45, 50]</code>和<code>[12, 19, 33]</code>，那么，原来的数组中的元素就变得比较靠近其最终位置了：<br><img src="/images/data-structure/s3.png" alt=""><br>　　我们知道，要是数组中的元素比较靠近元素最终在数组中的位置，这时使用插入排序来排序数组则可以取得较好的执行性能。因此，在这里，只要再执行一次步长为<code>1</code>的插入排序，那么数组中的全部元素就会变得有序了。</p>
<p>　　实际上，希尔排序的执行性能取决于步长的选择，一种较好的步长选择为<code>[1, 4, 13, 40, 121, 364, 1093,...]</code>。我们使用这个步长来实现希尔排序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIterator, <span class="keyword">typename</span> Comp&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">( RandomIterator first, RandomIterator last, Comp comp )</span> </span>&#123;</div><div class="line">    <span class="keyword">auto</span> size = last - first;</div><div class="line">    <span class="keyword">decltype</span>(size) step;</div><div class="line">    <span class="keyword">for</span>( step = <span class="number">1</span>; step &lt;= size / <span class="number">9</span>; step = step * <span class="number">3</span> + <span class="number">1</span> ) </div><div class="line">        ;</div><div class="line">    <span class="keyword">decltype</span>(first) sorted, current;</div><div class="line">    <span class="keyword">for</span>( ; step &gt;= <span class="number">1</span>; step = ( step - <span class="number">1</span> ) / <span class="number">3</span> ) &#123;</div><div class="line">        <span class="keyword">for</span>( sorted = first + step; sorted != last; ++sorted ) &#123;</div><div class="line">            current = sorted;</div><div class="line">            <span class="keyword">auto</span> elem = <span class="built_in">std</span>::move( *current );</div><div class="line">            <span class="keyword">while</span>( current &gt;= first + step &amp;&amp; comp( elem, *( current - step ) ) ) &#123;</div><div class="line">                *current = <span class="built_in">std</span>::move( *( current - step ) );</div><div class="line">                current -= step;</div><div class="line">            &#125;</div><div class="line">            *current = <span class="built_in">std</span>::move( elem );</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIterator&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">( RandomIterator first, RandomIterator last )</span> </span>&#123;</div><div class="line">    shell_sort( first, last, <span class="built_in">std</span>::less&lt;<span class="keyword">decltype</span>(*first)&gt;&#123;&#125; );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　性能分析：我们使用这个步长<code>[1, 4, 13, 40, 121, 364, 1093,...]</code>来实现希尔排序，则对于含有<code>N</code>个元素的数组，最多需要执行$O(N^{3/2})$次比较操作。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.amazon.com/Accelerated-C-Practical-Programming-Example/dp/020170353X/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1422256119&amp;sr=1-1&amp;keywords=accelerated+c%2B%2B" target="_blank" rel="external">Accelerated C++</a></li>
<li><a href="http://www.amazon.com/Algorithms-Parts-1-4-Fundamentals-Structure/dp/0201350882" target="_blank" rel="external">Algorithms in C++ 3rd Edition by Robert Sedgewick</a></li>
<li><a href="http://www.amazon.com/Data-Structures-Algorithm-Analysis-C/dp/013284737X/ref=sr_1_4?s=books&amp;ie=UTF8&amp;qid=1422255950&amp;sr=1-4&amp;keywords=data+structure+and+algorithm+in+c%2B%2B" target="_blank" rel="external">Data Structures and Algorithm Analysis in C++ 4th Edition by Mark A. Weiss</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="John Doe" />
          <p class="site-author-name" itemprop="name">John Doe</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">97</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">14</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">17</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  

  

  

  

</body>
</html>
